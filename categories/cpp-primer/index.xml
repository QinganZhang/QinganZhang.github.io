<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>cpp-primer on Paul&#39;s Blog</title>
    <link>https://qinganzhang.github.io/categories/cpp-primer/</link>
    <description>Recent content in cpp-primer on Paul&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 27 Feb 2024 15:59:07 +0800</lastBuildDate><atom:link href="https://qinganzhang.github.io/categories/cpp-primer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ch19 特殊工具与技术</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch19-%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Tue, 27 Feb 2024 15:59:07 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch19-%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF/</guid>
      <description>第十八章 用于大型程序的工具 18.1 异常处理 18.2 命名空间 命名空间定义 语法相关： 只要能出现在全局作用域的声明就能置于命名空间中 命名空间不能定义在函数或类</description>
      <content:encoded><![CDATA[<h1 id="第十八章-用于大型程序的工具">第十八章 用于大型程序的工具</h1>
<h2 id="181-异常处理">18.1 异常处理</h2>
<h2 id="182-命名空间">18.2 命名空间</h2>
<h3 id="命名空间定义">命名空间定义</h3>
<ul>
<li>语法相关：
<ul>
<li>只要能出现在全局作用域的声明就能置于命名空间中</li>
<li>命名空间不能定义在函数或类内部</li>
<li>每个命名空间是一个作用域。</li>
<li>命名空间可以不连续，即同一命名空间可以定义为几个不同的部分，在多处出现
<ul>
<li>在头文件中声明命名空间中的成员，在源文件中定义命名空间中的成员</li>
</ul>
</li>
<li>通常不将<code>#include</code>放在命名空间中，否则会将该头文件中的所有名字定义为该命名空间中的成员</li>
</ul>
</li>
<li>几种命名空间
<ul>
<li>全局命名空间：使用<code>::</code>显式指明</li>
<li>嵌套命名空间</li>
<li>内联命名空间：无需使用该命名空间的前缀，通过外层命名空间就可以直接访问。
<ul>
<li>inline必须出现在命名空间第一次定义的地方，后续打开命名空间时可以不加inline</li>
<li>程序代码更新版本时经常使用内联空间，当前版本放在内联空间中，历史版本放在非内联空间中，
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* 文件名：FifthEd.h */</span> 
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">namespace</span> <span class="n">FifthEd</span><span class="p">{</span> <span class="c1">//定义第五版命名空间，是内联，使用时不需显式指定该空间的名字 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">class</span> <span class="nc">Query_base</span><span class="p">{</span><span class="cm">/* 类的定义 */</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：FourthEd.h */</span> 
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">FourthEd</span><span class="p">{</span> <span class="c1">//定义第四版命名空间 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">class</span> <span class="nc">Query_base</span><span class="p">{</span><span class="cm">/* 类的定义 */</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：cplusplus_primer.h */</span> 
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">cplusplus_primer</span><span class="p">{</span> <span class="c1">//将上面两个命名空间嵌套进外层空间 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="cp">#include&#34;FifthEd.h&#34; </span><span class="c1">//引入头文件中的所有名字 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="cp">#include&#34;FourthEd.h&#34; 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：main.cc */</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#include&#34;cplusplus_primer.h&#34; 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">cplusplus_primer</span><span class="o">::</span><span class="n">Query_base</span><span class="p">;</span> <span class="c1">//默认使用第五版中的成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">cplusplus_primer</span><span class="o">::</span><span class="n">FourthEd</span><span class="o">::</span><span class="n">Query_base</span><span class="p">;</span> <span class="c1">//手动指定第四版中的成员
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>未命名的命名空间
<ul>
<li>未命名的命名空间可以在一个文件内不连续（是同一个命名空间），但是不可跨越文件（否则是两个无关的命名空间）</li>
<li>未命名的命名空间中定义的变量拥有静态的声明周期：在第一次使用前创建，直到程序结束才销毁。</li>
<li>如果头文件中定义了未命名的命名空间，则不同源文件中包含了该头文件后，该空间中的名字对应不同实体</li>
<li>未命名的命名空间中的名字可以跨越到上一次作用域，因此定义在未命名的命名空间中的名字可以直接使用，不能对未命名的命名空间的成员使用作用域算符</li>
<li>应用：未命名的命名空间取代文件中的静态声明
<ul>
<li>原来将全局变量声明为<code>static</code>以转变为内部变量（C方式）</li>
<li>现在将全局变量放在未命名的命名空间中（C++方式，原因见上述语法），但是此时全局变量仍然是外部的，</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用命名空间成员">使用命名空间成员</h3>
<ul>
<li>命名空间的别名：<code>namespace new_name = old_name1::old_name2;</code>
<ul>
<li>一个命名空间可以有多个别名，但不能在未定义命名空间之前就声明别名</li>
</ul>
</li>
<li><code>using</code>声明：<code>using my_namespace::mem;</code>
<ul>
<li>一次只能引入命名空间的一个成员</li>
<li>声明的名字的作用域与using语句本身的作用域一致</li>
<li>在类作用域中<code>using</code>声明只能声明基类成员</li>
</ul>
</li>
<li><code>using</code>指示：<code>using nemespace my_namespace;</code>
<ul>
<li>引入命名空间中所有名字</li>
<li>using指示将命名空间注入到外层作用域，即将命名空间中所有名字出现在最近的外层作用域中（相当于using声明的外层作用域）</li>
<li>不可出现在类作用域</li>
</ul>
</li>
<li>命名空间污染：
<ul>
<li>使用了多个命名空间的using指示后，外层作用域中来自不同命名空间的名字可能发生冲突，这种冲突允许存在，但是使用时需要使用<code>::</code>明确指定版本</li>
<li>在头文件中，不要在全局作用域中使用using声明/指示，最多在函数、命名空间中使用</li>
<li>using指示引发的二义性错误只有在使用冲突名字的地方才会被发现，难以定位bug</li>
<li>尽量使用using声明而非using指示</li>
</ul>
</li>
</ul>
<h3 id="类命名空间与作用域">类、命名空间与作用域</h3>
<ul>
<li>名字查找的例外：给函数传递类类型对象/引用/指针时，先在常规的作用域中查找函数名，随后还会在实参类（及其基类）所属的命名空间中查找函数名。
<ul>
<li>这个规则使得概念上作为接口一部分的非成员函数不需单独using声明就可被程序使用</li>
<li>例子：<code>std::cin&gt;&gt;str;</code>表达式中，作用域中没有声明<code>operator&gt;&gt;()</code>函数，但是仍可以使用，这是因为在<code>istream</code>（实参<code>std::cin</code>所属类）和<code>string</code>（实参<code>str</code>所属类）所在的命名空间中进行了查找。否则需要显式声明：<code>using std::operator&gt;&gt;</code>，使用<code>operator&gt;&gt;(std::cin, str);</code></li>
</ul>
</li>
<li>友元相关：
<ul>
<li>当类声明友元时，还需要在类外给出友元的正式声明</li>
<li>一个未声明的类/函数若第一次出现在友元声明中，则认为它是最近的外层命名空间的成员。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">A</span><span class="p">{</span> 
</span></span><span class="line"><span class="cl">	<span class="k">class</span> <span class="nc">C</span><span class="p">{</span> <span class="c1">//这2个友元声明时还没有正式声明，认为它是最近的外层空间的成员，即隐式声明为空间A的成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">friend</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">();</span> <span class="c1">//没有形参 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">friend</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">//接受C类型对象作为实参 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span> 
</span></span><span class="line"><span class="cl">	<span class="n">A</span><span class="o">::</span><span class="n">C</span> <span class="n">cobj</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="n">f</span><span class="p">(</span><span class="n">cobj</span><span class="p">);</span> <span class="c1">//对，f被隐式声明为A的成员，且实参决定会在A中查找函数f 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">f2</span><span class="p">();</span> <span class="c1">//错，虽然f2被隐式声明为A的成员，但未显式指明 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="重载与命名空间">重载与命名空间</h3>
<ul>
<li><code>using</code>声明
<ul>
<li><code>using</code>声明语句声明的是一个名字，而非特定的函数，也就是包括该函数的所有版本，都被引入到当前作用域中。</li>
<li><code>using</code>声明引入的函数将重载该声明语句所属作用域中已有的同名函数。</li>
</ul>
</li>
<li><code>using</code>指示
<ul>
<li>若命名空间中函数名与外层作用域中函数同名，即使函数同名同参也不会报错，只需要使用时指明版本</li>
</ul>
</li>
</ul>
<h2 id="183-多重继承与虚继承">18.3 多重继承与虚继承</h2>
<h3 id="多重继承">多重继承</h3>
<ul>
<li>可以从多个基类中继承构造函数，但是这些构造函数必须形参列表不同
<ul>
<li>如果相同，则派生类必须为这种形参列表的构造函数定义自己的版本</li>
</ul>
</li>
</ul>
<h3 id="类型转换与多个基类">类型转换与多个基类</h3>
<ul>
<li>在派生类向基类的转换中，如果有多个基类，编译器不会进行比较，转换到任何基类一样好</li>
<li>对象的指针/引用的静态类型决定了哪些成员可见</li>
</ul>
<h3 id="多重继承下的类作用域">多重继承下的类作用域</h3>
<ul>
<li>在派生类中使用了某个名字，则程序并行的在多个基类中查找名字
<ul>
<li>派生类继承多个基类的同名成员合法，只是使用时需要<code>::</code>指明版本</li>
<li>派生类只是引入潜在的二义性，如果不调用该重名的对象，则不会报错</li>
</ul>
<ul>
<li>只有使用该重名对象时，才会产生二义性报错
<ul>
<li>该名字在多个基类中是形参列表不同的函数</li>
<li>该名字在一个基类中是private，而在另一个基类中是public/protected</li>
<li>该名字在一个基类中直接找到，而在另一个基类的间接基类中找到</li>
</ul>
</li>
<li>避免这种二义性的方法是在派生类中再定义一次这个名字，覆盖基类名字，避免在基类中查找</li>
</ul>
</li>
<li>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。</li>
</ul>
<h3 id="虚继承">虚继承</h3>
<ul>
<li>背景：菱形继承中，间接基类应该只有一个，如果不使用虚继承，则间接基类在派生类对象中有两个部分</li>
<li>虚继承：令某个类做出声明，承诺愿意共享它的基类。被共享的基类子对象称为<strong>虚基类</strong>，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。
<ul>
<li>经常并不知道一个类是否会被继承多次，因此不知道由它而来的派生是否应该是虚派生</li>
<li>实际编程中，位于中间层次的类将其继承基类的方式声明为虚继承并不会出问题。虚派生只影响从虚基类的派生类中进一步派生出的类，它不影响虚基类的派生类。</li>
</ul>
</li>
<li>语法相关：
<ul>
<li>在派生列表中添加<code>virtual</code>，表示后续的派生类共享虚基类的同一份实例</li>
<li>菱形继承：类B定义了成员x，D1和D2由B虚继承得到，D继承自D1和D2，则在D的作用域中，x通过两个基类都可见。若通过D的对象使用x，有几种可能：
<ul>
<li>若D1和D2中都未定义x，则x被解析为B的成员，不存在二义性。因为只在虚基类中有定义</li>
<li>若D1或D2其中之一定义了x，则x被解析为D1或D2的成员，不存在二义性。因为D1和D2是派生类，位于内层作用域，优先级更高</li>
<li>若D1和D2中都定义了x，则直接访问x时是二义性。因为D1和D2的优先级相同</li>
</ul>
</li>
<li>解决二义性最好的方法就是在派生类中为成员自定义新的实例</li>
</ul>
</li>
</ul>
<h3 id="构造函数与虚继承">构造函数与虚继承</h3>
<ul>
<li>在虚派生中，虚基类由最终的派生类在其构造函数初值列表中初始化（越过了继承链），而非由其直接派生类初始化，否则被重复初始化</li>
<li>只要创建了虚基类的派生类对象，该派生类的构造函数就会越过继承链初始化虚基类</li>
<li>含有虚基类的对象的构造顺序：
<ul>
<li>首先使用提供给最终派生类构造函数的初值来初始化虚基类（否则虚基类默认初始化）</li>
<li>一个类可有多个虚基类，这些虚基类的初始化顺序是它们在派生列表中的顺序</li>
<li>然后按照直接基类在派生列表中的顺序初始化非虚基类</li>
</ul>
</li>
<li>构造派生类时，编译器按照直接基类的声明顺序对其依次检查，若基类中含有虚基类，则先构造虚基类，然后按照声明顺序逐一构造其他非虚基类</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch18 用于大型程序的工具</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch18-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:59 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch18-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/</guid>
      <description>第十八章 用于大型程序的工具 18.1 异常处理 18.2 命名空间 命名空间定义 语法相关： 只要能出现在全局作用域的声明就能置于命名空间中 命名空间不能定义在函数或类</description>
      <content:encoded><![CDATA[<h1 id="第十八章-用于大型程序的工具">第十八章 用于大型程序的工具</h1>
<h2 id="181-异常处理">18.1 异常处理</h2>
<h2 id="182-命名空间">18.2 命名空间</h2>
<h3 id="命名空间定义">命名空间定义</h3>
<ul>
<li>语法相关：
<ul>
<li>只要能出现在全局作用域的声明就能置于命名空间中</li>
<li>命名空间不能定义在函数或类内部</li>
<li>每个命名空间是一个作用域。</li>
<li>命名空间可以不连续，即同一命名空间可以定义为几个不同的部分，在多处出现
<ul>
<li>在头文件中声明命名空间中的成员，在源文件中定义命名空间中的成员</li>
</ul>
</li>
<li>通常不将<code>#include</code>放在命名空间中，否则会将该头文件中的所有名字定义为该命名空间中的成员</li>
</ul>
</li>
<li>几种命名空间
<ul>
<li>全局命名空间：使用<code>::</code>显式指明</li>
<li>嵌套命名空间</li>
<li>内联命名空间：无需使用该命名空间的前缀，通过外层命名空间就可以直接访问。
<ul>
<li>inline必须出现在命名空间第一次定义的地方，后续打开命名空间时可以不加inline</li>
<li>程序代码更新版本时经常使用内联空间，当前版本放在内联空间中，历史版本放在非内联空间中，
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* 文件名：FifthEd.h */</span> 
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">namespace</span> <span class="n">FifthEd</span><span class="p">{</span> <span class="c1">//定义第五版命名空间，是内联，使用时不需显式指定该空间的名字 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">class</span> <span class="nc">Query_base</span><span class="p">{</span><span class="cm">/* 类的定义 */</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：FourthEd.h */</span> 
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">FourthEd</span><span class="p">{</span> <span class="c1">//定义第四版命名空间 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">class</span> <span class="nc">Query_base</span><span class="p">{</span><span class="cm">/* 类的定义 */</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：cplusplus_primer.h */</span> 
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">cplusplus_primer</span><span class="p">{</span> <span class="c1">//将上面两个命名空间嵌套进外层空间 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="cp">#include&#34;FifthEd.h&#34; </span><span class="c1">//引入头文件中的所有名字 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="cp">#include&#34;FourthEd.h&#34; 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：main.cc */</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#include&#34;cplusplus_primer.h&#34; 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">cplusplus_primer</span><span class="o">::</span><span class="n">Query_base</span><span class="p">;</span> <span class="c1">//默认使用第五版中的成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">cplusplus_primer</span><span class="o">::</span><span class="n">FourthEd</span><span class="o">::</span><span class="n">Query_base</span><span class="p">;</span> <span class="c1">//手动指定第四版中的成员
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>未命名的命名空间
<ul>
<li>未命名的命名空间可以在一个文件内不连续（是同一个命名空间），但是不可跨越文件（否则是两个无关的命名空间）</li>
<li>未命名的命名空间中定义的变量拥有静态的声明周期：在第一次使用前创建，直到程序结束才销毁。</li>
<li>如果头文件中定义了未命名的命名空间，则不同源文件中包含了该头文件后，该空间中的名字对应不同实体</li>
<li>未命名的命名空间中的名字可以跨越到上一次作用域，因此定义在未命名的命名空间中的名字可以直接使用，不能对未命名的命名空间的成员使用作用域算符</li>
<li>应用：未命名的命名空间取代文件中的静态声明
<ul>
<li>原来将全局变量声明为<code>static</code>以转变为内部变量（C方式）</li>
<li>现在将全局变量放在未命名的命名空间中（C++方式，原因见上述语法），但是此时全局变量仍然是外部的，</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用命名空间成员">使用命名空间成员</h3>
<ul>
<li>命名空间的别名：<code>namespace new_name = old_name1::old_name2;</code>
<ul>
<li>一个命名空间可以有多个别名，但不能在未定义命名空间之前就声明别名</li>
</ul>
</li>
<li><code>using</code>声明：<code>using my_namespace::mem;</code>
<ul>
<li>一次只能引入命名空间的一个成员</li>
<li>声明的名字的作用域与using语句本身的作用域一致</li>
<li>在类作用域中<code>using</code>声明只能声明基类成员</li>
</ul>
</li>
<li><code>using</code>指示：<code>using nemespace my_namespace;</code>
<ul>
<li>引入命名空间中所有名字</li>
<li>using指示将命名空间注入到外层作用域，即将命名空间中所有名字出现在最近的外层作用域中（相当于using声明的外层作用域）</li>
<li>不可出现在类作用域</li>
</ul>
</li>
<li>命名空间污染：
<ul>
<li>使用了多个命名空间的using指示后，外层作用域中来自不同命名空间的名字可能发生冲突，这种冲突允许存在，但是使用时需要使用<code>::</code>明确指定版本</li>
<li>在头文件中，不要在全局作用域中使用using声明/指示，最多在函数、命名空间中使用</li>
<li>using指示引发的二义性错误只有在使用冲突名字的地方才会被发现，难以定位bug</li>
<li>尽量使用using声明而非using指示</li>
</ul>
</li>
</ul>
<h3 id="类命名空间与作用域">类、命名空间与作用域</h3>
<ul>
<li>名字查找的例外：给函数传递类类型对象/引用/指针时，先在常规的作用域中查找函数名，随后还会在实参类（及其基类）所属的命名空间中查找函数名。
<ul>
<li>这个规则使得概念上作为接口一部分的非成员函数不需单独using声明就可被程序使用</li>
<li>例子：<code>std::cin&gt;&gt;str;</code>表达式中，作用域中没有声明<code>operator&gt;&gt;()</code>函数，但是仍可以使用，这是因为在<code>istream</code>（实参<code>std::cin</code>所属类）和<code>string</code>（实参<code>str</code>所属类）所在的命名空间中进行了查找。否则需要显式声明：<code>using std::operator&gt;&gt;</code>，使用<code>operator&gt;&gt;(std::cin, str);</code></li>
</ul>
</li>
<li>友元相关：
<ul>
<li>当类声明友元时，还需要在类外给出友元的正式声明</li>
<li>一个未声明的类/函数若第一次出现在友元声明中，则认为它是最近的外层命名空间的成员。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">A</span><span class="p">{</span> 
</span></span><span class="line"><span class="cl">	<span class="k">class</span> <span class="nc">C</span><span class="p">{</span> <span class="c1">//这2个友元声明时还没有正式声明，认为它是最近的外层空间的成员，即隐式声明为空间A的成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">friend</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">();</span> <span class="c1">//没有形参 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">friend</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">//接受C类型对象作为实参 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span> 
</span></span><span class="line"><span class="cl">	<span class="n">A</span><span class="o">::</span><span class="n">C</span> <span class="n">cobj</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="n">f</span><span class="p">(</span><span class="n">cobj</span><span class="p">);</span> <span class="c1">//对，f被隐式声明为A的成员，且实参决定会在A中查找函数f 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">f2</span><span class="p">();</span> <span class="c1">//错，虽然f2被隐式声明为A的成员，但未显式指明 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="重载与命名空间">重载与命名空间</h3>
<ul>
<li><code>using</code>声明
<ul>
<li><code>using</code>声明语句声明的是一个名字，而非特定的函数，也就是包括该函数的所有版本，都被引入到当前作用域中。</li>
<li><code>using</code>声明引入的函数将重载该声明语句所属作用域中已有的同名函数。</li>
</ul>
</li>
<li><code>using</code>指示
<ul>
<li>若命名空间中函数名与外层作用域中函数同名，即使函数同名同参也不会报错，只需要使用时指明版本</li>
</ul>
</li>
</ul>
<h2 id="183-多重继承与虚继承">18.3 多重继承与虚继承</h2>
<h3 id="多重继承">多重继承</h3>
<ul>
<li>可以从多个基类中继承构造函数，但是这些构造函数必须形参列表不同
<ul>
<li>如果相同，则派生类必须为这种形参列表的构造函数定义自己的版本</li>
</ul>
</li>
</ul>
<h3 id="类型转换与多个基类">类型转换与多个基类</h3>
<ul>
<li>在派生类向基类的转换中，如果有多个基类，编译器不会进行比较，转换到任何基类一样好</li>
<li>对象的指针/引用的静态类型决定了哪些成员可见</li>
</ul>
<h3 id="多重继承下的类作用域">多重继承下的类作用域</h3>
<ul>
<li>在派生类中使用了某个名字，则程序并行的在多个基类中查找名字
<ul>
<li>派生类继承多个基类的同名成员合法，只是使用时需要<code>::</code>指明版本</li>
<li>派生类只是引入潜在的二义性，如果不调用该重名的对象，则不会报错</li>
</ul>
<ul>
<li>只有使用该重名对象时，才会产生二义性报错
<ul>
<li>该名字在多个基类中是形参列表不同的函数</li>
<li>该名字在一个基类中是private，而在另一个基类中是public/protected</li>
<li>该名字在一个基类中直接找到，而在另一个基类的间接基类中找到</li>
</ul>
</li>
<li>避免这种二义性的方法是在派生类中再定义一次这个名字，覆盖基类名字，避免在基类中查找</li>
</ul>
</li>
<li>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。</li>
</ul>
<h3 id="虚继承">虚继承</h3>
<ul>
<li>背景：菱形继承中，间接基类应该只有一个，如果不使用虚继承，则间接基类在派生类对象中有两个部分</li>
<li>虚继承：令某个类做出声明，承诺愿意共享它的基类。被共享的基类子对象称为<strong>虚基类</strong>，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。
<ul>
<li>经常并不知道一个类是否会被继承多次，因此不知道由它而来的派生是否应该是虚派生</li>
<li>实际编程中，位于中间层次的类将其继承基类的方式声明为虚继承并不会出问题。虚派生只影响从虚基类的派生类中进一步派生出的类，它不影响虚基类的派生类。</li>
</ul>
</li>
<li>语法相关：
<ul>
<li>在派生列表中添加<code>virtual</code>，表示后续的派生类共享虚基类的同一份实例</li>
<li>菱形继承：类B定义了成员x，D1和D2由B虚继承得到，D继承自D1和D2，则在D的作用域中，x通过两个基类都可见。若通过D的对象使用x，有几种可能：
<ul>
<li>若D1和D2中都未定义x，则x被解析为B的成员，不存在二义性。因为只在虚基类中有定义</li>
<li>若D1或D2其中之一定义了x，则x被解析为D1或D2的成员，不存在二义性。因为D1和D2是派生类，位于内层作用域，优先级更高</li>
<li>若D1和D2中都定义了x，则直接访问x时是二义性。因为D1和D2的优先级相同</li>
</ul>
</li>
<li>解决二义性最好的方法就是在派生类中为成员自定义新的实例</li>
</ul>
</li>
</ul>
<h3 id="构造函数与虚继承">构造函数与虚继承</h3>
<ul>
<li>在虚派生中，虚基类由最终的派生类在其构造函数初值列表中初始化（越过了继承链），而非由其直接派生类初始化，否则被重复初始化</li>
<li>只要创建了虚基类的派生类对象，该派生类的构造函数就会越过继承链初始化虚基类</li>
<li>含有虚基类的对象的构造顺序：
<ul>
<li>首先使用提供给最终派生类构造函数的初值来初始化虚基类（否则虚基类默认初始化）</li>
<li>一个类可有多个虚基类，这些虚基类的初始化顺序是它们在派生列表中的顺序</li>
<li>然后按照直接基类在派生列表中的顺序初始化非虚基类</li>
</ul>
</li>
<li>构造派生类时，编译器按照直接基类的声明顺序对其依次检查，若基类中含有虚基类，则先构造虚基类，然后按照声明顺序逐一构造其他非虚基类</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch17 标准库特殊设施</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch17-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:50 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch17-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/</guid>
      <description>第十六章 模板和泛型编程 16.1 定义模板 模板参数列表：&amp;lt;&amp;gt; 模板参数（也称(模板)类型参数）：T typename或class（作用相同），</description>
      <content:encoded><![CDATA[<h1 id="第十六章-模板和泛型编程">第十六章 模板和泛型编程</h1>
<h2 id="161-定义模板">16.1 定义模板</h2>
<ul>
<li>模板参数列表：<code>&lt;&gt;</code></li>
<li>模板参数（也称(模板)类型参数）：<code>T</code>
<ul>
<li><code>typename</code>或<code>class</code>（作用相同），用来表示模板参数</li>
</ul>
</li>
<li>模板非类型参数：模板参数列表中表示一个值而非一个类型</li>
</ul>
<h3 id="函数模板">函数模板</h3>
<ul>
<li>模板实例化时，可以使用[[ch16-模板和泛型编程#函数模板显式实参|显式实参]]，根据实参[[ch16-模板和泛型编程#类型转换与模板类型参数|隐式推断模板参数类型]]</li>
<li>模板非类型参数：
<ul>
<li>可以是一个整型、指针或左值引用</li>
<li>实例化时，整型实参必须是常量表达式，指针/引用指向的对象必须有静态的生存周期（即对象不能是非static局部变量或动态对象），这样做可以使编译器在编译时实例化模板</li>
<li>使用场景：比如数组类型作为模板参数时大小固定，但是使用模板非类型参数就不必固定
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">M</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="n">T</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r2</span><span class="p">)[</span><span class="n">M</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">strcmp</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><code>inline</code>或<code>constexpr</code>的函数模板：模板参数列表之后，返回类型之前</li>
<li>模板编译
<ul>
<li>只有模板实例化时，编译器才生成代码</li>
<li>通常将类定义和函数声明放在头文件中，其实现放在源文件中；但是，函数模板和类模板成员函数的实现通常也放在头文件中。因为编译器知道模板的完整定义后才能进行实例化</li>
<li>大多数模板的编译错误在实例化期间才报告</li>
</ul>
</li>
</ul>
<h3 id="类模板">类模板</h3>
<ul>
<li>使用类模板必须提供显式模板参数列表，编译器不能推断模板参数类型</li>
<li>一个类模板的成员函数只有当程序用到它时，才进行<span id="类模板的实例化">实例化</span></li>
<li>使用类模板类型时必须提供模板参数，只有在类模板作用域内部才可以只使用模板名而不提供实参</li>
<li>友元相关，<a href="https://blog.csdn.net/caroline_wendy/article/details/16916441">例子</a>
<ul>
<li>如果一个类模板包含一个非模板友元，则友元可以访问该类模板的所有实例</li>
<li>如果一个类模板包含一个模板友元，则类可以授权给所有友元模板实例，也可以只授权给特定实例
<ul>
<li>一对一友好关系：友好关系被限定在相同类型的友元和类本身之间
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">friend</span> <span class="k">class</span> <span class="nc">Fri</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 比如Fri&lt;int&gt;实例可以访问MyClass&lt;int&gt;实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span> <span class="c1">// 友元函数，重载==
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="p">()</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span><span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span> <span class="nf">clone</span><span class="p">();</span> <span class="c1">// 处于类模板作用域中，编译器会将MyClass当作是MyClass&lt;T&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">clone</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">MyClass</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	  <span class="c1">// 一对一友好关系，Fri&lt;T&gt;是MyClass&lt;T&gt;的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">void</span> <span class="n">size</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	  <span class="c1">// 但是Fri&lt;T&gt;就不是MyClass&lt;K&gt;的友元(T!=K)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">char_class</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_class</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">Fri</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">fri</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">char_class</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// fri.func(int_class);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>    
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>通用和特定的模板友好关系：一个类可以将另一个模板的每个实例都声明为为自己的友元，或者限定特定的实例为友元
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Common</span><span class="p">{</span> <span class="c1">// 普通类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal</span><span class="p">;</span> <span class="c1">// 【Pal的所有实例】都是类Common的友元，此时Fri可以不用提前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span> <span class="c1">// 模板类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">friend</span> <span class="k">class</span> <span class="nc">Fri</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 一对一友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">MyFri</span><span class="p">;</span> <span class="c1">// 【MyPal的所有实例】都是MyClass每个实例的友元，此时MyPal可以不用提前声明，且声明中使用了不同的模板参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">friend</span> <span class="k">class</span> <span class="nc">Commom_fri</span><span class="p">;</span> <span class="c1">// 普通类作为模板类的友元，此时不需要提前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>      
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>虽然友元通常是类或函数，但是允许将模板类型参数<code>T</code>作为友元，因此类型<code>T</code>的对象可以访问类模板的private成员。<a href="https://blog.csdn.net/craftsman1970/article/details/81748184">例子</a>。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">friend</span> <span class="n">T</span><span class="p">;</span> <span class="c1">// 类型T是MyClass的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">private_func</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;private func of MyClass &#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">func</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">		<span class="n">test</span><span class="p">.</span><span class="n">private_func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">;</span> <span class="c1">// 类型Test是MyClass的友元，Test类型的对象可以访问【类模板MyClass基于Test类型的实例】的private成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">Test</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">t</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>模板类型别名
<ul>
<li>为类模板的实例创建别名：<code>typedef MyClass&lt;int&gt; MC;</code></li>
<li>为类模板定义别名：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 固定一个类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>类模板的static成员
<ul>
<li>相同类型类模板的实例的static成员是共享的，不同类型之间类模板的实例的static成员是不同的</li>
</ul>
</li>
</ul>
<h3 id="模板参数">模板参数</h3>
<ul>
<li>模板内不能重用模板参数名，且同一个模板参数名<code>T</code>在同一个模板参数列表中只能出现一次</li>
<li>声明中的模板参数不必与定义中的模板参数相同，且模板声明通常一起放在文件开始位置（使用模板的代码之前）</li>
<li>使用<code>T::mem</code>，无法判断mem是类型T的static成员还是类型T的类型成员
<ul>
<li>普通类中编译器已知类的定义因此可以判断</li>
<li>默认<code>T::mem</code>访问的是static成员</li>
<li>使用<code>typename</code>显式说明访问的是类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">using</span> <span class="n">age</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">;</span> <span class="c1">// 类型成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="c1">// static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Person</span><span class="o">::</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;zhang&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">age</span> <span class="n">func</span><span class="p">(){</span> <span class="c1">// 显式说明T::age是一个类型而非static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">T</span><span class="o">::</span><span class="n">name</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 默认T::name是static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">age</span> <span class="n">myAge</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">myAge</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>默认模板实参：默认模板实参都在最右侧，对函数模板和类模板都可以提供默认模板实参</li>
</ul>
<h3 id="成员模板">成员模板</h3>
<ul>
<li>成员模板：普通类或模板类的成员函数是模板函数，成员模板不能是虚函数</li>
<li>普通类的成员模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span> <span class="c1">// 普通类中包含成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 普通类中的成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 对比模板类中的普通成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span> <span class="n">myClass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 普通类中的成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">Test</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">test</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 模板类中的普通函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>类模板的成员模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">K</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">H</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 类模板的模板参数列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">H</span><span class="o">&gt;</span> <span class="c1">// 类模板的成员模板的模板参数列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">(</span><span class="n">H</span> <span class="n">h</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">H</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myClass</span><span class="p">(</span><span class="sc">&#39;k&#39;</span><span class="p">);</span> <span class="c1">// 显式提供T=int, 隐式推断K=char
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span> <span class="c1">// 隐式推断H=double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;str&#34;</span><span class="p">);</span> <span class="c1">// 显式提供H=string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="显式实例化">显式实例化</h3>
<ul>
<li>背景：模板只有使用时才被实例化，因此相同的实例可能出现在多个文件中，造成额外开销</li>
<li>显式实例化
<ul>
<li>当编译器遇到<code>extern</code>模板声明时，不会在本文件中生成模板的实例化代码，表示使用其他位置的实例化代码</li>
<li><code>extern</code>声明必须出现在使用此实例化版本的代码之前，否则编译器进行实例化，起不到外部定义的效果</li>
<li>显式实例化定义会实例化所有成员</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 在a.cpp中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 实例化声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="kt">int</span> <span class="n">compare</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 在b.cpp中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 实例化定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="效率与灵活性">效率与灵活性</h3>
<ul>
<li>shared_ptr在运行时绑定删除器，因此删除器保存为一个指针而不是一个成员，因此删除器的类型直到运行时才直到，而且可以随时改变删除器的类型
<ul>
<li>需要间接调用删除器，但是用户重载删除器的操作更加便捷（只需要传入一个可调用对象）</li>
</ul>
</li>
<li>unique_ptr在编译期绑定删除器，删除器的类型是类类型的一部分（因此删除器类型在编译器是已知的），从而删除器可以直接保存在成员中
<ul>
<li>避免了间接调用删除器的运行时开销</li>
</ul>
</li>
</ul>
<h2 id="162-函数模板实参推断">16.2 函数模板实参推断</h2>
<ul>
<li>可以[[ch16-模板和泛型编程#类型转换与模板类型参数|基于实参推导模板参数类型]]，也可以[[ch16-模板和泛型编程#函数指针和实参推断|函数指针指向函数模板推导模板参数类型]]</li>
<li>有时比如返回值类型无法推导出来，可以指定[[ch16-模板和泛型编程#函数模板显式实参|模板显式实参]]，也可以使用[[ch16-模板和泛型编程#尾置返回类型与类型转换|尾置返回类型]]（同时可以[[ch16-模板和泛型编程#尾置返回类型后进行类型转换|去除引用]]）</li>
<li>当模板类型<code>T</code>为引用时，需要依据实参是左值/右值来判断T的引用类型，而且可以使用完美转发保持实参的类型不变</li>
</ul>
<h3 id="类型转换与模板类型参数">类型转换与模板类型参数</h3>
<ul>
<li>模板实参推断：根据实参类型推断出模板参数<code>T</code>的类型
<ul>
<li>一般<code>T</code>就是实参类型</li>
<li>编译器会对以下几种实参进行类型转换，得到的<code>T</code>并不完全是实参类型
<ul>
<li>顶层<code>const</code>会被忽略</li>
<li>可以将非const对象的指针或引用传递给一个const的指针或引用形参</li>
<li>如果形参不是引用类型，数组名/函数名转换为指针类型</li>
</ul>
</li>
</ul>
</li>
<li><code>template&lt;typename T&gt; void func(T a, T b);</code>中，a和b推断的类型必须相同</li>
</ul>
<h3 id="函数模板显式实参">函数模板显式实参</h3>
<ul>
<li>背景：类型<code>T</code>只出现在返回值/函数体，不在形参列表中时，编译器无法推断出模板实参的类型：</li>
<li>函数模板显式实参从左到右进行对应，如果模板参数可以推导出来，放在模板参数列表右侧，实例化时可以进行推导</li>
<li>当显式指定实参时，对实参可以使用正常的类型转换</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span> <span class="n">T1</span> <span class="n">sum</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">);</span> <span class="c1">// T1在返回值中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="kt">double</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// T1类型是long long, T2、T3类型可以推导出来，放在右侧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">test</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// T2类型显式指定为long long，因此将a转换为long long型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">compare</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// 使用显式模板实参，a、b都转换为long long类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="尾置返回类型与类型转换">尾置返回类型与类型转换</h3>
<h4 id="尾置返回类型">尾置返回类型</h4>
<ul>
<li>背景：有时函数模板的返回值类型不能由实参推导而来，比如[[ch16-模板和泛型编程#函数模板显式实参|函数模板显式实参]]的背景
<ul>
<li>可以使用函数模板显式实参进行指定，也可以<strong>使用尾置返回类型自动推导</strong></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="n">Iter</span> <span class="n">beg</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">){</span> <span class="c1">// 从局部变量中推导出返回类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="尾置返回类型后进行类型转换">尾置返回类型后进行类型转换</h4>
<ul>
<li>背景：通过模板显式实参可以指定返回值类型，但是通过尾置返回类型推导得到的类型可能不是想要的，比如有时不希望得到引用类型</li>
<li><strong>标准库的类型转换模板</strong>
<ul>
<li>定义在头文件<code>type_traits</code>中，常用于模板元程序设计</li>
<li>Mod是一个类模板，将类型<code>T</code>转换为类型<code>type</code>；如果无法转化，则类型<code>type</code></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="n">Iter</span> <span class="n">beg</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">{</span> <span class="c1">// 表明type是一个类型而非一个static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th><code>Mod</code></th>
<th><code>T</code></th>
<th><code>Mod&lt;T&gt;::type</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_const</code></td>
<td><code>X&amp;</code>或<code>const X</code>或函数</td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>const T</code></td>
</tr>
<tr>
<td><code>add_lvalue_reference</code></td>
<td><code>X&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td><code>X&amp;&amp;</code></td>
<td><code>X&amp;</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;</code></td>
</tr>
<tr>
<td><code>add_rvalue_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;&amp;</code></td>
</tr>
<tr>
<td><code>remove_pointer</code></td>
<td><code>X*</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_pointer</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X*</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T*</code></td>
</tr>
<tr>
<td><code>make_signed</code></td>
<td><code>unsigned X</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>make_unsigned</code></td>
<td>带符号类型</td>
<td><code>unsigned X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_extent</code></td>
<td><code>X[n]</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_all_extents</code></td>
<td><code>X[n1][n2]...</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<h3 id="函数指针和实参推断">函数指针和实参推断</h3>
<ul>
<li>将函数模板赋值给函数指针：
<ul>
<li>函数指针指向函数模板的一个实例</li>
<li>使用函数指针的类型来推断模板实参</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>  <span class="c1">// T是int，f指向函数模板的实例compare(const int&amp;, const int&amp;)
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果函数func的形参是函数指针，实参可以传入函数模板，这样函数指针指向一个模板实例且进行了参数推断
<ul>
<li>但是当func有多个重载的版本时（接受不同类型的函数指针），传入函数模板可能产生歧义，此时可以指定【显式模板实参】</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">));</span> <span class="c1">// 重载
</span></span></span><span class="line"><span class="cl"><span class="c1">// func(compare); // 歧义：函数模板compare实例化为哪一种函数指针？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">func</span><span class="p">(</span><span class="n">compare</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="模板实参推断和引用">模板实参推断和引用</h3>
<h4 id="模板参数t的类型推断">模板参数<code>T&amp;</code>的类型推断</h4>
<table>
<thead>
<tr>
<th style="text-align:center">模板类型参数</th>
<th style="text-align:center">实参要求</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>T&amp;</code></td>
<td style="text-align:center">必须传递一个左值</td>
<td style="text-align:center">实参为<code>int</code>，<code>T</code>为<code>int</code>;实参为<code>const int</code>，<code>T</code>为<code>const int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>const T&amp;</code></td>
<td style="text-align:center">可以传递左值或右值</td>
<td style="text-align:center">实参为<code>int, const int, const int&amp;&amp;</code>，<code>T</code>都为<code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>T&amp;&amp;</code></td>
<td style="text-align:center">必须传递一个右值</td>
<td style="text-align:center">实参为<code>int&amp;&amp;</code>， <code>T</code>为<code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>T&amp;&amp;</code></td>
<td style="text-align:center">例外：传递一个类型为<code>type</code>的左值，推导<code>T</code>为<code>type&amp;</code>类型</td>
<td style="text-align:center">实参为<code>int&amp;</code>,<code>T</code>为<code>int&amp;</code></td>
</tr>
</tbody>
</table>
<h4 id="引用折叠">引用折叠</h4>
<ul>
<li>背景：基于上面这个例外，创造出了引用的引用，或者通过类型别名也可以创造出引用的引用，可以将多个引用折叠为一个引用</li>
<li>引用折叠规则：
<ul>
<li><code>type&amp; &amp;、 type&amp; &amp;&amp;、 type&amp;&amp; &amp;</code>折叠为<code>type &amp;</code></li>
<li><code>type&amp;&amp; &amp;&amp;</code>折叠为<code>T&amp;&amp;</code></li>
</ul>
</li>
<li>使用：
<ul>
<li>若函数形参是<code>T&amp;&amp;</code>，则可以传递一个左值（实参的const属性可以保持，因为是底层const）</li>
<li>如果传入的是左值<code>type&amp;</code>，推导出<code>T=type&amp;</code></li>
<li>万能引用（或称为模板类型参数右值引用）：函数形参为<code>T&amp;&amp;</code>时，传递左值/右值均可
<ul>
<li>使用万能引用导致只有在运行时才能确定形参是左值还是右值，使得模板的编写变得困难</li>
<li>通常在两种情况中使用万能引用：模板转发实参，模板重载</li>
<li>使用万能引用的形参通常重载为两个版本：
<ul>
<li>拷贝版本：<code>template&lt;typename T&gt; void f(const T&amp;)</code>  绑定到左值和const右值</li>
<li>移动版本：<code>template&lt;typename T&gt; void f(T&amp;&amp;)</code> 绑定到非const右值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="stdmove"><code>std::move</code></h4>
<ul>
<li>[[ch13-拷贝控制#^d3a2a0|std::move函数]]的定义：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>可以使用<code>static_cast</code>显式地将左值转换为右值引用</li>
</ul>
<h3 id="转发">转发</h3>
<ul>
<li>背景：比如函数f内部调用函数g时，可能需要将f的实参传递给g，而且同时要求保持实参性质不变（比如const属性，左值/右值属性）
<ul>
<li>即希望达到这样的效果：将实参传递给f，再传递给g，与实参直接传递给g，的效果等价</li>
<li>例子一：f形参类型是非引用，g形参类型是左值引用，传入一个左值引用，则此时f转发参数给g时会使用自己的拷贝而非原来的引用</li>
<li>例子二：f形参类型是万能引用<code>T&amp;&amp;</code>，g形参类型是右值引用，f可以接受右值（或左值），此时f转发参数给g时，使用的右值引用本身是一个左值，不能传参给g的右值引用</li>
</ul>
</li>
<li>比较：都是定义在<code>utility</code>中的函数模板，最好显式指明是<code>std::</code>中的
<ul>
<li><code>std::forward</code>：可指定模板参数，并且可以对返回值使用引用折叠来保留左右值属性</li>
<li><code>std::move</code>：返回值一定是右值引用</li>
</ul>
</li>
<li>使用：完美转发
<ul>
<li>通过万能引用在传入外层f时保留实参的全部属性</li>
<li>通过<code>std::forward</code>在传入内层函数g时再次保留实参的全部属性</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">arg</span><span class="p">){</span> <span class="c1">// 万能引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span> <span class="c1">// std::forward&lt;T&gt;的返回类型是T&amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果实参是左值，推导出<code>T=type&amp;</code>，<code>std::forward&lt;T&gt;</code>的返回类型<code>T&amp;&amp;</code>折叠为<code>type&amp;</code></li>
<li>如果实参是右值，推导出<code>T=type</code>，<code>std::forward&lt;T&gt;</code>的返回类型即为<code>type&amp;&amp;</code></li>
</ul>
</li>
<li>例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">flip</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">K</span> <span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34;  &#34;</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">flip</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// F=void(*)(int&amp;&amp;, int&amp;), T=int&amp;, K=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">flip</span><span class="p">(</span><span class="n">g</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// F=void(*)(int&amp;&amp;, int&amp;), T=int&amp;, K=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="163-重载与模板">16.3 重载与模板</h2>
<ul>
<li>函数模板可以被另一个函数模板或普通函数重载
<ul>
<li>[[ch06-函数#6.6 函数匹配|函数的重载与匹配]]：有一些重载的函数，根据实参情况，调用时用哪个函数？</li>
<li>函数模板的重载与匹配：有一些重载的函数模板和普通函数，根据实参情况（函数模板进行函数模板实参推断），实例化并调用哪个函数模板</li>
</ul>
</li>
<li>到函数模板的函数匹配规则（[[ch06-函数#6.6 函数匹配|普通函数匹配的拓展]]）
<ul>
<li>确定候选函数：同名的函数，包括实参推断成功的函数模板实例</li>
<li>确定可行函数：参数类型和数量都匹配，
<ul>
<li>候选的函数模板实例都是可行的，因为实参推断会排除掉不可行的模板</li>
</ul>
</li>
<li>按照类型转换进行排序，寻找最佳匹配（普通函数和函数模板实例都可能发生类型转换，只是应用于函数模板的[[ch16-模板和泛型编程#类型转换与模板类型参数|类型转换]]十分有限）
<ul>
<li>若恰有一个函数提供比其他函数都好的匹配，则选择它</li>
<li>如果多个函数都提供相同级别的匹配
<ul>
<li>非模板和模板重载：如果只有一个是非模板函数，选择非模板函数</li>
<li>多个可行模板：如果没有非模板函数（有多个函数模板），选择最特例化的函数模板（特例化：比如<code>T&amp;</code>可以匹配任意类型，<code>T*</code>只能匹配指针类型）</li>
<li>调用有歧义，失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最佳实践：在定义重载函数之前，应该先声明所有重载的版本，否则可能重载一个模板函数进行实例化（因为没有找到想使用的版本，使用函数模板进行实例化），编译期不会报错，但是运行期会调用不期望使用的版本</li>
</ul>
<h2 id="164-可变参数模板">16.4 可变参数模板</h2>
<ul>
<li><strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类，可变数目的参数被称为<strong>参数包</strong>
<ul>
<li>模板参数包：表示零个或多个模板参数（模板类型参数或模板非类型参数）
<ul>
<li><code>typename</code>后跟<code>...</code>表示模板类型参数包</li>
<li>类型名后跟<code>...</code>表示模板非类型参数包</li>
</ul>
</li>
<li>函数参数包：表示零个或多个函数参数。</li>
</ul>
</li>
<li><code>sizeof...</code>运算符：返回参数包中的元素数量，且不会对其实参求值（类似于sizeof）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span> <span class="c1">// 模板参数包：Args是模板类型参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="p">...</span> <span class="n">rest</span><span class="p">){</span>  <span class="c1">// 函数参数包：rest是函数参数包（其类型是模板参数包Args）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">rest</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="编写可变参数函数模板">编写可变参数函数模板</h3>
<ul>
<li>[[ch06-函数#可变形参|可变形参]]<code>initializer_list</code>可以接受可变数目实参，但是需要是相同类型的</li>
<li>可变参数函数通常是递归的
<ul>
<li>第一步调用处理参数包中的第一个实参，然后用剩余实参调用自身</li>
<li>还需要定义一个非可变参数的函数（因为函数匹配时会使用这个更加特例化的版本，而不是使用0个参数的可变参数模板的实例），来处理参数包中最后一个实参</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="c1">// 打印最后一个元素，用来终止递归，必须在可变参数版本的print定义之前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rest</span><span class="p">...);</span>   <span class="c1">// 递归调用，实参是将除了第一个，剩余的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="包扩展">包扩展</h3>
<ul>
<li>扩展<code>...</code>：将参数包分解为单个元素，每个元素应用模式，得到拓展后的列表</li>
<li>常用情况：
<ul>
<li><code>const Args&amp; ...</code>：将模板参数包<code>Args</code>中所有类型<code>T</code>都扩展为<code>const T&amp;</code></li>
<li><code>args...</code>：将函数参数包<code>args</code>扩展为参数列表</li>
<li><code>f(args)...</code>：对函数参数包<code>args</code>中每个元素调用函数<code>f</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">){</span> <span class="c1">// 扩展模板参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">debug_reg</span><span class="p">(</span><span class="n">rest</span><span class="p">)...);</span> <span class="c1">// 扩展函数参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="转发参数包">转发参数包</h3>
<ul>
<li>组合使用可变参数模板和<code>forward</code>机制，实现将可变参数的完美转发，例子：<code>emplace_back</code></li>
<li>如果同时存在模板参数包和函数参数包，则同时拓展：
<ul>
<li><code>f&lt;Args&gt;(args)...</code>等价于<code>f&lt;Args1&gt;(args1), f&lt;Args2&gt;(args2), ... </code></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">work</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="165-模板特例化specializations">16.5 模板特例化（Specializations）</h2>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=03b4a1a4-b85a-ef1b-901a-178f5542609b&amp;page=650&amp;rect=86.880,83.040,255.996,90.480">背景和例子</a>：对于某个类型，不想用（对特定类型可以做优化）或者不能用（对特定类型的使用并非预期）模板</li>
</ul>
<h3 id="定义函数模板特例化">定义函数模板特例化</h3>
<ul>
<li>必须为原模板中每个模板参数都提供实参（全特例化）</li>
<li>关键字<code>template</code>后面跟一个空尖括号对（<code>&lt;&gt;</code>），表示所有模板参数都已被指定</li>
<li>特例化版本的参数类型必须与一个先前声明的模板中对应的类型相匹配。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">// T为const char*
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="函数重载与模板特例化">函数重载与模板特例化</h3>
<ul>
<li>特例化的本质是实例化一个模板，而不是重载它。因此特例化不影响[[ch16-模板和泛型编程#16.3 重载与模板|函数的匹配规则]]，即非模板函数先，再是特例化版本的函数（模板的实例化），最后是函数模板的实例</li>
<li>最佳实践：模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是特例化版本。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span> <span class="c1">// 特例化版本，T为const char*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span> <span class="c1">// 普通函数
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="类模板特例化">类模板特例化</h3>
<ul>
<li>必须在原模板定义所在的命名空间中进行类模板特例化</li>
<li>类模板可以进行部分特例化（偏特例化），得到的是模板；也可以全部特例化（全特例化），得到的是实例</li>
<li>类模板的部分特例化
<ul>
<li>未完全确定类型的模板参数仍放在<code>&lt;&gt;</code>中，即偏特化的模板参数列表非空。使用时也需提供模板实参，这些实参与原始模板中的参数按位置对应</li>
<li>部分特例化的模板参数列表是原始模板参数列表的一个子集或者特例化版本</li>
<li>例子：标准库remove_reference类型是通过一系列的特例化版本来完成其功能的
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//原始的、最通用的版本，可用于任意类型实例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span> <span class="p">{</span>  <span class="c1">//针对于左值引用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span> <span class="p">{</span> <span class="c1">//针对于右值引用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//调用原始模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">a</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//decltype(i)==int&amp;，调用第一个（T&amp;）部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">b</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//decltype(std::move(i))==int&amp;&amp;，调用第二个（T&amp;&amp;）部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">c</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//a、b、c均为int
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>特例化成员函数而不是整个类
<ul>
<li>使用模板的实例调用成员时，若该实例的模板实参与特化该成员时的参数一致，则调用特化版本的成员</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="p">())</span> <span class="o">:</span><span class="n">mem</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span> <span class="c1">//通用的Bar()函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">T</span> <span class="n">mem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//特例化Foo&lt;int&gt;版本的的成员Bar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Bar</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">Foo</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">fs</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="n">fs</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>       <span class="c1">//使用Foo&lt;string&gt;的通用的Bar()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fi</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">	<span class="n">fi</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>       <span class="c1">//使用Foo&lt;int&gt;的特例化的Bar()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch16 模板和泛型编程</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:40 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</guid>
      <description>第十六章 模板和泛型编程 16.1 定义模板 模板参数列表：&amp;lt;&amp;gt; 模板参数（也称(模板)类型参数）：T typename或class（作用相同），</description>
      <content:encoded><![CDATA[<h1 id="第十六章-模板和泛型编程">第十六章 模板和泛型编程</h1>
<h2 id="161-定义模板">16.1 定义模板</h2>
<ul>
<li>模板参数列表：<code>&lt;&gt;</code></li>
<li>模板参数（也称(模板)类型参数）：<code>T</code>
<ul>
<li><code>typename</code>或<code>class</code>（作用相同），用来表示模板参数</li>
</ul>
</li>
<li>模板非类型参数：模板参数列表中表示一个值而非一个类型</li>
</ul>
<h3 id="函数模板">函数模板</h3>
<ul>
<li>模板实例化时，可以使用[[ch16-模板和泛型编程#函数模板显式实参|显式实参]]，根据实参[[ch16-模板和泛型编程#类型转换与模板类型参数|隐式推断模板参数类型]]</li>
<li>模板非类型参数：
<ul>
<li>可以是一个整型、指针或左值引用</li>
<li>实例化时，整型实参必须是常量表达式，指针/引用指向的对象必须有静态的生存周期（即对象不能是非static局部变量或动态对象），这样做可以使编译器在编译时实例化模板</li>
<li>使用场景：比如数组类型作为模板参数时大小固定，但是使用模板非类型参数就不必固定
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">M</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="n">T</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r2</span><span class="p">)[</span><span class="n">M</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">strcmp</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><code>inline</code>或<code>constexpr</code>的函数模板：模板参数列表之后，返回类型之前</li>
<li>模板编译
<ul>
<li>只有模板实例化时，编译器才生成代码</li>
<li>通常将类定义和函数声明放在头文件中，其实现放在源文件中；但是，函数模板和类模板成员函数的实现通常也放在头文件中。因为编译器知道模板的完整定义后才能进行实例化</li>
<li>大多数模板的编译错误在实例化期间才报告</li>
</ul>
</li>
</ul>
<h3 id="类模板">类模板</h3>
<ul>
<li>使用类模板必须提供显式模板参数列表，编译器不能推断模板参数类型</li>
<li>一个类模板的成员函数只有当程序用到它时，才进行<span id="类模板的实例化">实例化</span></li>
<li>使用类模板类型时必须提供模板参数，只有在类模板作用域内部才可以只使用模板名而不提供实参</li>
<li>友元相关，<a href="https://blog.csdn.net/caroline_wendy/article/details/16916441">例子</a>
<ul>
<li>如果一个类模板包含一个非模板友元，则友元可以访问该类模板的所有实例</li>
<li>如果一个类模板包含一个模板友元，则类可以授权给所有友元模板实例，也可以只授权给特定实例
<ul>
<li>一对一友好关系：友好关系被限定在相同类型的友元和类本身之间
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">friend</span> <span class="k">class</span> <span class="nc">Fri</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 比如Fri&lt;int&gt;实例可以访问MyClass&lt;int&gt;实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span> <span class="c1">// 友元函数，重载==
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="p">()</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span><span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span> <span class="nf">clone</span><span class="p">();</span> <span class="c1">// 处于类模板作用域中，编译器会将MyClass当作是MyClass&lt;T&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">clone</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">MyClass</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	  <span class="c1">// 一对一友好关系，Fri&lt;T&gt;是MyClass&lt;T&gt;的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">void</span> <span class="n">size</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	  <span class="c1">// 但是Fri&lt;T&gt;就不是MyClass&lt;K&gt;的友元(T!=K)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">char_class</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_class</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">Fri</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">fri</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">char_class</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// fri.func(int_class);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>    
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>通用和特定的模板友好关系：一个类可以将另一个模板的每个实例都声明为为自己的友元，或者限定特定的实例为友元
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Common</span><span class="p">{</span> <span class="c1">// 普通类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal</span><span class="p">;</span> <span class="c1">// 【Pal的所有实例】都是类Common的友元，此时Fri可以不用提前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span> <span class="c1">// 模板类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">friend</span> <span class="k">class</span> <span class="nc">Fri</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 一对一友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">MyFri</span><span class="p">;</span> <span class="c1">// 【MyPal的所有实例】都是MyClass每个实例的友元，此时MyPal可以不用提前声明，且声明中使用了不同的模板参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">friend</span> <span class="k">class</span> <span class="nc">Commom_fri</span><span class="p">;</span> <span class="c1">// 普通类作为模板类的友元，此时不需要提前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>      
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>虽然友元通常是类或函数，但是允许将模板类型参数<code>T</code>作为友元，因此类型<code>T</code>的对象可以访问类模板的private成员。<a href="https://blog.csdn.net/craftsman1970/article/details/81748184">例子</a>。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">friend</span> <span class="n">T</span><span class="p">;</span> <span class="c1">// 类型T是MyClass的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">private_func</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;private func of MyClass &#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">func</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">		<span class="n">test</span><span class="p">.</span><span class="n">private_func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">;</span> <span class="c1">// 类型Test是MyClass的友元，Test类型的对象可以访问【类模板MyClass基于Test类型的实例】的private成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">Test</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">t</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>模板类型别名
<ul>
<li>为类模板的实例创建别名：<code>typedef MyClass&lt;int&gt; MC;</code></li>
<li>为类模板定义别名：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 固定一个类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>类模板的static成员
<ul>
<li>相同类型类模板的实例的static成员是共享的，不同类型之间类模板的实例的static成员是不同的</li>
</ul>
</li>
</ul>
<h3 id="模板参数">模板参数</h3>
<ul>
<li>模板内不能重用模板参数名，且同一个模板参数名<code>T</code>在同一个模板参数列表中只能出现一次</li>
<li>声明中的模板参数不必与定义中的模板参数相同，且模板声明通常一起放在文件开始位置（使用模板的代码之前）</li>
<li>使用<code>T::mem</code>，无法判断mem是类型T的static成员还是类型T的类型成员
<ul>
<li>普通类中编译器已知类的定义因此可以判断</li>
<li>默认<code>T::mem</code>访问的是static成员</li>
<li>使用<code>typename</code>显式说明访问的是类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">using</span> <span class="n">age</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">;</span> <span class="c1">// 类型成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="c1">// static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Person</span><span class="o">::</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;zhang&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">age</span> <span class="n">func</span><span class="p">(){</span> <span class="c1">// 显式说明T::age是一个类型而非static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">T</span><span class="o">::</span><span class="n">name</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 默认T::name是static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">age</span> <span class="n">myAge</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">myAge</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>默认模板实参：默认模板实参都在最右侧，对函数模板和类模板都可以提供默认模板实参</li>
</ul>
<h3 id="成员模板">成员模板</h3>
<ul>
<li>成员模板：普通类或模板类的成员函数是模板函数，成员模板不能是虚函数</li>
<li>普通类的成员模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span> <span class="c1">// 普通类中包含成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 普通类中的成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 对比模板类中的普通成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span> <span class="n">myClass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 普通类中的成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">Test</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">test</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 模板类中的普通函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>类模板的成员模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">K</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">H</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 类模板的模板参数列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">H</span><span class="o">&gt;</span> <span class="c1">// 类模板的成员模板的模板参数列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">(</span><span class="n">H</span> <span class="n">h</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">H</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myClass</span><span class="p">(</span><span class="sc">&#39;k&#39;</span><span class="p">);</span> <span class="c1">// 显式提供T=int, 隐式推断K=char
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span> <span class="c1">// 隐式推断H=double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;str&#34;</span><span class="p">);</span> <span class="c1">// 显式提供H=string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="显式实例化">显式实例化</h3>
<ul>
<li>背景：模板只有使用时才被实例化，因此相同的实例可能出现在多个文件中，造成额外开销</li>
<li>显式实例化
<ul>
<li>当编译器遇到<code>extern</code>模板声明时，不会在本文件中生成模板的实例化代码，表示使用其他位置的实例化代码</li>
<li><code>extern</code>声明必须出现在使用此实例化版本的代码之前，否则编译器进行实例化，起不到外部定义的效果</li>
<li>显式实例化定义会实例化所有成员</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 在a.cpp中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 实例化声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="kt">int</span> <span class="n">compare</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 在b.cpp中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 实例化定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="效率与灵活性">效率与灵活性</h3>
<ul>
<li>shared_ptr在运行时绑定删除器，因此删除器保存为一个指针而不是一个成员，因此删除器的类型直到运行时才直到，而且可以随时改变删除器的类型
<ul>
<li>需要间接调用删除器，但是用户重载删除器的操作更加便捷（只需要传入一个可调用对象）</li>
</ul>
</li>
<li>unique_ptr在编译期绑定删除器，删除器的类型是类类型的一部分（因此删除器类型在编译器是已知的），从而删除器可以直接保存在成员中
<ul>
<li>避免了间接调用删除器的运行时开销</li>
</ul>
</li>
</ul>
<h2 id="162-函数模板实参推断">16.2 函数模板实参推断</h2>
<ul>
<li>可以[[ch16-模板和泛型编程#类型转换与模板类型参数|基于实参推导模板参数类型]]，也可以[[ch16-模板和泛型编程#函数指针和实参推断|函数指针指向函数模板推导模板参数类型]]</li>
<li>有时比如返回值类型无法推导出来，可以指定[[ch16-模板和泛型编程#函数模板显式实参|模板显式实参]]，也可以使用[[ch16-模板和泛型编程#尾置返回类型与类型转换|尾置返回类型]]（同时可以[[ch16-模板和泛型编程#尾置返回类型后进行类型转换|去除引用]]）</li>
<li>当模板类型<code>T</code>为引用时，需要依据实参是左值/右值来判断T的引用类型，而且可以使用完美转发保持实参的类型不变</li>
</ul>
<h3 id="类型转换与模板类型参数">类型转换与模板类型参数</h3>
<ul>
<li>模板实参推断：根据实参类型推断出模板参数<code>T</code>的类型
<ul>
<li>一般<code>T</code>就是实参类型</li>
<li>编译器会对以下几种实参进行类型转换，得到的<code>T</code>并不完全是实参类型
<ul>
<li>顶层<code>const</code>会被忽略</li>
<li>可以将非const对象的指针或引用传递给一个const的指针或引用形参</li>
<li>如果形参不是引用类型，数组名/函数名转换为指针类型</li>
</ul>
</li>
</ul>
</li>
<li><code>template&lt;typename T&gt; void func(T a, T b);</code>中，a和b推断的类型必须相同</li>
</ul>
<h3 id="函数模板显式实参">函数模板显式实参</h3>
<ul>
<li>背景：类型<code>T</code>只出现在返回值/函数体，不在形参列表中时，编译器无法推断出模板实参的类型：</li>
<li>函数模板显式实参从左到右进行对应，如果模板参数可以推导出来，放在模板参数列表右侧，实例化时可以进行推导</li>
<li>当显式指定实参时，对实参可以使用正常的类型转换</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span> <span class="n">T1</span> <span class="n">sum</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">);</span> <span class="c1">// T1在返回值中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="kt">double</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// T1类型是long long, T2、T3类型可以推导出来，放在右侧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">test</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// T2类型显式指定为long long，因此将a转换为long long型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">compare</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// 使用显式模板实参，a、b都转换为long long类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="尾置返回类型与类型转换">尾置返回类型与类型转换</h3>
<h4 id="尾置返回类型">尾置返回类型</h4>
<ul>
<li>背景：有时函数模板的返回值类型不能由实参推导而来，比如[[ch16-模板和泛型编程#函数模板显式实参|函数模板显式实参]]的背景
<ul>
<li>可以使用函数模板显式实参进行指定，也可以<strong>使用尾置返回类型自动推导</strong></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="n">Iter</span> <span class="n">beg</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">){</span> <span class="c1">// 从局部变量中推导出返回类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="尾置返回类型后进行类型转换">尾置返回类型后进行类型转换</h4>
<ul>
<li>背景：通过模板显式实参可以指定返回值类型，但是通过尾置返回类型推导得到的类型可能不是想要的，比如有时不希望得到引用类型</li>
<li><strong>标准库的类型转换模板</strong>
<ul>
<li>定义在头文件<code>type_traits</code>中，常用于模板元程序设计</li>
<li>Mod是一个类模板，将类型<code>T</code>转换为类型<code>type</code>；如果无法转化，则类型<code>type</code></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="n">Iter</span> <span class="n">beg</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">{</span> <span class="c1">// 表明type是一个类型而非一个static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th><code>Mod</code></th>
<th><code>T</code></th>
<th><code>Mod&lt;T&gt;::type</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_const</code></td>
<td><code>X&amp;</code>或<code>const X</code>或函数</td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>const T</code></td>
</tr>
<tr>
<td><code>add_lvalue_reference</code></td>
<td><code>X&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td><code>X&amp;&amp;</code></td>
<td><code>X&amp;</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;</code></td>
</tr>
<tr>
<td><code>add_rvalue_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;&amp;</code></td>
</tr>
<tr>
<td><code>remove_pointer</code></td>
<td><code>X*</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_pointer</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X*</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T*</code></td>
</tr>
<tr>
<td><code>make_signed</code></td>
<td><code>unsigned X</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>make_unsigned</code></td>
<td>带符号类型</td>
<td><code>unsigned X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_extent</code></td>
<td><code>X[n]</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_all_extents</code></td>
<td><code>X[n1][n2]...</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<h3 id="函数指针和实参推断">函数指针和实参推断</h3>
<ul>
<li>将函数模板赋值给函数指针：
<ul>
<li>函数指针指向函数模板的一个实例</li>
<li>使用函数指针的类型来推断模板实参</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>  <span class="c1">// T是int，f指向函数模板的实例compare(const int&amp;, const int&amp;)
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果函数func的形参是函数指针，实参可以传入函数模板，这样函数指针指向一个模板实例且进行了参数推断
<ul>
<li>但是当func有多个重载的版本时（接受不同类型的函数指针），传入函数模板可能产生歧义，此时可以指定【显式模板实参】</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">));</span> <span class="c1">// 重载
</span></span></span><span class="line"><span class="cl"><span class="c1">// func(compare); // 歧义：函数模板compare实例化为哪一种函数指针？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">func</span><span class="p">(</span><span class="n">compare</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="模板实参推断和引用">模板实参推断和引用</h3>
<h4 id="模板参数t的类型推断">模板参数<code>T&amp;</code>的类型推断</h4>
<table>
<thead>
<tr>
<th style="text-align:center">模板类型参数</th>
<th style="text-align:center">实参要求</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>T&amp;</code></td>
<td style="text-align:center">必须传递一个左值</td>
<td style="text-align:center">实参为<code>int</code>，<code>T</code>为<code>int</code>;实参为<code>const int</code>，<code>T</code>为<code>const int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>const T&amp;</code></td>
<td style="text-align:center">可以传递左值或右值</td>
<td style="text-align:center">实参为<code>int, const int, const int&amp;&amp;</code>，<code>T</code>都为<code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>T&amp;&amp;</code></td>
<td style="text-align:center">必须传递一个右值</td>
<td style="text-align:center">实参为<code>int&amp;&amp;</code>， <code>T</code>为<code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>T&amp;&amp;</code></td>
<td style="text-align:center">例外：传递一个类型为<code>type</code>的左值，推导<code>T</code>为<code>type&amp;</code>类型</td>
<td style="text-align:center">实参为<code>int&amp;</code>,<code>T</code>为<code>int&amp;</code></td>
</tr>
</tbody>
</table>
<h4 id="引用折叠">引用折叠</h4>
<ul>
<li>背景：基于上面这个例外，创造出了引用的引用，或者通过类型别名也可以创造出引用的引用，可以将多个引用折叠为一个引用</li>
<li>引用折叠规则：
<ul>
<li><code>type&amp; &amp;、 type&amp; &amp;&amp;、 type&amp;&amp; &amp;</code>折叠为<code>type &amp;</code></li>
<li><code>type&amp;&amp; &amp;&amp;</code>折叠为<code>T&amp;&amp;</code></li>
</ul>
</li>
<li>使用：
<ul>
<li>若函数形参是<code>T&amp;&amp;</code>，则可以传递一个左值（实参的const属性可以保持，因为是底层const）</li>
<li>如果传入的是左值<code>type&amp;</code>，推导出<code>T=type&amp;</code></li>
<li>万能引用（或称为模板类型参数右值引用）：函数形参为<code>T&amp;&amp;</code>时，传递左值/右值均可
<ul>
<li>使用万能引用导致只有在运行时才能确定形参是左值还是右值，使得模板的编写变得困难</li>
<li>通常在两种情况中使用万能引用：模板转发实参，模板重载</li>
<li>使用万能引用的形参通常重载为两个版本：
<ul>
<li>拷贝版本：<code>template&lt;typename T&gt; void f(const T&amp;)</code>  绑定到左值和const右值</li>
<li>移动版本：<code>template&lt;typename T&gt; void f(T&amp;&amp;)</code> 绑定到非const右值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="stdmove"><code>std::move</code></h4>
<ul>
<li>[[ch13-拷贝控制#^d3a2a0|std::move函数]]的定义：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>可以使用<code>static_cast</code>显式地将左值转换为右值引用</li>
</ul>
<h3 id="转发">转发</h3>
<ul>
<li>背景：比如函数f内部调用函数g时，可能需要将f的实参传递给g，而且同时要求保持实参性质不变（比如const属性，左值/右值属性）
<ul>
<li>即希望达到这样的效果：将实参传递给f，再传递给g，与实参直接传递给g，的效果等价</li>
<li>例子一：f形参类型是非引用，g形参类型是左值引用，传入一个左值引用，则此时f转发参数给g时会使用自己的拷贝而非原来的引用</li>
<li>例子二：f形参类型是万能引用<code>T&amp;&amp;</code>，g形参类型是右值引用，f可以接受右值（或左值），此时f转发参数给g时，使用的右值引用本身是一个左值，不能传参给g的右值引用</li>
</ul>
</li>
<li>比较：都是定义在<code>utility</code>中的函数模板，最好显式指明是<code>std::</code>中的
<ul>
<li><code>std::forward</code>：可指定模板参数，并且可以对返回值使用引用折叠来保留左右值属性</li>
<li><code>std::move</code>：返回值一定是右值引用</li>
</ul>
</li>
<li>使用：完美转发
<ul>
<li>通过万能引用在传入外层f时保留实参的全部属性</li>
<li>通过<code>std::forward</code>在传入内层函数g时再次保留实参的全部属性</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">arg</span><span class="p">){</span> <span class="c1">// 万能引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span> <span class="c1">// std::forward&lt;T&gt;的返回类型是T&amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果实参是左值，推导出<code>T=type&amp;</code>，<code>std::forward&lt;T&gt;</code>的返回类型<code>T&amp;&amp;</code>折叠为<code>type&amp;</code></li>
<li>如果实参是右值，推导出<code>T=type</code>，<code>std::forward&lt;T&gt;</code>的返回类型即为<code>type&amp;&amp;</code></li>
</ul>
</li>
<li>例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">flip</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">K</span> <span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34;  &#34;</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">flip</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// F=void(*)(int&amp;&amp;, int&amp;), T=int&amp;, K=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">flip</span><span class="p">(</span><span class="n">g</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// F=void(*)(int&amp;&amp;, int&amp;), T=int&amp;, K=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="163-重载与模板">16.3 重载与模板</h2>
<ul>
<li>函数模板可以被另一个函数模板或普通函数重载
<ul>
<li>[[ch06-函数#6.6 函数匹配|函数的重载与匹配]]：有一些重载的函数，根据实参情况，调用时用哪个函数？</li>
<li>函数模板的重载与匹配：有一些重载的函数模板和普通函数，根据实参情况（函数模板进行函数模板实参推断），实例化并调用哪个函数模板</li>
</ul>
</li>
<li>到函数模板的函数匹配规则（[[ch06-函数#6.6 函数匹配|普通函数匹配的拓展]]）
<ul>
<li>确定候选函数：同名的函数，包括实参推断成功的函数模板实例</li>
<li>确定可行函数：参数类型和数量都匹配，
<ul>
<li>候选的函数模板实例都是可行的，因为实参推断会排除掉不可行的模板</li>
</ul>
</li>
<li>按照类型转换进行排序，寻找最佳匹配（普通函数和函数模板实例都可能发生类型转换，只是应用于函数模板的[[ch16-模板和泛型编程#类型转换与模板类型参数|类型转换]]十分有限）
<ul>
<li>若恰有一个函数提供比其他函数都好的匹配，则选择它</li>
<li>如果多个函数都提供相同级别的匹配
<ul>
<li>非模板和模板重载：如果只有一个是非模板函数，选择非模板函数</li>
<li>多个可行模板：如果没有非模板函数（有多个函数模板），选择最特例化的函数模板（特例化：比如<code>T&amp;</code>可以匹配任意类型，<code>T*</code>只能匹配指针类型）</li>
<li>调用有歧义，失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最佳实践：在定义重载函数之前，应该先声明所有重载的版本，否则可能重载一个模板函数进行实例化（因为没有找到想使用的版本，使用函数模板进行实例化），编译期不会报错，但是运行期会调用不期望使用的版本</li>
</ul>
<h2 id="164-可变参数模板">16.4 可变参数模板</h2>
<ul>
<li><strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类，可变数目的参数被称为<strong>参数包</strong>
<ul>
<li>模板参数包：表示零个或多个模板参数（模板类型参数或模板非类型参数）
<ul>
<li><code>typename</code>后跟<code>...</code>表示模板类型参数包</li>
<li>类型名后跟<code>...</code>表示模板非类型参数包</li>
</ul>
</li>
<li>函数参数包：表示零个或多个函数参数。</li>
</ul>
</li>
<li><code>sizeof...</code>运算符：返回参数包中的元素数量，且不会对其实参求值（类似于sizeof）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span> <span class="c1">// 模板参数包：Args是模板类型参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="p">...</span> <span class="n">rest</span><span class="p">){</span>  <span class="c1">// 函数参数包：rest是函数参数包（其类型是模板参数包Args）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">rest</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="编写可变参数函数模板">编写可变参数函数模板</h3>
<ul>
<li>[[ch06-函数#可变形参|可变形参]]<code>initializer_list</code>可以接受可变数目实参，但是需要是相同类型的</li>
<li>可变参数函数通常是递归的
<ul>
<li>第一步调用处理参数包中的第一个实参，然后用剩余实参调用自身</li>
<li>还需要定义一个非可变参数的函数（因为函数匹配时会使用这个更加特例化的版本，而不是使用0个参数的可变参数模板的实例），来处理参数包中最后一个实参</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="c1">// 打印最后一个元素，用来终止递归，必须在可变参数版本的print定义之前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rest</span><span class="p">...);</span>   <span class="c1">// 递归调用，实参是将除了第一个，剩余的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="包扩展">包扩展</h3>
<ul>
<li>扩展<code>...</code>：将参数包分解为单个元素，每个元素应用模式，得到拓展后的列表</li>
<li>常用情况：
<ul>
<li><code>const Args&amp; ...</code>：将模板参数包<code>Args</code>中所有类型<code>T</code>都扩展为<code>const T&amp;</code></li>
<li><code>args...</code>：将函数参数包<code>args</code>扩展为参数列表</li>
<li><code>f(args)...</code>：对函数参数包<code>args</code>中每个元素调用函数<code>f</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">){</span> <span class="c1">// 扩展模板参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">debug_reg</span><span class="p">(</span><span class="n">rest</span><span class="p">)...);</span> <span class="c1">// 扩展函数参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="转发参数包">转发参数包</h3>
<ul>
<li>组合使用可变参数模板和<code>forward</code>机制，实现将可变参数的完美转发，例子：<code>emplace_back</code></li>
<li>如果同时存在模板参数包和函数参数包，则同时拓展：
<ul>
<li><code>f&lt;Args&gt;(args)...</code>等价于<code>f&lt;Args1&gt;(args1), f&lt;Args2&gt;(args2), ... </code></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">work</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="165-模板特例化specializations">16.5 模板特例化（Specializations）</h2>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=03b4a1a4-b85a-ef1b-901a-178f5542609b&amp;page=650&amp;rect=86.880,83.040,255.996,90.480">背景和例子</a>：对于某个类型，不想用（对特定类型可以做优化）或者不能用（对特定类型的使用并非预期）模板</li>
</ul>
<h3 id="定义函数模板特例化">定义函数模板特例化</h3>
<ul>
<li>必须为原模板中每个模板参数都提供实参（全特例化）</li>
<li>关键字<code>template</code>后面跟一个空尖括号对（<code>&lt;&gt;</code>），表示所有模板参数都已被指定</li>
<li>特例化版本的参数类型必须与一个先前声明的模板中对应的类型相匹配。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">// T为const char*
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="函数重载与模板特例化">函数重载与模板特例化</h3>
<ul>
<li>特例化的本质是实例化一个模板，而不是重载它。因此特例化不影响[[ch16-模板和泛型编程#16.3 重载与模板|函数的匹配规则]]，即非模板函数先，再是特例化版本的函数（模板的实例化），最后是函数模板的实例</li>
<li>最佳实践：模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是特例化版本。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span> <span class="c1">// 特例化版本，T为const char*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span> <span class="c1">// 普通函数
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="类模板特例化">类模板特例化</h3>
<ul>
<li>必须在原模板定义所在的命名空间中进行类模板特例化</li>
<li>类模板可以进行部分特例化（偏特例化），得到的是模板；也可以全部特例化（全特例化），得到的是实例</li>
<li>类模板的部分特例化
<ul>
<li>未完全确定类型的模板参数仍放在<code>&lt;&gt;</code>中，即偏特化的模板参数列表非空。使用时也需提供模板实参，这些实参与原始模板中的参数按位置对应</li>
<li>部分特例化的模板参数列表是原始模板参数列表的一个子集或者特例化版本</li>
<li>例子：标准库remove_reference类型是通过一系列的特例化版本来完成其功能的
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//原始的、最通用的版本，可用于任意类型实例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span> <span class="p">{</span>  <span class="c1">//针对于左值引用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span> <span class="p">{</span> <span class="c1">//针对于右值引用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//调用原始模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">a</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//decltype(i)==int&amp;，调用第一个（T&amp;）部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">b</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//decltype(std::move(i))==int&amp;&amp;，调用第二个（T&amp;&amp;）部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">c</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//a、b、c均为int
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>特例化成员函数而不是整个类
<ul>
<li>使用模板的实例调用成员时，若该实例的模板实参与特化该成员时的参数一致，则调用特化版本的成员</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="p">())</span> <span class="o">:</span><span class="n">mem</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span> <span class="c1">//通用的Bar()函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">T</span> <span class="n">mem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//特例化Foo&lt;int&gt;版本的的成员Bar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Bar</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">Foo</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">fs</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="n">fs</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>       <span class="c1">//使用Foo&lt;string&gt;的通用的Bar()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fi</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">	<span class="n">fi</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>       <span class="c1">//使用Foo&lt;int&gt;的特例化的Bar()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch15 面向对象程序设计</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:30 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</guid>
      <description>第十五章 面向对象程序设计 OOP的核心思想是多态性（polymorphism）。 多态即具有继承关系的多个类型 引用或指针的静态类型与动态类型不同</description>
      <content:encoded><![CDATA[<h1 id="第十五章-面向对象程序设计">第十五章 面向对象程序设计</h1>
<p>OOP的核心思想是多态性（polymorphism）。</p>
<ul>
<li>多态即具有继承关系的多个类型</li>
<li>引用或指针的静态类型与动态类型不同是C++支持多态的根本</li>
</ul>
<p>本章内容：</p>
<ul>
<li>基类与派生类语法及其类型转换</li>
<li>虚函数、纯虚函数、抽象基类</li>
<li>访问控制：成员访问控制、派生访问控制、using声明</li>
<li>继承过程中的函数解析和作用域</li>
<li>继承过程中的构造函数和（合成）拷贝控制成员</li>
</ul>
<h2 id="151-oop概述">15.1 OOP：概述</h2>
<ul>
<li>基类，派生类、类派生列表</li>
<li>[[ch15-面向对象程序设计#15.3 虚函数|虚函数]]：基类将函数声明为虚函数，派生类定义适合自己的版本</li>
<li><strong>动态绑定</strong>（dynamic binding，又称运行时绑定）：
<ul>
<li>使用基类的引用或指针调用一个虚函数时将发生动态绑定（即在运行时，根据传入参数的类型选择函数版本）</li>
</ul>
</li>
</ul>
<h2 id="152-定义基类和派生类">15.2 定义基类和派生类</h2>
<h3 id="定义基类">定义基类</h3>
<ul>
<li>如果函数希望被派生类覆盖，则基类将其定义为虚函数；否则基类中的函数希望派生类直接继承而且不要改变</li>
<li>基类中的虚函数 ^ae3c55
<ul>
<li>基类通常都应该定义一个【虚析构函数】，即使该函数不执行任何实际操作。</li>
<li>除构造函数之外的任何非静态函数都可以定义为虚函数</li>
<li>如果基类把一个函数声明为虚函数，则该函数在派生类中隐式的也是虚函数</li>
</ul>
</li>
<li>[[ch15-面向对象程序设计#^8deb68|访问控制]]</li>
</ul>
<h3 id="定义派生类">定义派生类</h3>
<ul>
<li>【类派生列表中的访问说明符】用于控制【派生类从基类继承而来的成员】是否【对派生类的对象】可见
<ul>
<li>派生类必须将继承而来的成员函数中需要覆盖的那些重新声明</li>
<li>如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分，因此可以将派生类类型的对象绑定到基类的指针或引用上</li>
</ul>
</li>
<li>派生类中的虚函数 ^91e48b
<ul>
<li>如果派生类没有覆盖基类中的某个虚函数，则派生类会直接继承其在基类中的版本</li>
<li>派生类必须在其内部对所有重新定义的虚函数进行声明，virtual关键字可加可不加</li>
<li>派生类中覆盖虚函数时，形参类型和返回值类型必须相同
<ul>
<li>返回值不相同只有一个例外：虚函数返回类型是类本身的指针或引用，比如类Base派生出类Derived，则基类Base的虚函数返回值可以返回<code>*Base</code>，而派生类Derived中覆盖的虚函数可以返回<code>*Derived</code></li>
</ul>
</li>
<li>C++11使用<code>override</code>显式指明重新定义虚函数（<code>override</code>放在引用限定符之后）</li>
</ul>
</li>
<li>派生类到基类的类型转换
<ul>
<li>基类与派生类之间的[[#类型转换与继承]]</li>
<li>[[ch15-面向对象程序设计#^ec492b|派生类向基类转换的可访问性]]</li>
</ul>
</li>
<li>派生类构造函数：每个类控制自己的成员初始化过程
<ul>
<li>派生类必须使用【基类的构造函数】来初始化它的基类部分，【派生类的构造函数】通过【[[ch07-类#^742596|构造函数初始值列表]]】来将实参传递给【基类构造函数】，同时在【构造函数初始值列表】初始化自己的数据成员</li>
<li>遵循基类的接口，尽管从语法上可以在派生类中给基类的公有成员直接进行赋值</li>
<li>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化</li>
<li>顺序：先初始化基类部分，在按声明顺序依次初始化派生类的成员</li>
</ul>
</li>
<li>静态成员
<ul>
<li>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一实例。</li>
<li>静态成员遵循通用的访问控制规则</li>
</ul>
</li>
<li>派生类的声明中不包含它的派生列表，派生列表必须于派生类的定义一起出现</li>
<li>如果想用某个类作为基类，该类必须已经定义而非仅仅声明
<ul>
<li>一个类不能派生它本身</li>
<li>直接基类与间接基类：派生类构造函数只初始化它的直接基类</li>
</ul>
</li>
<li>防止继承：在类名后面跟一个关键字<code>final</code>。
<ul>
<li>final关键字除了防止继承，还可以防止函数被覆盖</li>
</ul>
</li>
</ul>
<h3 id="类型转换与继承">类型转换与继承</h3>
<ul>
<li>可以将【指向基类的指针/引用】绑定到派生类对象上，因此【指向基类的指针/引用】的静态类型与动态类型可能不一致
<ul>
<li>静态类型：变量或表达式类型在编译时已知</li>
<li>动态类型：变量或表达式类型在运行时才可知，是指针指向的内存中对象的类型</li>
</ul>
</li>
<li>编译器自动将【指向派生类的指针/引用】转换为【指向基类的指针/引用】</li>
<li>不存在【指向基类的指针/引用】隐式转换到【指向派生类的指针/引用】
<ul>
<li>除了使用强制类型转换：使用<code>dynamic_cast</code>，将【指向基类的指针/引用】安全的转换成【指向派生类的指针/引用】，将在运行期进行安全检查</li>
<li>如果已知某个基类到派生类的转换是安全的，可以使用<code>static_cast</code>强制覆盖掉编译器的检查工作</li>
</ul>
</li>
<li>派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。
<ul>
<li>如果表达式不是引用/指针，则它的静态类型与动态类型永远一致</li>
<li>有时确实希望将派生类对象转换成基类类型，派生类的部分被切掉(sliced down)了</li>
</ul>
</li>
</ul>
<h2 id="153-虚函数">15.3 虚函数</h2>
<ul>
<li>[[ch15-面向对象程序设计#^ae3c55|基类中的虚函数]]</li>
<li>[[ch15-面向对象程序设计#^91e48b|派生类中的虚函数]]</li>
<li>virtual关键字只能出现在类内部的声明语句，而不能用于类外部的函数定义</li>
<li>必须为每一个虚函数提供定义，不管是否被用到（因为编译器也无法确定哪个虚函数会被使用）</li>
<li>默认实参
<ul>
<li>如果虚函数中有默认实参，则默认实参的值由本次调用的指针/引用的静态类型决定</li>
<li>因此可能使用的是基类中的默认实参，但是实际运行的是派生类的虚函数版本</li>
<li>最好基类和派生类中的默认实参一致</li>
</ul>
</li>
<li>回避虚函数：对虚函数的调用不要进行动态绑定，而强迫执行虚函数的某个版本
<ul>
<li>使用<strong>作用域运算符</strong>（<code>::</code>）来回避虚函数</li>
<li>通常，只有成员函数（或友元）中才需要使用使用回避虚函数的机制，比如一个派生类的虚函数调用它覆盖的基类的虚函数版本（如果不使用回避机制，在运行时该调用将被解析为派生类版本自身的调用，导致无限循环递归）</li>
<li>例子：<code>Derived* p = Derived(); p-&gt;Base::func();</code></li>
</ul>
</li>
</ul>
<h2 id="154-抽象基类">15.4 抽象基类</h2>
<ul>
<li>纯虚函数：一个没有意义的虚函数
<ul>
<li>纯虚函数无需定义，或者也可以提供定义，但是函数体必须定义在类的外部</li>
<li>声明时末尾加上<code>=0</code>将函数声明为纯虚函数，且只能出现在类内部的函数声明中</li>
</ul>
</li>
<li>抽象基类
<ul>
<li>含有（或未经覆盖直接继承）纯虚函数的类
<ul>
<li>如果派生类不覆盖抽象基类中的纯虚函数，则该派生类仍然是抽象基类</li>
</ul>
</li>
<li>抽象基类负责定义接口，后续的其他类可以覆盖该接口</li>
<li>不能创建抽象基类的对象。</li>
</ul>
</li>
</ul>
<h2 id="155-访问控制与继承">15.5 访问控制与继承</h2>
<ul>
<li>派生类中继承而来的成员的访问权限受到两个因素影响：基类中成员的访问控制（<strong>成员访问说明符</strong>）、类派生列表中的访问控制（<strong>派生访问说明符</strong>）
<ul>
<li>基类中成员的访问控制 ^8deb68
<ul>
<li><code>public</code>：基类本身、派生类、友元、类对象都可以访问</li>
<li><code>protected</code> ： 基类本身、派生类、友元可以访问，类对象无法访问
<ul>
<li>派生类和友元可以通过派生类对象访问基类的protected成员，但是不能直接通过基类对象来访问。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=af2c58f1-ba76-b811-d0dc-29291dabce5c&amp;page=569&amp;rect=166.478,559.210,246.731,566.890">例子</a>。</li>
</ul>
</li>
<li><code>private</code> ： 基类本身、友元可以访问，其他都无法访问</li>
</ul>
</li>
<li>类派生列表中的访问控制：基类中public/protected的成员，在派生类中的访问说明符
<ul>
<li>如果继承是public的，则成员遵循原来的访问说明符</li>
<li>如果继承是private的，则派生类中【从基类中继承而来的成员】是private的</li>
<li>如果继承是protected的，则派生类中【从基类中继承而来的成员】是protected的</li>
</ul>
</li>
</ul>
</li>
<li>派生类向基类转换的可访问性 ^ec492b
<ul>
<li>总体原则：对于继承树中的某个节点，如果基类的共有成员是可以访问的，则派生类可以向基类进行类型转换；反之则不行。<a href="https://blog.csdn.net/monster_acm/article/details/81200777">示例说明</a>。</li>
<li>只有当继承是public的时，派生类才能转换到基类（基类指针指向派生类对象）</li>
<li>不管D以什么方式继承B，【D的成员函数和友元函数】中【派生类D可以转换到直接基类B】</li>
<li>如果D继承B的方式是public的或protected的，则【D派生类的成员和友元】可以使用【D向B的类型转换】；反之如果是私有的，则不能使用</li>
</ul>
</li>
<li>友元关系是单向的，不具有传递性，且不能继承
<ul>
<li>如果Pal是基类Base的友元，则Pal可以访问Base的对象的成员和派生类Derived中属于Base部分的成员</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">protected_val</span><span class="p">;</span> <span class="c1">// 每个类负责控制自己成员的访问权限，protected_val访问权限由Base控制（即使Base是内嵌在派生类对象中）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">friend</span> <span class="k">class</span> <span class="nc">PPal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">de_protected_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Pal</span><span class="p">{</span> <span class="c1">// 基类的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">f</span><span class="p">(</span><span class="n">Derived</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">protected_val</span><span class="p">;}</span> <span class="c1">// protected_val的访问控制权限由Baes控制，这种可访问性包括了Base对象内嵌在其派生类对象中的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="n">Derived</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">de_protected_val</span><span class="p">;}</span> <span class="c1">// error: 基类的友元不能随便访问派生类的成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DPal</span><span class="o">:</span> <span class="k">public</span> <span class="n">Pal</span><span class="p">{</span> <span class="c1">// 【基类友元】的派生类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">k</span><span class="p">(</span><span class="n">Derived</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">protected_val</span><span class="p">;}</span> <span class="c1">// error：友元关系不能继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PPal</span><span class="p">{</span> <span class="c1">// 派生类的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">h</span><span class="p">(</span><span class="n">Derived</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">protected_val</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>改变派生类个别成员的可访问性：使用<code>using</code>。 ^f2ba1c
<ul>
<li>将基类的public/protected成员使用using进行标记，放在派生类public/protected/private的位置，就获得了相应的访问级别</li>
<li>派生类只能针对基类的public/protected成员使用using声明改变可访问性（因为派生类无法访问基类的private成员）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">pub_func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="nf">pub_func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">pro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">pri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">private</span> <span class="n">Base</span><span class="p">{</span> <span class="c1">// Derived中从基类Base中继承而来的成员默认都是private的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">pub_func</span><span class="p">;</span> <span class="c1">// 使用using声明，两个重载的pub_func现在都被添加，都是public的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">pro</span><span class="p">;</span> <span class="c1">// 使用using声明，pro现在是protected的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 派生类无法访问到基类的private成员	
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>class</code>与<code>struct</code>
<ul>
<li>默认使用<code>clas</code>定义的类成员是private的，使用<code>struct</code>定义的类成员是public的</li>
<li>默认使用<code>class</code>定义的派生类是私有继承的，使用<code>struct</code>定义的派生类是公有继承的。</li>
<li>除此之外再无不同</li>
</ul>
</li>
</ul>
<h2 id="156-继承中的类作用域">15.6 继承中的类作用域</h2>
<ul>
<li>派生类的作用域嵌套在其基类的作用域之内</li>
<li>函数调用的解析过程：<code>p-&gt;mem()</code>或者<code>obj.mem()</code>
<ol>
<li>确定p或obj的静态类型</li>
<li>名字查找：在该静态类型对应的类中查找mem，如果找不到，则依次在直接继承中不断查找，直到继承链的顶端</li>
<li>类型检查：假如找到mem，进行常规的类型检查，以确认本次调用是否合法</li>
<li>假如合法，编译器根据调用的是否为虚函数产生不同的代码：
<ul>
<li>mem是虚函数且通过指针或引用来调用：编译器产生的代码将在运行时确定到底是运行该虚函数的哪个版本，依据是对象的动态类型</li>
<li>mem不是虚函数或者通过对象进行调用：产生一个常规的函数调用</li>
</ul>
</li>
</ol>
</li>
<li>函数调用的解析过程导致的现象：
<ul>
<li>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的
<ul>
<li>比如将基类指针绑定到派生类，基类指针静态类型是指向基类（因此无法调用派生类特有的成员），但是动态类型是指向派生类</li>
</ul>
</li>
<li>派生类的成员将隐藏同名的基类成员，即使成员函数形参列表不同
<ul>
<li>可以使用域运算符<code>::</code>使用被隐藏的基类成员</li>
<li>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</li>
<li>派生类中继承来的虚函数要保持相同的参数列表，否则派生类定义的是一个新函数，该新函数不是虚函数</li>
</ul>
</li>
<li>虚函数解析过程：
<ul>
<li>在编译期，基类指针在静态类型中进行名字查找和类型检查</li>
<li>在运行期，根据动态类型决定运行虚函数的哪个版本</li>
</ul>
</li>
</ul>
</li>
<li>覆盖重载的函数：
<ul>
<li>派生类可以覆盖重载函数的0个或多个版本</li>
<li>如果派生类希望所有的重载版本对它来说都是可见的，那么就需要覆盖所有的版本，或者一个也不覆盖（因此到基类中寻找名字）</li>
<li>如果像重写一部分而非全部，可以使用using声明将同名的重载版本都添加到派生类作用域中，然后再重写</li>
<li>根本原因还是相应静态类型中查找到名字后但是类型不匹配，如果只覆盖一部分相当于重载版本变少了</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Base 1&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Base 2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Base 3&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">D1</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;D1 &#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 只覆盖一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">D2</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 一个都不覆盖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">D3</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;D3 2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">D1</span> <span class="n">d1</span><span class="p">;</span> <span class="n">D2</span> <span class="n">d2</span><span class="p">;</span> <span class="n">D3</span> <span class="n">d3</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="c1">//  d1.f(1); // 报错：因为d1静态类型为D1，D1中有函数f，但是类型检查失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">d2</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Base 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">d3</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// D3 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//  D1* p = &amp;d1; // 这样定义就错，原因同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Base</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">;</span> <span class="c1">// p的静态类型为Base，Base中有函数f(int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">p</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Base 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>重载、重写（覆盖）与隐藏，<a href="https://www.cnblogs.com/sunbines/p/9130227.html">参考</a>
<ul>
<li>重载：同一作用域内的几个函数同名但是形参列表不同</li>
<li>隐藏：派生类中的函数屏蔽了与其同名的基类函数，不管参数列表是否相同</li>
<li>重写（覆盖）：虚函数重写</li>
</ul>
</li>
</ul>
<h2 id="157-构造函数与拷贝控制">15.7 构造函数与拷贝控制</h2>
<h3 id="虚析构函数">虚析构函数</h3>
<ul>
<li>基类通常应该定义一个虚析构函数，这样最终执行动态类型版本的析构函数</li>
<li>一般来说，如果一个类需要析构函数，那么它也需要拷贝和赋值操作，但是基类的析构函数不遵循该规则</li>
<li>虚析构函数将阻止使用合成的移动操作，即使使用<code>=default</code>显式声明</li>
</ul>
<h3 id="合成的拷贝控制与继承">合成的拷贝控制与继承</h3>
<ul>
<li>派生类的合成拷贝控制成员，通过调用基类的合成拷贝控制成员，来对基类部分进行相应的拷贝、移动、销毁等操作</li>
<li>某些定义基类的方式可能导致部分派生类成员成为被删除的函数：
<ul>
<li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或者不可访问的函数，则派生类中对应的成员也会是被删除的。</li>
<li>如果基类的析构函数是被删除的或者不可访问的，则派生类中合成的默认和拷贝构造函数也会是被删除的。</li>
<li>如果基类的移动操作是删除的，则派生类中对应的函数也是删除的。</li>
<li>在实际编程中，如果基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。</li>
</ul>
</li>
<li>移动操作与继承
<ul>
<li>大多数基类都会定义一个虚析构函数，因此基类通常没有合成的移动操作</li>
<li>如果需要移动操作，首先在基类中定义，之后派生类会自动合成移动操作</li>
</ul>
</li>
</ul>
<h3 id="派生类的拷贝控制成员">派生类的拷贝控制成员</h3>
<ul>
<li>当派生类定义了拷贝或移动操作时，该操作通过调用基类的对应成员，来拷贝或移动包括基类在内的整个对象。</li>
<li>与拷贝和移动操作不同，派生类的析构函数只负责销毁由派生类自己分配的资源，对象销毁的顺序与创建顺序相反</li>
<li>在构造函数和析构函数中尽量不要调用虚函数：<a href="https://zhuanlan.zhihu.com/p/424508028#:~:text=%E9%A6%96%E5%85%88%E7%BB%99%E5%87%BA%E7%AD%94%E6%A1%88%EF%BC%9A%20%E5%9C%A8C%2B%2B,primer%E4%B8%AD%E8%AF%B4%E5%88%B0%E8%BF%87%E6%98%AF%E6%9C%80%E5%A5%BD%20%E4%B8%8D%E8%A6%81%E8%B0%83%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%AF%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%EF%BC%8C%20%E6%89%80%E4%BB%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B7%9F%E8%99%9A%E6%9E%84%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%E9%83%BD%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E4%BC%9A%E6%8A%A5%E9%94%99%E3%80%82">例子</a>。
<ul>
<li>比如在进行基类的初始化时，调用了派生类版本的虚函数，但是此时派生类还未进行初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// 构造函数中调用虚函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">Base</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>	
</span></span><span class="line"><span class="cl">	<span class="n">Base</span><span class="p">(</span><span class="n">Base</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">Base</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Base</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">Base</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="n">Base</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Base&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Derived</span><span class="p">()</span><span class="o">:</span> <span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">	<span class="n">Derived</span><span class="p">(</span><span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// 使用基类的构造函数初始化对象的基类部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">Derived</span><span class="p">(</span><span class="n">Derived</span><span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="n">Derived</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	  <span class="n">Base</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">// 使用基类的拷贝赋值运算符赋值对象的基类部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	  <span class="cm">/* do something*/</span>
</span></span><span class="line"><span class="cl">	  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">~</span><span class="n">Derived</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/*销毁派生类自己分配的资源*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Derived&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Derived</span> <span class="n">d</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 先构造基类部分，此时派生类部分还未创建，基类构造函数中使用的是Base::func()
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="继承的构造函数">继承的构造函数</h3>
<ul>
<li>背景
<ul>
<li>如果基类有多个不同的构造函数，那么派生类也需要相应实现多个构造函数，<a href="https://blog.csdn.net/K346K346/article/details/81703914">参考</a></li>
<li>派生类不能继承默认、拷贝、移动构造函数，派生类如果没有直接定义这些构造函数，编译器会为派生类合成</li>
</ul>
</li>
<li>派生类可以使用using声明重用基类的构造函数，编译器在派生类中生成一个形参列表完全相同的构造函数，派生类自己的数据成员被默认初始化
<ul>
<li>和普通的using声明不一样（可以[[ch15-面向对象程序设计#^f2ba1c|改变派生类个别成员的可访问性]]），构造函数的using声明不会改变构造函数的访问声明符</li>
<li>如果基类构造函数是<code>explict</code>的或<code>constexpr</code>的，则重用的构造函数也拥有相同的属性</li>
<li>如果一个基类构造函数含有默认实参，这些实参并不会被直接继承，派生类会获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。</li>
<li>基类有几个构造函数，派生类会重用所有的这些构造函数，除了两个例外：
<ul>
<li>派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本：如果派生类定义的构造函数与重用基类的构造函数具有相同的参数列表，则派生类中的构造函数将替换重用的基类构造函数</li>
<li>默认、拷贝和移动构造函数不会被继承，这些构造函数按照正常规则被合成</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="158-容器与继承">15.8 容器与继承</h2>
<ul>
<li>当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式，即在容器中放置（智能）指针而非对象，否则派生类对象的部分会被切掉</li>
</ul>
<h2 id="159-文本查询程序再探">15.9 文本查询程序再探</h2>
<ul>
<li>使系统支持：单词查询、逻辑非查询、逻辑或查询、逻辑与查询。</li>
</ul>
<h3 id="面向对象的解决方案">面向对象的解决方案</h3>
<ul>
<li>将几种不同的查询建模成相互独立的类，这些类共享一个公共基类：
<ul>
<li><code>WordQuery</code></li>
<li><code>NotQuery</code></li>
<li><code>OrQuery</code></li>
<li><code>AndQuery</code></li>
</ul>
</li>
<li>这些类包含两个操作：
<ul>
<li><code>eval</code>：接受一个<code>TextQuery</code>对象并返回一个<code>QueryResult</code>。</li>
<li><code>rep</code>：返回基础查询的<code>string</code>表示形式。</li>
</ul>
</li>
<li>继承和组合：
<ul>
<li>当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（Is A）”的关系。</li>
<li>类型之间另一种常见的关系是“有一个（Has A）”的关系。</li>
</ul>
</li>
<li>对于面向对象编程的新手来说，想要理解一个程序，最困难的部分往往是理解程序的设计思路。一旦掌握了设计思路，接下来的实现也就水到渠成了。
<strong>Query程序设计</strong>:</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Query</code>程序接口类和操作</td>
<td></td>
</tr>
<tr>
<td><code>TextQuery</code></td>
<td>该类读入给定的文件并构建一个查找图。包含一个<code>query</code>操作，它接受一个<code>string</code>实参，返回一个<code>QueryResult</code>对象；该<code>QueryResult</code>对象表示<code>string</code>出现的行。</td>
</tr>
<tr>
<td><code>QueryResult</code></td>
<td>该类保存一个<code>query</code>操作的结果。</td>
</tr>
<tr>
<td><code>Query</code></td>
<td>是一个接口类，指向<code>Query_base</code>派生类的对象。</td>
</tr>
<tr>
<td><code>Query q(s)</code></td>
<td>将<code>Query</code>对象<code>q</code>绑定到一个存放着<code>string s</code>的新<code>WordQuery</code>对象上。</td>
</tr>
<tr>
<td><code>q1 &amp; q2</code></td>
<td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q1</code>和<code>q2</code>的新<code>AndQuery</code>对象上。</td>
</tr>
<tr>
<td>`q1</td>
<td>q2`</td>
</tr>
<tr>
<td><code>~q</code></td>
<td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q</code>的新<code>NotQuery</code>对象上。</td>
</tr>
<tr>
<td><code>Query</code>程序实现类</td>
<td></td>
</tr>
<tr>
<td><code>Query_base</code></td>
<td>查询类的抽象基类</td>
</tr>
<tr>
<td><code>WordQuery</code></td>
<td><code>Query_base</code>的派生类，用于查找一个给定的单词</td>
</tr>
<tr>
<td><code>NotQuery</code></td>
<td><code>Query_base</code>的派生类，用于查找一个给定的单词</td>
</tr>
<tr>
<td><code>BinaryQuery</code></td>
<td><code>Query_base</code>的派生类，查询结果是<code>Query</code>运算对象没有出现的行的集合</td>
</tr>
<tr>
<td><code>OrQuery</code></td>
<td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的并集</td>
</tr>
<tr>
<td><code>AndQuery</code></td>
<td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的交集</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch14 重载运算与类型转换</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:22 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>第十四章 重载运算与类型转换 14.1 基本概念 语法相关： 重载的运算符必须是某个类的成员或至少拥有一个类类型的运算对象 重载运算符函数的参数数量和该运算符</description>
      <content:encoded><![CDATA[<h1 id="第十四章-重载运算与类型转换">第十四章 重载运算与类型转换</h1>
<h2 id="141-基本概念">14.1 基本概念</h2>
<ul>
<li>语法相关：
<ul>
<li>重载的运算符必须是某个类的成员或至少拥有一个类类型的运算对象</li>
<li>重载运算符函数的参数数量和该运算符作用的运算对象数量一样多，左侧运算对象传递给第一个参数，右侧传递给第二个，除了重载函数调用符<code>()</code>，其他重载运算符不能有默认实参，调用方式：<code>operator+(data1, data2)</code></li>
<li>如果一个重载的运算符是成员函数，<strong><code>this</code>指向左侧运算对象</strong>，因此定义成员运算符时的参数数量比运算符的运算对象少一个，调用方式：<code>data1.operator+=(data2)</code></li>
<li>重载运算符的优先级和结合律跟对应的内置运算符保持一致。</li>
</ul>
</li>
<li>使用：
<ul>
<li>一些运算符通常一起进行重载，比如重载了<code>==</code>也应该重载<code>!=</code>，重载了<code>&lt;</code>也应该重载其他关系操作，重载了算数运算符或位运算符，也应该重载对应的复合赋值运算符</li>
<li>考虑定义为成员函数还是普通函数
<ul>
<li>赋值（<code>=</code>）、下标（<code>[]</code>）、调用（<code>()</code>）和成员访问箭头（<code>-&gt;</code>）运算符必须是成员。</li>
<li>递增、递减、解引用、复合赋值运算符一般是成员</li>
<li>具有对称性的运算符如算术、相等性、关系和位运算符等，通常是非成员函数。</li>
<li>IO运算符应该声明为类的友元</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="142-运算符重载">14.2 运算符重载</h2>
<h3 id="1421-重载输出运算符">14.2.1 重载输出运算符<code>&lt;&lt;</code></h3>
<ul>
<li><code>ostream&amp; operator&lt;&lt; (ostream &amp;os, const T &amp;t);</code></li>
<li>第一个形参通常是一个非常量的<code>ostream</code>对象的引用，第二个形参是要打印类型的常量引用</li>
<li>输出运算符应该尽量减少格式化操作（比如不应该打印换行符）</li>
</ul>
<h3 id="1422-重载输入运算符">14.2.2 重载输入运算符<code>&gt;&gt;</code></h3>
<ul>
<li><code>istream&amp; operator&gt;&gt; (istream&amp; is, T &amp;t);</code></li>
<li>第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用。</li>
<li>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。
<ul>
<li>如果读取失败，输入运算符应该负责从错误中恢复，主要是将输入对象重置为合法状态，一般为未输入前的状态。</li>
</ul>
</li>
</ul>
<h3 id="1423-重载算数运算符-">14.2.3 重载算数运算符<code>+、-、*、/</code></h3>
<ul>
<li>一般设置为非成员函数，形参一般为常量引用，返回值不为引用（因为返回值一般是局部变量的拷贝）</li>
<li>一般都是先定义复合赋值运算符（成员函数），在基于此实现算数运算符（普通函数）</li>
</ul>
<h3 id="1424-相等运算符">14.2.4 相等运算符<code>==</code></h3>
<ul>
<li>如果定义了<code>operator==</code>，则这个类也应该定义<code>operator!=</code>。</li>
<li>相等运算符和不等运算符的一个应该把工作委托给另一个</li>
</ul>
<h3 id="1425-关系运算符">14.2.5 关系运算符<code>&lt;</code></h3>
<ul>
<li>如果两个对象是!=的，则一个对象应该<code>&lt;</code>另一个对象</li>
</ul>
<h3 id="1426-赋值运算符">14.2.6 赋值运算符<code>=</code></h3>
<ul>
<li>赋值运算符和复合赋值运算符应该返回左侧运算对象的引用。</li>
</ul>
<h3 id="1427-下标运算符">14.2.7 下标运算符<code>[]</code></h3>
<ul>
<li>一般会定义两个版本：
<ul>
<li>返回普通引用：<code>T&amp; operator[]();</code></li>
<li>是类的常量成员，并返回常量引用：<code>const T&amp; operator[] const;</code></li>
</ul>
</li>
</ul>
<h3 id="1428-递增和递减运算符--">14.2.8 递增和递减运算符<code>++、--</code></h3>
<ul>
<li>应该同时定义前置版本和后置版本，而且通常为类的成员。
<ul>
<li>前置运算符应该返回递增或递减后对象的引用：<code>string&amp; operator++();</code></li>
<li>后置运算符应该返回递增或递减前对象的值，而不是引用：<code>T operator++(int);</code>
<ul>
<li>后置版本接受一个额外的、不被使用的<code>int</code>类型的形参，且无需命名，编译器提供一个值为0的实参。该形参唯一的作用就是区分前置和后置递增。</li>
<li>如果想通过函数调用的方式使用后置递增，需要为这个int形参传递一个值（比如0）</li>
</ul>
</li>
<li>后置版本可以通过调用前置版本来实现。</li>
</ul>
</li>
</ul>
<h3 id="1429-成员访问运算符-">14.2.9 成员访问运算符<code>*、-&gt;</code></h3>
<ul>
<li>箭头运算符必须是类的成员，解引用运算符通常也是类的成员，且通常为const的成员函数，而且箭头运算符一般通过调用解引用运算符来实现</li>
</ul>
<h3 id="14210-函数调用运算符">14.2.10 函数调用运算符<code>()</code></h3>
<h2 id="148-函数调用运算符">14.8 函数调用运算符</h2>
<ul>
<li>如果类定义了调用运算符，则该类的对象称作【<strong>函数对象</strong>】。
<ul>
<li>函数对象可以被调用，同时因为函数对象可以存储状态（即数据成员），所以与普通函数相比更加灵活，通常作为泛型算法的实参</li>
</ul>
</li>
<li>C++中的【可调用对象】：函数、函数指针、lambda表达式、bind创建的对象、函数对象（或者说重载了调用运算符的类）
<ul>
<li>【可调用对象的类型】：lambda表达式有他自己唯一（未命名）的类类型，函数、函数指针的类型由返回值类型和实参类型决定</li>
<li>【调用形式】：指明了调用返回的类型和传递给调用的实参类型，比如<code>int(int,int)</code>
<ul>
<li>不同类型的可调用对象可以共享同一种调用形式，但它们并不是同一类型。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=29b2448c-5e82-8903-6155-e45a101f91f1&amp;page=538&amp;rect=58.810,599.770,427.200,622.320">例子</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="lambda是函数对象"><code>lambda</code>是函数对象</h3>
<ul>
<li>编译器将[[ch10-泛型算法#lambda表达式|lambda表达式]]转换成一个未命名类的未命名对象（即类中重载了函数调用运算符）
<ul>
<li>这个未命名类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认的拷贝/移动构造函数，通常视捕获变量的类型而定</li>
</ul>
</li>
<li>lambda默认不能改变它捕获的变量，此时未命名类中的函数调用运算符是一个const成员函数；如果lambda被声明为可变的，则调用运算符就不再是const成员函数
<ul>
<li>如果进行引用捕获，编译器直接使用该引用而无须在产生的类中相应存储为数据成员（由程序确保该引用绑定的对象确实存在）</li>
<li>如果进行值捕获，产生的类必须为捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化相应的数据成员</li>
</ul>
</li>
</ul>
<h3 id="标准库定义的函数对象">标准库定义的函数对象</h3>
<h6 id="标准库函数对象">标准库函数对象</h6>
<table>
<thead>
<tr>
<th>算术</th>
<th>关系</th>
<th>逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>plus&lt;Type&gt;</code></td>
<td><code>equal_to&lt;Type&gt;</code></td>
<td><code>logical_and&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>minus&lt;Type&gt;</code></td>
<td><code>not_equal_to&lt;Type&gt;</code></td>
<td><code>logical_or&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>multiplies&lt;Type&gt;</code></td>
<td><code>greater&lt;Type&gt;</code></td>
<td><code>logical_not&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>divides&lt;Type&gt;</code></td>
<td><code>greater_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>modulus&lt;Type&gt;</code></td>
<td><code>less&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>negate&lt;Type&gt;</code></td>
<td><code>less_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>一组表示算数运算符、关系运算符和逻辑运算符的模板类，每个类中重载了调用运算符来实现相应的命名操作</li>
<li>标准库函数对象经常用来替换算法中的默认运算符</li>
<li>如果想根据指针（或者说内存地址）进行排序，Type可以是指针类型，但是无法通过自定义的函数来进行内存地址的比较</li>
</ul>
<h3 id="可调用对象与function">可调用对象与function</h3>
<ul>
<li>调用形式相同的可调用对象，其类型不一定相同</li>
<li><code>function</code>封装了相同调用形式、但是不同类型的可调用对象
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">mod</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;%&#34;</span><span class="p">,</span> <span class="n">mod</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">[</span><span class="s">&#34;+&#34;</span><span class="p">](</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 将不同可调用类型的可调用对象存储在一起    
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>不能直接将重载函数的名字存入<code>function</code>类型的对象中，因为会产生二义性，消除二义性的方法是使用lambda或者函数指针而非函数名字
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">add</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="n">t</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">});</span> <span class="c1">// error: which add?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">fp</span><span class="p">});</span> 
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);};</span> <span class="c1">// 另一种写法
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="149-重载类型转换运算符">14.9 重载、类型转换、运算符</h2>
<p>类类型转换（或者称用户定义的类型转换）：转换构造函数（从其他类型转换到类类型）+类型转换运算符（从类类型转换到其他类型）</p>
<h3 id="类型转换运算符">类型转换运算符</h3>
<ul>
<li>一般类型：<code>operator type() const;</code></li>
<li>语法相关：
<ul>
<li>可以转换到任意类型（除了void），只要该类型能作为函数的返回类型</li>
<li>必须是类的成员函数，不能声明返回类型（但是函数返回一个对应类型的值），形参列表为空，一般为const成员函数</li>
</ul>
</li>
<li>使用：
<ul>
<li>类型转换运算符不需要显式调用，在执行运算时会隐式的执行</li>
<li>尽量确保类型转换是有意义的，避免过度使用</li>
<li>尽管编译器一次只能执行一个【用户定义的类型转换】，但是隐式的【用户定义的类型转换】可以置于一个标准内置类型转换之前或之后</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">smallInt</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">smallInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;bad value&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">		<span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="o">-</span><span class="n">val</span><span class="p">;}</span> <span class="c1">// 为了说明类型转换运算符的效果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">size_t</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">smallInt</span> <span class="n">s</span> <span class="o">=</span> <span class="mf">2.1</span><span class="p">;</span> <span class="c1">// 先将double转换为int，再使用转换构造函数将int转换为smallInt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span> <span class="o">+</span> <span class="mf">2.1</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 使用【类型转换运算符】将s隐式地转换为int，再转换为double相加
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>显式的类型转换运算符（C++11）：<code>explicit operator type() const;</code>
<ul>
<li>需要使用<code>static_cast&lt;type&gt;</code>进行显式的类型转换
<ul>
<li>例外：当表达式被用作条件时，显式的类型转换将被隐式的执行</li>
</ul>
</li>
<li>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的。</li>
</ul>
</li>
</ul>
<h3 id="避免有二义性的类型转换">避免有二义性的类型转换</h3>
<ul>
<li>必须确保在类类型和目标类型之间只存在唯一一种转换方式，否则很可能有二义性</li>
<li>两种情况会产生多重转换路径：
<ul>
<li>【用A的转换构造函数还是B的类型转换运算符】：A类定义了一个参数为B类的转换构造函数，B类定义了一个目标类型为A类的类型转换运算符，此时可以显式指定调用哪一种
<ul>
<li>无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">B</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span><span class="p">()</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="o">&amp;</span><span class="n">B</span><span class="p">);</span> <span class="c1">// 转换构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">B</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">operator</span> <span class="nf">A</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 类型转换运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 定义一个函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">B</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 二义性：使用B的【类型转换运算符】，还是使用A的【转换构造函数】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="k">operator</span> <span class="n">A</span><span class="p">());</span> <span class="c1">// 使用B的类型转换运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">A</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="p">));</span> <span class="c1">// 使用A的转换构造函数
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>【有多个类型转换运算符，用哪个】：类定义了多个类型转换规则，转换目标为内置类型，且转换级别一致
<ul>
<li>标准类型转换的级别决定编译器如何选择最佳匹配，转换级别一致就会出现二义性</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">operator</span> <span class="nf">double</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 二义性错误：a转换成int还是转换成double，再提升为long double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">short</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="nf">a2</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// 不会产生二义性错误，因为short类型提升为int优先于short类型提升为double
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>经验：尽量避免定义类型转换，且限制非显式构造函数
<ul>
<li>不要令两个类执行相同的类型转换</li>
<li>避免转换目标是内置算数类型的类型转换，特别是已经定义了一个转换成算数类型的类型转换</li>
</ul>
</li>
</ul>
<h3 id="重载与函数匹配">重载与函数匹配</h3>
<ul>
<li>[[ch06-函数#6.6 函数匹配|函数匹配]]</li>
<li>重载函数与转换构造函数
<ul>
<li>当调用重载函数时，如果两个或多个类型转换都提供了同一种可行匹配，则这些类型转换一样好</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">C</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">D</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">D</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 重载函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">func</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 二义性错误：
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=efa03877-7c33-c199-b557-f956b4531c90&amp;page=546&amp;rect=70.080,407.290,216.481,415.930">重载函数与用户定义的类型转换</a></li>
<li>重载运算符与函数匹配
<ul>
<li>如果既定义了类型转换运算符（转换到内置类型），又将运算符进行重载，会遇到二义性问题
<ul>
<li>如果<code>a</code>是一种类类型，则表达式<code>a sym b</code>可能是：
<ul>
<li><code>a.operatorsym(b);</code> 成员函数</li>
<li><code>operatorsym(a,b);</code> 普通函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">T</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">friend</span> <span class="n">T</span> <span class="k">operator</span><span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// 转换构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// 类型转换运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 二义性：可以将t转换成int进行内置加法，或者将1转换成类型T进行重载加法
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch13 拷贝控制</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:13 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</guid>
      <description>第十三章 拷贝控制 一些术语 构造函数： （合成的）[[ch07-类#^15282e|默认构造函数]]：编译器创建或是使用=default修饰的构造</description>
      <content:encoded><![CDATA[<h1 id="第十三章-拷贝控制">第十三章 拷贝控制</h1>
<h2 id="一些术语">一些术语</h2>
<ul>
<li>构造函数：
<ul>
<li>（合成的）[[ch07-类#^15282e|默认构造函数]]：编译器创建或是使用<code>=default</code>修饰的构造函数</li>
<li>一般的构造函数</li>
<li>拷贝构造函数</li>
<li>转换构造函数（或称为[[ch07-类#隐式的类型转换|隐式的类型转换]]）</li>
<li>移动构造函数</li>
<li>[[ch07-类#委托构造函数 （delegating constructor）|委托构造函数]]</li>
</ul>
</li>
<li>初始化类型：
<ul>
<li>默认初始化：<code>int* a = new int;</code></li>
<li>值初始化：<code>int *a = new int(); // 默认a=0</code></li>
<li>直接初始化：<code>int *a = new int(1);</code></li>
<li>拷贝初始化：<code>=</code></li>
<li>列表初始化：<code>{}</code></li>
</ul>
</li>
<li><strong>拷贝控制操作</strong>（copy control）（或者称为拷贝控制成员）:一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值、和销毁操作
<ul>
<li>拷贝构造函数（copy constructor）</li>
<li>拷贝赋值运算符（copy-assignment operator）</li>
<li>移动构造函数（move constructor）</li>
<li>移动赋值函数（move-assignement operator）</li>
<li>析构函数（destructor）</li>
</ul>
</li>
</ul>
<h2 id="131-拷贝赋值和销毁">13.1 拷贝、赋值和销毁</h2>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<ul>
<li>拷贝构造函数：
<ul>
<li>第一个参数是自身类型的引用（而且一般是const引用，否则导致无限递归，因为传递实参本身就是拷贝），且其他参数都有默认值</li>
<li>通常不会声明为explicit的</li>
</ul>
</li>
<li>合成的拷贝构造函数：
<ul>
<li>编译器将参数的非static成员逐个拷贝到正在创建的对象中。</li>
<li>对于某些类，合成的拷贝构造函数使用<code>=delete</code>来禁止对该类型对象的拷贝</li>
</ul>
</li>
<li>拷贝初始化：
<ul>
<li>通常使用拷贝构造函数完成，但也可能使用移动构造函数</li>
<li>出现场景：
<ul>
<li>用<code>=</code>定义变量时。</li>
<li>将一个对象作为实参传递给一个非引用类型的形参。</li>
<li>从一个返回类型为非引用类型的函数返回一个对象。</li>
<li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="拷贝赋值运算符">拷贝赋值运算符</h3>
<ul>
<li>重载赋值运算符：
<ul>
<li>通常返回一个指向其左侧运算对象（即自身）的引用：<code>return *this;</code></li>
</ul>
</li>
<li>合成拷贝赋值运算符：
<ul>
<li>将右侧运算对象的每个非<code>static</code>成员赋予左侧运算对象的对应成员，之后返回左侧对象的引用</li>
<li>对于某些类，合成的拷贝赋值运算符使用<code>=delete</code>来禁止对该类型对象的赋值</li>
</ul>
</li>
</ul>
<h3 id="析构函数">析构函数</h3>
<ul>
<li>析构顺序：
<ul>
<li>先执行析构函数体：因为销毁指针并不会delete它所指的对象，因此需要手动释放空间</li>
<li>再执行析构部分，按初始化顺序的逆序销毁非static的数据成员</li>
</ul>
</li>
</ul>
<h3 id="三五法则">三/五法则</h3>
<ul>
<li>背景：一个类通常需要拷贝构造函数、拷贝赋值运算符、析构函数（和移动构造函数、移动赋值运算符），虽然通常不会全部自定义，但是有时需要将这些拷贝控制成员看作一个整体</li>
<li>三五法则：
<ul>
<li>一个需要自定义析构函数的类，一定也需要一个拷贝构造函数和拷贝赋值运算符（比如类中有一个指向动态内存的指针，使用合成版本的构造函数只会复制指针的值）</li>
<li>一个需要自定义拷贝构造函数的类，也一定需要一个拷贝赋值运算符，反之亦然；但是未必需要析构函数（比如每个类需要有一个唯一id）</li>
</ul>
</li>
</ul>
<h3 id="显式合成default">显式合成<code>=default</code></h3>
<ul>
<li>可以通过将拷贝控制成员定义为<code>=default</code>来显式地要求编译器生成合成的版本。
<ul>
<li>只能对具有合成版本的成员函数（即默认构造函数或拷贝控制成员）使用=default</li>
<li>在类内部使用=default修饰成员声明时，合成的函数是隐式内联的；如果不希望合成的是内联函数，应该只对成员的类外定义使用=default</li>
</ul>
</li>
</ul>
<h3 id="阻止拷贝delete">阻止拷贝<code>=delete</code></h3>
<ul>
<li>删除的函数<code>=delete</code>：虽然声明了该函数，但是不能使用它们</li>
<li>语法相关：
<ul>
<li><code>=delete</code>只能出现在函数第一次声明的地方（即告诉编译器不定义这些函数）</li>
<li>可以对任何函数（除了析构函数，否则动态分配了对象后无法释放）使用</li>
<li>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的构造、拷贝、复制、析构函数被定义为删除的。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=87750c2e-2368-c105-88dd-7f6d8e702f15&amp;page=476&amp;rect=90.240,157.210,339.610,165.130">原文</a>。
<ul>
<li>如果类的某个数据成员的析构函数是删除的或不可访问的（如 private 的），则该类的合成析构函数、合成拷贝构造函数和默认构造函数被定义为删除的</li>
<li>如果类的某个数据成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。</li>
<li>如果类的某个数据成员的拷贝赋值运算符是删除的或不可访问的，则类的合成拷贝赋值运算符被定义为删除的。</li>
<li>如果类有一个 const 成员或引用成员，则类的合成拷贝赋值运算符被定义为删除的。（但是拷贝构造函数在初始化时执行）</li>
<li>如果类有一个没有类内初始化器且未显式定义默认构造函数的 const 成员或没有类内初始化器的引用成员，则该类的默认构造函数被定义为删除的</li>
</ul>
</li>
</ul>
</li>
<li>老版本的阻止拷贝
<ul>
<li>将拷贝控制成员设置为<code>private</code>，阻止普通用户拷贝对象（编译期报错）</li>
<li>将拷贝控制成员只声明不定义，友元和成员函数调用时报错（链接时报错）</li>
</ul>
</li>
</ul>
<h2 id="132-拷贝控制和资源管理">13.2 拷贝控制和资源管理</h2>
<ul>
<li>通常管理类外资源的类必须定义拷贝控制成员</li>
<li>类的行为可以像一个值，也可以像一个指针，主要是依据拷贝指针成员的行为
<ul>
<li>不允许拷贝和赋值的类，行为既不像值，也不像指针</li>
</ul>
</li>
</ul>
<h4 id="行为像值">行为像值</h4>
<ul>
<li>对象有自己的状态，副本和原对象是完全独立的，需要定义一个拷贝构造函数、一个析构函数、一个拷贝赋值运算符
<ul>
<li>赋值运算符通常组合析构函数（销毁左侧对象的资源）和构造函数（从右侧对象拷贝构造）的操作</li>
<li>拷贝赋值运算符要考虑到【自赋值】的正确性：</li>
</ul>
</li>
<li>好的方法是先将右侧对象（动态内存的指针对象）拷贝到一个局部临时对象，再销毁左侧对象的资源。（P453<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=79f6e710-cfdb-8315-7af9-bccf63645b0b&amp;page=479&amp;rect=80.880,111.600,117.360,120.720">例子</a>）</li>
</ul>
<h4 id="行为像指针">行为像指针</h4>
<ul>
<li>共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据，需要定义一个拷贝构造函数、一个析构函数、一个拷贝赋值运算符</li>
<li>最好使用shared_ptr管理资源，或者使用一个<strong>引用计数</strong>来直接管理（引用计数和资源一样是共享的，应该保存在动态内存中）。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=0cd2068b-d080-32af-4d30-59bb8bec3168&amp;page=481&amp;rect=80.160,327.130,164.400,334.810">引用计数的工作方式</a>：
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。创建一个对象时，计数器初始化为1。</li>
<li>拷贝构造函数不创建新的引用计数，而是拷贝对象的计数器并递增它。</li>
<li>析构函数递减计数器，如果计数器变为 0，则析构函数释放状态。</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为 0 就销毁状态。</li>
</ul>
</li>
<li>拷贝赋值运算符类似于shared_ptr，需要递增右侧对象的引用计数，递减左侧对象的引用计数</li>
<li>此时处理【自赋值】问题：先是右侧对象引用计数递增，后是左侧对象引用计数递减，自赋值时引用计数不变（P457<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=2715fed7-26b5-0064-9720-b469350a27a6&amp;page=482&amp;rect=236.842,53.760,344.400,62.160">例子</a>）</li>
</ul>
<h2 id="133-交换操作">13.3 交换操作</h2>
<ul>
<li>管理资源的类通常还定义一个名为<code>swap</code>的函数，经常用于重排元素顺序的算法。</li>
<li>优先使用自定义的swap，否则使用标准库的<code>std::swap</code></li>
<li>通常可以使用swap来实现赋值运算符
<ul>
<li>右侧对象传值，然后将左侧对象与右侧对象的副本进行交换（copy and swap），可以正确处理自赋值的情况</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">HasPtr</span><span class="p">{</span> <span class="c1">// 行为类似值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">HasPtr</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">HasPtr</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">())</span> <span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// 拷贝构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">HasPtr</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;&amp;</span><span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span> <span class="mi">0</span><span class="p">;}</span> <span class="c1">// 移动构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span> <span class="c1">// 拷贝赋值操作符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">ps</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 特点：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 1.用swap实现赋值运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 2.既是拷贝赋值运算符（参数是左值），又是移动赋值运算符（参数是右值）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="n">HasPtr</span> <span class="n">rhs</span><span class="p">){</span> <span class="c1">// copy and swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 传入的是rhs的副本（假设是rhs-copy），this还是指向本身（假设是lhs）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// 交换左侧对象(lhs)和右侧对象的副本(rhs-copy)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 此时this指向rhs-copy（更准确来说还是指向lhs地址，但是原来lhs的内容已经被swap为了rhs-copy）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// swap后的lhs没有变量来接管，因此被析构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 因此实现了this指向从lhs改变为rhs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span><span class="k">delete</span> <span class="n">ps</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span> <span class="c1">// 当某个成员没有自定义的swap时，使用标准库版本的swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">ps</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">i</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">HasPtr</span> <span class="n">h</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Foo</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span> <span class="c1">// 优先使用自定义版本的swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">h</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// 使用HasPtr版本的swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">HasPtr</span> <span class="nf">p1</span><span class="p">(</span><span class="s">&#34;test)</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span> <span class="c1">// 使用拷贝赋值运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span> <span class="c1">// 使用移动赋值运算符
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="134-拷贝控制示例">13.4 拷贝控制示例</h2>
<h2 id="135-动态内存管理类">13.5 动态内存管理类</h2>
<h2 id="136-对象移动">13.6 对象移动</h2>
<p>使用对象移动的原因：</p>
<ul>
<li>一些拷贝操作后，原对象会被立即销毁，因此引入移动操作可以大幅度提升性能。</li>
<li>C++11可以用容器保存不可拷贝的类型，只要它们可以被移动即可。
<ul>
<li>标准库容器、<code>string</code>和<code>shared_ptr</code>类既可以支持移动也支持拷贝。<code>IO</code>类和<code>unique_ptr</code>类可以移动但不能拷贝。</li>
</ul>
</li>
</ul>
<h3 id="左值与右值">左值与右值</h3>
<ul>
<li>左值：
<ul>
<li>返回左值的表达式：返回左值引用的函数，赋值、下标、解引用、前置递增递减运算符，</li>
<li>左值引用：可以绑定到变量（包括右值引用变量）、返回左值的表达式</li>
<li>const的左值引用可以绑定到右值</li>
</ul>
</li>
<li>右值：
<ul>
<li>右值要么是字面常量（没有其他用户），要么是表达式求值过程中创建的临时变量（即将被销毁）</li>
<li>返回右值的表达式：返回非引用类型的函数，算数、关系、位、后置递增递减运算符</li>
<li>右值引用：可以绑定到要求转换的表达式、字面常量、返回右值的表达式</li>
</ul>
</li>
<li>move函数： ^d3a2a0
<ul>
<li>可以将一个右值引用绑定到左值上 <code>int a=1; int &amp;&amp;r = std::move(a);</code></li>
<li>定义在头文件utility中</li>
<li><code>move</code>告诉编译器，我们有一个左值，但我希望像右值一样处理它。</li>
<li>对左值调用<code>move</code>意味着：不在使用该左值的值，除非销毁它或者对它重新赋值</li>
<li>使用move的代码应该使用std::move而不是move，可以避免潜在的名字冲突</li>
</ul>
</li>
</ul>
<h3 id="移动构造函数和移动赋值运算符">移动构造函数和移动赋值运算符</h3>
<ul>
<li>移动构造函数
<ul>
<li>第一个参数是该类类型的一个右值引用，比如<code>StrVec::StrVec(StrVec &amp;&amp;s) noexcept{}</code></li>
<li>在形参列表后添加关键字<code>noexcept</code>可以指明该函数不会抛出任何异常，在声明和定义中均应该指明<code>noexcept</code>
<ul>
<li>不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code></li>
<li>原因：如果用移动构造函数，移动到一半抛出异常，容器不能满足即使发生异常也保持自身不变的要求，因此需要显式标记<code>noexcept</code>；否则编译器基于上面的考虑，会调用拷贝构造函数而非移动构造函数</li>
</ul>
</li>
<li>除了完成资源移动，还要确保移动后源对象是可以安全销毁的（比如将源对象中数组的指针指向nullptr，然后源对象进行正确析构，否则会释放掉刚才移动的对象），用户不能使用移动后源对象的值</li>
</ul>
</li>
<li>移动赋值运算符
<ul>
<li><code>StrVec&amp; StrVec::operator=(StrVec &amp;&amp; rhs) noexcept{}</code></li>
<li>使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能，依赖于实参的类型：实参是左值，则实参被拷贝；实参是右值，则实参被移动：<code>StrVec&amp;   StrVec::operator=(StrVec rhs);</code></li>
</ul>
</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=e9cc2ba7-e7de-20c5-6d18-bd84fd5f6733&amp;page=506&amp;rect=180.960,300.960,227.280,309.840">移动迭代器</a>：
<ul>
<li>普通迭代器的解引用运算符返回一个指向元素的左值，移动迭代器的解引用运算符生成一个右值引用</li>
<li><code>make_move_iterator</code>函数将一个普通迭代器转换为一个移动迭代器。</li>
<li>因此，可以将移动迭代器传递给算法或是allocator的伴随算法</li>
<li>但是，标准库不能保证哪些算法适用于移动迭代器，哪些不适用。由于移动一个对象可能销毁掉源对象，因此要确定以后不再访问这个元素时，才能将移动迭代器传递给算法。</li>
<li>移后源对象具有不确定的状态，必须确认移后源对象没有其他用户，因此要小心使用</li>
</ul>
</li>
<li>合成的移动操作
<ul>
<li>如果一个类定义了自己的拷贝构造函数、拷贝赋值函数或者析构函数，编译器不会为它合成移动构造函数和移动赋值运算符</li>
<li>如果一个类没有移动操作，类会用对应的拷贝操作来代替移动操作，即使使用move函数也是如此</li>
<li>只有当一个类没有自定义的拷贝控制成员，且类的每个非static数据成员都可以移动（内置类型可以移动，类类型要有对应的移动操作）时，编译器才会为类合成移动构造函数和移动赋值运算符；否则即使显式要求合成移动操作<code>=default</code>，编译器也会将移动操作定义为<code>=delele</code></li>
<li>与拷贝操作不同，移动操作永远不会隐式定义为<code>=delete</code>
<ul>
<li>例外：<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=26545b20-71fb-2bf8-83a8-871ae37ad44a&amp;page=502&amp;rect=64.080,328.080,432,350.400">将合成的移动操作定义为删除的</a></li>
</ul>
</li>
<li>如果一个类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝函数和拷贝赋值运算符会被定义为删除的</li>
<li>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的</li>
</ul>
</li>
</ul>
<h3 id="引用限定符">引用限定符</h3>
<ul>
<li>成员函数一般有接受拷贝的<code>const T&amp;</code>版本和接受右值的<code>T&amp;&amp;</code>版本</li>
<li><strong>引用限定符</strong><code>&amp;</code>和<code>&amp;&amp;</code>：
<ul>
<li>限制调用者必须是左值还是右值</li>
<li>语法相关：
<ul>
<li>引用限定符只能用于非static成员函数</li>
<li>引用限定符必须同时出现在函数的声明和定义中</li>
<li>一个函数可以同时使用const和引用限定，即引用限定符必须在const限定符之后</li>
<li>如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符</li>
</ul>
</li>
<li>可以综合使用引用限定符和const限定符来区分一个函数的重载版本
<ul>
<li>使用const &amp;&amp;进行限定时，调用者必须是右值</li>
<li>使用const &amp;进行限定时，调用者可以是左值，也可以是右值</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Test</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nf">show</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="k">return</span> <span class="n">val</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// const int show() &amp; {} // 报错：返回值与重载无关，见6.4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="nf">show</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="k">return</span> <span class="n">val</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nf">show</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="k">return</span> <span class="n">val</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nf">show</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;&amp;</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="k">return</span> <span class="n">val</span><span class="p">;}</span> <span class="c1">// 右值本来就是常量，这种方法无法被调用（被show() &amp;&amp;）覆盖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>    
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">Test</span> <span class="n">t1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">t1</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">Test</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">show</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">Test</span> <span class="n">t3</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">t3</span><span class="p">.</span><span class="n">show</span><span class="p">();</span> <span class="c1">// const对象或是const对象的指针/引用，只能调用const成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 输出1 2 3 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch12 动态内存</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:04 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</guid>
      <description>第十二章 动态内存 对象的生命周期： 全局对象在程序启动时分配，结束时销毁。 局部对象在进入程序块时创建，离开块时销毁。 局部static对象在第一次</description>
      <content:encoded><![CDATA[<h1 id="第十二章-动态内存">第十二章 动态内存</h1>
<ul>
<li>对象的生命周期：
<ul>
<li>全局对象在程序启动时分配，结束时销毁。</li>
<li>局部对象在进入程序块时创建，离开块时销毁。</li>
<li>局部<code>static</code>对象在第一次使用前分配，在程序结束时销毁。</li>
<li>动态分配对象：只能显式地被释放。</li>
</ul>
</li>
<li>对象的内存位置：
<ul>
<li><strong>静态内存</strong>用来保存局部<code>static</code>对象、类<code>static</code>对象、定义在任何函数之外的变量。</li>
<li><strong>栈内存</strong>用来保存定义在函数内的非<code>static</code>对象；由操作系统自动分配和释放，内存空间比较小</li>
<li><strong>堆内存</strong>，又称自由空间，用来存储<strong>动态分配</strong>的对象；手动申请和释放，内存空间比较大</li>
</ul>
</li>
</ul>
<h2 id="121-动态内存与智能指针">12.1 动态内存与智能指针</h2>
<h3 id="1210-动态内存">12.1.0 动态内存</h3>
<ul>
<li>使用<code>new</code>动态分配内存，返回的是一个指向该对象的指针
<ul>
<li>动态分配的对象是默认初始化的，也可以使用值初始化、直接初始化（圆括号中有初始值）、列表初始化方式来进行初始化
<ul>
<li>对于类而言，值初始化与默认初始化没有区别</li>
<li>对于内置类型而言，
<ul>
<li>值初始化有一个确定的初始值：<code>int *p = new int(); // 此时所指对象值为0</code></li>
<li>默认初始化的初始值未定：<code>int *p = new int;</code></li>
<li>直接初始化：<code>auto *p = new int(2);</code></li>
</ul>
</li>
</ul>
</li>
<li>可以使用new分配const对象，返回指向const类型的指针，但是动态分配的const对象必须初始化
<ul>
<li><code>const int* pc = new const int(1);</code></li>
</ul>
</li>
<li>new失败会抛出<code>bad_alloc</code>异常
<ul>
<li>使用定位new可以阻止抛出异常，定位new允许将new传递额外参数</li>
<li>如果传递<code>nothrow</code>给new，则new在分配失败之后会返回空指针：<code>int* p = new(nothrow) int;</code></li>
</ul>
</li>
</ul>
</li>
<li>使用<code>delete</code>销毁对象，并释放内存
<ul>
<li><code>delete</code>后的指针称为空悬指针（dangling pointer），应该在delete之后将指针值置空。</li>
</ul>
</li>
<li>使用<code>new/delete</code>，要么容易忘记释放内存引起内存泄露，要么释放内存后再使用引起use after free</li>
<li>智能指针：定义在头文件<code>memory</code>中
<ul>
<li><code>shared_ptr</code>：允许多个指针指向同一个对象，共享内存</li>
<li><code>unique_ptr</code>：独占所指向的对象</li>
<li><code>weak_ptr</code>：是一种弱引用，指向<code>shared_ptr</code>所管理的对象</li>
</ul>
</li>
</ul>
<h3 id="1211-shared_ptr">12.1.1 shared_ptr</h3>
<h4 id="声明和初始化">声明和初始化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp1</span><span class="p">;</span> <span class="c1">// 指向类型T的空智能指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp2</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="c1">// 参数q为T*类型的内置指针, sp2接管对象的所有权
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp3</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span> <span class="c1">// sp3使用删除器d代替默认删除器delete（删除器d必须接受一个T*类型的参数）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp4</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span> <span class="c1">// 参数sp为shared_ptr&lt;T&gt;，等价于sp4 = sp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp5</span> <span class="o">=</span> <span class="n">sp4</span><span class="p">;</span> <span class="c1">// sp4引用计数递减，sp5引用计数递增
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp6</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">);</span> <span class="c1">// 使用参数args初始化类型为T的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp7</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="c1">// 参数u为unique_ptr&lt;T&gt;, sp7接管对象的所有权，并将u置为空
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>语法相关：
<ul>
<li>使用内置指针<code>q</code>进行初始化必须使用直接初始化形式（如<code>sp2</code>），不能使用拷贝初始化，因为调用了explicit的转换构造函数</li>
<li>默认内置指针<code>q</code>必须指向动态内存（因为智能指针默认使用<code>delete</code>释放对象），如果将智能指针绑定到指向其他类型资源的指针上，需要使用自定义的删除器代替<code>delete</code></li>
</ul>
</li>
<li>推荐使用<code>sp6</code>的初始化方式<code>make_shared</code>，即<strong>不要混合使用智能指针和内置指针</strong>
<ul>
<li>不推荐<code>sp2</code>方式进行初始化，因为同一个内置指针<code>q</code>不能绑定到多个独立创建的shared_ptr，否则<strong>析构时多次delete</strong></li>
<li>如果使用<code>q</code>创建shared_ptr后（比如<code>sp2</code>），不要再使用<code>q</code>，因为<code>q</code>无法知道对象何时被shared_ptr释放，随时可能变成空悬指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp1</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// shared_ptr&lt;int&gt; sp(p1); // 报错，p1绑定到独立的两个shared_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">add</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">));</span> <span class="c1">// 函数调用完后，智能指针引用计数为0，p2所指向内存被释放，此时p2成为悬空指针，危险！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">sp3</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// 推荐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">add</span><span class="p">(</span><span class="n">sp3</span><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="其他操作">其他操作</h4>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>p.get()</code></td>
<td style="text-align:center">返回<code>p</code>中保存的指针。如果智能指针释放了对象，则get返回一个悬空指针。</td>
</tr>
<tr>
<td style="text-align:center"><code>p.use_count()</code></td>
<td style="text-align:center">返回与<code>p</code>共享对象的智能指针的数量</td>
</tr>
<tr>
<td style="text-align:center"><code>p.unique()</code></td>
<td style="text-align:center">当前对象是否被<code>p</code>独占（或者当<code>p.use_count()==1</code>时返回<code>true</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>p.reset()</code></td>
<td style="text-align:center">如果<code>p</code>时唯一指向其对象的<code>shared_ptr</code>，则释放此对象</td>
</tr>
<tr>
<td style="text-align:center"><code>p.reset(q)</code></td>
<td style="text-align:center">令<code>p</code>指向内置指针<code>q</code></td>
</tr>
<tr>
<td style="text-align:center"><code>p.reset(q, d)</code></td>
<td style="text-align:center">令<code>p</code>指向内置指针<code>q</code>，并调用删除器<code>d</code>（而非默认删除器）来释放<code>q</code></td>
</tr>
</tbody>
</table>
<ul>
<li>智能指针不支持指针算数运算</li>
<li><code>get</code>函数
<ul>
<li>智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象，主要用于向不能使用智能指针的代码传递内置指针。</li>
<li>使用get返回的指针不能用来delete</li>
<li>不要使用get函数初始化另一个智能指针或为智能指针赋值（因为析构时多次delete）</li>
<li>只有在确定代码不会delete指针的情况下，才使用get</li>
</ul>
</li>
<li><code>unique</code>函数通常用与<code>reset</code>一起使用，检查shared_ptr是否独占当前对象，如果不是需要使用<code>reset</code>指向新的元素或拷贝。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=ea61576a-2659-8626-9cab-fee42fcc5b31&amp;page=440&amp;rect=65.520,177.370,433.440,199.210">例子</a>。</li>
</ul>
<h4 id="使用建议">使用建议</h4>
<ul>
<li>不使用相同的内置指针初始化或<code>reset</code>多个智能指针</li>
<li>不<code>delete get()</code>返回的指针。</li>
<li>不使用<code>get()</code>初始化或<code>reset</code>另一个智能指针</li>
<li>如果你使用<code>get()</code>返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。</li>
<li>如果你使用智能指针管理的资源不是<code>new</code>分配的内存，记住传递给它一个删除函数。</li>
</ul>
<h3 id="1212-unique_ptr">12.1.2 unique_ptr</h3>
<h4 id="声明和初始化-1">声明和初始化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">u1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">u1</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="c1">// q为类型T*的内置指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">uniuqe_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">u2</span><span class="p">;</span> <span class="c1">// 定义一个unique_ptr，指向类型T，有一个类型为D的删除器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">u3</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">u4</span> <span class="o">=</span> <span class="n">make_uniuqe</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">);</span> <span class="c1">// C++14
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>unique_ptr将删除器类型放在尖括号中，因为删除器类型也是unique_ptr类型的一部分</li>
<li>同一时刻只能有一个<code>unique_ptr</code>指向一个给定的对象。当unique_ptr被销毁时，它指向的对象也被销毁
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">uniuqe_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 正确，但是u销毁之后p成为空悬指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">uniuqe_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">up</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 推荐写法
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>unique_ptr必须使用内置指针进行直接初始化（圆括号初始化），不支持拷贝或赋值操作（unique的含义，而且其拷贝构造函数是删除的）
<ul>
<li>例外：可以拷贝或赋值一个即将被销毁的unique_ptr（移动构造、移动赋值）</li>
</ul>
</li>
</ul>
<h4 id="其他操作-1">其他操作</h4>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u.get()</code></td>
<td style="text-align:center">返回<code>u</code>中保存的指针。如果智能指针释放了对象，则<code>get</code>返回一个悬空指针。</td>
</tr>
<tr>
<td style="text-align:center"><code>u.release()</code></td>
<td style="text-align:center"><code>u</code>放弃对指针的控制权（但不会释放指向对象的内存），返回内置指针，并将<code>u</code>置空。</td>
</tr>
<tr>
<td style="text-align:center"><code>u.reset()</code></td>
<td style="text-align:center">释放<code>u</code>指向的对象</td>
</tr>
<tr>
<td style="text-align:center"><code>u.reset(q)</code></td>
<td style="text-align:center">令<code>u</code>指向内置指针<code>q</code>指向的对象，<code>u</code>原来指向的对象被释放</td>
</tr>
</tbody>
</table>
<ul>
<li>release返回的指针通常用来初始化另一个智能指针(reset)或给智能指针赋值
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="n">p2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span> <span class="n">p3</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">p1</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">// p1放弃了对象的控制权，对象的内存没有释放，而且对象的指针丢失
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">// 使用p保存对象的指针，但是后续需要使用delete(p)释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">release</span><span class="p">());</span> <span class="c1">// u接管p3
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="1213-weak_ptr">12.1.3 weak_ptr</h3>
<h4 id="声明和初始化-2">声明和初始化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">w1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">w2</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span> <span class="c1">// sp是shared_ptr&lt;T&gt;类型, w2指向一个由shared_ptr管理的对象，但是不改变shared_ptr的引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">w3</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// p可以是shared_ptr或weak_ptr
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针。</li>
</ul>
<h4 id="其他操作-2">其他操作</h4>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>w.reset()</code></td>
<td style="text-align:center">将<code>w</code>置为空。</td>
</tr>
<tr>
<td style="text-align:center"><code>w.use_count()</code></td>
<td style="text-align:center">与<code>w</code>共享对象的<code>shared_ptr</code>的数量。</td>
</tr>
<tr>
<td style="text-align:center"><code>w.expired()</code></td>
<td style="text-align:center">若<code>w.use_count()</code>为0，返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td style="text-align:center"><code>w.lock()</code></td>
<td style="text-align:center">如果<code>expired</code>为<code>true</code>，则返回一个空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code>。</td>
</tr>
</tbody>
</table>
<ul>
<li>weak_ptr不能直接访问对象。因为如果shared_ptr被销毁，即使有weak_ptr指向对象，对象仍然可能被释放</li>
<li>使用weak_ptr访问对象时，必须先调用lock函数，以检查指向的对象是否仍然存在
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="122-动态数组">12.2 动态数组</h2>
<p>C++中提供了两种动态数组的分配方式：</p>
<ul>
<li>new动态数组，将内存分配和对象构造结合在一起，对应的delete将对象析构和内存释放结合在一起</li>
<li>使用allocator类，可以实现内存分配与对象构造的分离，管理内存更灵活</li>
</ul>
<h3 id="1221-动态数组">12.2.1 动态数组</h3>
<h4 id="new和动态数组"><code>new</code>和动态数组</h4>
<ul>
<li><code>new</code>一个动态数组，返回指向第一个对象的指针（返回的指针不是数组类型，而是数组元素类型）
<ul>
<li>由于new分配的内存不是数组类型（比如<code>int[10]</code>），因此不能对动态数组调用begin和end，也不能使用range-for遍历元素</li>
</ul>
</li>
<li>new的数组可以进行值初始化、列表初始化
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">sz</span><span class="p">];</span> <span class="c1">// 没有初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">sz</span><span class="p">]();</span> <span class="c1">// 值初始化为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">sz</span><span class="p">]{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="c1">// 列表初始化  
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>因为值初始化时不能提供参数，所以没有默认构造函数的类是无法动态分配数组的。</li>
<li>动态分配一个空数组是合法的，此时返回一个合法的非空指针，类似于尾后指针</li>
<li>使用<code>delete []</code>释放动态分配的数组，使用<code>delete</code>释放动态分配的对象</li>
</ul>
<h4 id="unique_ptr和动态数组"><code>unique_ptr</code>和动态数组</h4>
<p>可以使用unique_ptr管理new分配的数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]());</span> <span class="c1">// p指向一个包含10个元素的int数组，数组元素使用值初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 指向数组的unique_ptr不支持成员访问运算符（点和箭头），支持下标访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">// 自动用delete[]销毁其指针
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="shared_ptr和动态数组"><code>shared_ptr</code>和动态数组</h4>
<ul>
<li><code>shared_ptr</code>不支持直接管理动态数组，如果想用<code>shared_ptr</code>管理动态数组，必须提供自定义的删除器（否则使用delete释放动态数组，报错）</li>
<li><code>shared_ptr</code>未定义下标运算符，智能指针也不支持指针算数运算。可以通过get函数获取内置指针再进行访问</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">](),</span> <span class="p">[](</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span><span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="1222-allocator类">12.2.2 allocator类</h3>
<ul>
<li>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，帮助我们将内存分配和对象构造分离开。</li>
<li>分配的是原始的、未构造的内存，程序需要再内存中构造对象。（直接使用未构造的内存是未定义的行为）</li>
<li>对象使用完之后，需要对每个构造的元素调用destroy进行销毁</li>
</ul>
<h6 id="标准库allocator类及其方法">标准库allocator类及其方法</h6>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>allocator&lt;T&gt; a</code></td>
<td>定义了一个名为<code>a</code>的<code>allocator</code>对象，它可以为类型为<code>T</code>的对象分配内存</td>
</tr>
<tr>
<td><code>a.allocate(n)</code></td>
<td>分配一段原始的、未构造的内存，保存<code>n</code>个类型为<code>T</code>的对象，返回一个指向类型<code>T</code>的指针</td>
</tr>
<tr>
<td><code>a.deallocate(p, n)</code></td>
<td>释放从<code>T*</code>指针<code>p</code>中地址开始的内存，这块内存保存了<code>n</code>个类型为<code>T</code>的对象；<code>p</code>必须是一个先前由<code>allocate</code>返回的指针。且<code>n</code>必须是<code>p</code>创建时所要求的大小。在调用<code>deallocate</code>之前，用户必须对每个在这块内存中创建的对象调用<code>destroy</code>。</td>
</tr>
<tr>
<td><code>a.construct(p, args)</code></td>
<td><code>p</code>必须是一个类型是<code>T*</code>的指针，指向一块原始内存；<code>args</code>被传递给类型为<code>T</code>的构造函数，用来在<code>p</code>指向的内存中构造一个对象。使用时需要<code>p++</code>移动指针</td>
</tr>
<tr>
<td><code>a.destroy(p)</code></td>
<td><code>p</code>为<code>T*</code>类型的指针，此算法对<code>p</code>指向的对象执行析构函数。</td>
</tr>
</tbody>
</table>
<ul>
<li>construct和destroy一次只能构造或销毁一个对象，使用中可能需要使用指针对每个元素进行遍历</li>
</ul>
<h6 id="allocator伴随算法">allocator伴随算法</h6>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>uninitialized_copy(b, e, b2)</code></td>
<td>从【迭代器<code>b</code>和<code>e</code>给定的输入范围】中拷贝元素到【迭代器<code>b2</code>指定的未构造的原始内存】中。<code>b2</code>指向的内存必须足够大，能够容纳输入序列中元素的拷贝。</td>
</tr>
<tr>
<td><code>uninitialized_copy_n(b, n, b2)</code></td>
<td>从迭代器<code>b</code>指向的元素开始，拷贝<code>n</code>个元素到【<code>b2</code>开始的未构造内存】中。</td>
</tr>
<tr>
<td><code>uninitialized_fill(b, e, t)</code></td>
<td>在【迭代器<code>b</code>和<code>e</code>指向的原始内存范围】中创建对象，对象的值均为<code>t</code>的拷贝。</td>
</tr>
<tr>
<td><code>uninitialized_fill_n(b, n, t)</code></td>
<td>从【迭代器<code>b</code>指向的原始内存地址】开始创建<code>n</code>个对象。<code>b</code>必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。</td>
</tr>
</tbody>
</table>
<ul>
<li>进行拷贝和填充未初始化内存</li>
<li>返回最后一个构造元素的尾后位置</li>
</ul>
<h2 id="123-使用标准库文本查询程序">12.3 使用标准库：文本查询程序</h2>
<p><a href="https://note.youdao.com/ynoteshare/index.html?id=2d14bd20c72c482dc96b195231795ab7&amp;type=note&amp;_time=1695087341648">参考</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch11 关联容器</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 27 Feb 2024 15:57:46 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</guid>
      <description>第十一章 关联容器 关联容器基于关键字访问元素，顺序容器基于位置访问元素 关联容器类型 11.2 关联容器概述 关联容器的初始化可以使用直接初始化（圆括号初始</description>
      <content:encoded><![CDATA[<h1 id="第十一章-关联容器">第十一章 关联容器</h1>
<ul>
<li>关联容器基于关键字访问元素，顺序容器基于位置访问元素</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=16110e06-66cf-a0f0-d524-7a3218cd59e7&amp;page=400&amp;rect=236.880,402.480,290.160,409.920">关联容器类型</a></li>
</ul>
<h2 id="112-关联容器概述">11.2 关联容器概述</h2>
<ul>
<li>关联容器的初始化可以使用直接初始化（圆括号初始化）、列表初始化、拷贝初始化、迭代器范围初始化（会对关键字自动去重）</li>
<li><code>map</code>类型通常被称为关联数组</li>
<li>对于有序容器，关键字类型必须定义元素比较的方法（即<code>&lt;</code>），<strong>严格弱序</strong></li>
<li>pair类型
<ul>
<li>定义在<code>utility</code>头文件</li>
<li>map中的每个元素都是一个pair类型的对象，pair是一个模板类型，保存两个名为first和second的共有数据成员，first保存关键字，second保存值</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pair&lt;T1, T2&gt; p;</code></td>
<td><code>p</code>是一个<code>pair</code>，两个类型分别是<code>T1</code>和<code>T2</code>的成员都进行了值初始化。</td>
</tr>
<tr>
<td><code>pair&lt;T1, T2&gt; p(v1, v2);</code></td>
<td><code>first</code>和<code>second</code>分别用<code>v1</code>和<code>v2</code>进行初始化。</td>
</tr>
<tr>
<td><code>pair&lt;T1, T2&gt;p = {v1, v2};</code></td>
<td>等价于`p(v1, v2)</td>
</tr>
<tr>
<td><code>make_pair(v1, v2);</code></td>
<td><code>pair</code>的类型从<code>v1</code>和<code>v2</code>的类型推断出来。</td>
</tr>
<tr>
<td><code>p.first</code></td>
<td>返回<code>p</code>的名为<code>first</code>的数据成员。</td>
</tr>
<tr>
<td><code>p.second</code></td>
<td>返回<code>p</code>的名为<code>second</code>的数据成员。</td>
</tr>
<tr>
<td><code>p1 relop p2</code></td>
<td>relop(relational operations,&lt;,&gt;,&lt;=,&gt;=)，运算关系符按字典序定义。</td>
</tr>
<tr>
<td><code>p1 == p2</code></td>
<td>必须两对元素两两相等</td>
</tr>
<tr>
<td><code>p1 != p2</code></td>
<td>同上</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 定义一个重载键类型的类，重载()操作符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">MyCmp</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();}</span>    
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">MyCmp</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">{{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;ab&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">}};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();}</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mp2</span><span class="p">({{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">}},</span> <span class="n">cmp</span><span class="p">);</span> <span class="c1">// 模板中传入函数类型，构造函数中传入函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">CMP</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">CMP</span><span class="o">&gt;</span> <span class="n">mp3</span><span class="p">({{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">}},</span> <span class="n">cmp</span><span class="p">);</span> <span class="c1">// 或者模板中传入函数类型的别名，构造函数中同样传入函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">cmp</span><span class="p">)</span><span class="o">*&gt;</span> <span class="n">mp4</span><span class="p">({{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">}},</span> <span class="n">cmp</span><span class="p">);</span> <span class="c1">// 使用decltype获取函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">CMP</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">mp3</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">mp3</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="c1">// 或者使用map&lt;string, int&gt;::iterator iter也可以
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="s">&#34; &#34;</span> <span class="o">&gt;&gt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&gt;&gt;</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="113-关联容器操作">11.3 关联容器操作</h2>
<ul>
<li>关联容器额外的类型别名：</li>
</ul>
<table>
<thead>
<tr>
<th>类型别名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key_type</code></td>
<td>此容器类型的关键字类型</td>
</tr>
<tr>
<td><code>mapped_type</code></td>
<td>每个关键字关联的类型，只适用于<code>map</code>系列</td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>对于<code>map</code>，是<code>pair&lt;const key_type, mapped_type&gt;</code>（注意关键字部分有const）; 对于<code>set</code>，和<code>key_type</code>相同。</td>
</tr>
</tbody>
</table>
<ul>
<li>解引用一个关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的值的引用。
<ul>
<li><code>map</code>而言，value_type是pair类型（<code>pair&lt;const key_type, mapped_type&gt;</code>）</li>
<li><code>set</code>而言，value_type是<code>const key_type</code>，普通迭代器和const迭代器都是只读的，不能修改值</li>
</ul>
</li>
</ul>
<h3 id="添加元素insert">添加元素：<code>insert</code></h3>
<table>
<thead>
<tr>
<th><code>insert</code>操作</th>
<th>关联容器</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.insert(v)</code>  <code>c.emplace(args)</code></td>
<td><code>v</code>是<code>value_type</code>类型的对象；<code>args</code>用来构造一个元素。函数返回一个<code>pair</code>，指向具有指定关键字的元素的迭代器，和一个指示插入是否成功的<code>bool</code>值。</td>
</tr>
<tr>
<td><code>c.insert(b, e)</code> <code>c.insert(il)</code></td>
<td><code>b</code>和<code>e</code>是迭代器，表示一个<code>c::value_type</code>类型值的范围；<code>il</code>是这种值的花括号列表。函数返回<code>void</code>。对于 <code>map</code>和<code>set</code>，只插入关键字不在<code>c</code>中的元素。</td>
</tr>
<tr>
<td><code>c.insert(p, v)</code>  <code>c.emplace(p, args)</code></td>
<td>类似<code>insert(v)</code>，但将迭代器<code>p</code>作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。</td>
</tr>
</tbody>
</table>
<ul>
<li>向<code>map</code>添加元素（在参数列表中构建pair），例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>相对于下标操作，多使用insert（因为有返回值）
<ul>
<li>例子：wordcount
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">word</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">++</span><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">word</span><span class="p">,</span> <span class="mi">0</span><span class="p">}).</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="删除元素erase">删除元素：<code>erase</code></h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.erase(k)</code></td>
<td>从<code>c</code>中删除每个关键字为<code>k</code>的元素。返回一个<code>size_type</code>值，指出删除的元素的数量。（顺序容器没有该操作）</td>
</tr>
<tr>
<td><code>c.erase(p)</code></td>
<td>从<code>c</code>中删除迭代器<code>p</code>指定的元素。<code>p</code>必须指向<code>c</code>中一个真实元素，不能等于<code>c.end()</code>。返回一个指向<code>p</code>之后元素的迭代器。</td>
</tr>
<tr>
<td><code>c.erase(b, e)</code></td>
<td>删除迭代器对<code>b</code>和<code>e</code>所表示范围中的元素。返回<code>e</code>。</td>
</tr>
</tbody>
</table>
<ul>
<li>注意遍历容器删除元素时，map与vector不同</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">){</span> 
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">		<span class="n">m</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="o">++</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> 
</span></span><span class="line"><span class="cl">		<span class="n">iter</span><span class="o">++</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">){</span> 
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">		<span class="n">iter</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> 
</span></span><span class="line"><span class="cl">		<span class="n">iter</span><span class="o">++</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="下标操作">下标操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c[k]</code></td>
<td>返回关键字为<code>k</code>的元素；如果<code>k</code>不在<code>c</code>中，添加一个关键字为<code>k</code>的元素，对其值初始化。</td>
</tr>
<tr>
<td><code>c.at(k)</code></td>
<td>访问关键字为<code>k</code>的元素，带参数检查；若<code>k</code>不存在在<code>c</code>中，抛出一个<code>out_of_range</code>异常。</td>
</tr>
</tbody>
</table>
<ul>
<li>下标和<code>at</code>操作只适用于非<code>const</code>的<code>map</code>和<code>unordered_map</code>，即使访问操作也不行</li>
<li>map的下标操作只能返回非常量引用，如果map本身是常量，则无法使用下标访问元素，只能使用at函数</li>
</ul>
<h3 id="查找元素">查找元素</h3>
<p><strong>在一个关联容器中查找元素</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.find(k)</code></td>
<td>返回一个迭代器，指向第一个关键字为<code>k</code>的元素，若<code>k</code>不在容器中，则返回尾后迭代器</td>
</tr>
<tr>
<td><code>c.count(k)</code></td>
<td>返回关键字等于<code>k</code>的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1。</td>
</tr>
<tr>
<td><code>c.lower_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>大于等于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.upper_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>大于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.equal_range(k)</code></td>
<td>返回一个迭代器<code>pair</code>，表示关键字等于<code>k</code>的元素的范围。若<code>k</code>不存在，<code>pair</code>的两个成员均等于<code>c.end()</code>。</td>
</tr>
</tbody>
</table>
<ul>
<li><code>lower_bound</code>和<code>upper_bound</code>不适用于无序容器。</li>
<li>如果<code>multimap</code>或<code>multiset</code>中有多个元素有相同关键字，则这些元素在容器中会相邻存储</li>
</ul>
<h2 id="114-无序容器">11.4 无序容器</h2>
<ul>
<li>有序容器使用比较运算符来组织元素；无序容器使用哈希函数和关键字类型的<code>==</code>运算符。</li>
<li>无序容器在存储上组织为一组桶(bucket)，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。无序容器首先计算元素的哈希值，找到应该搜索哪个桶（相同哈希值的元素保存到相同的桶中），再搜索桶。
<strong>无序容器管理操作</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>桶接口</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.bucket_count()</code></td>
<td>正在使用的桶的数目</td>
</tr>
<tr>
<td><code>c.max_bucket_count()</code></td>
<td>容器能容纳的最多的桶的数目</td>
</tr>
<tr>
<td><code>c.bucket_size(n)</code></td>
<td>第<code>n</code>个桶中有多少个元素</td>
</tr>
<tr>
<td><code>c.bucket(k)</code></td>
<td>关键字为<code>k</code>的元素在哪个桶中</td>
</tr>
<tr>
<td><strong>桶迭代</strong></td>
<td></td>
</tr>
<tr>
<td><code>local_iterator</code></td>
<td>可以用来访问桶中元素的迭代器类型</td>
</tr>
<tr>
<td><code>const_local_iterator</code></td>
<td>桶迭代器的<code>const</code>版本</td>
</tr>
<tr>
<td><code>c.begin(n)</code>，<code>c.end(n)</code></td>
<td>桶<code>n</code>的首元素迭代器</td>
</tr>
<tr>
<td><code>c.cbegin(n)</code>，<code>c.cend(n)</code></td>
<td>与前两个函数类似，但返回<code>const_local_iterator</code>。</td>
</tr>
<tr>
<td><strong>哈希策略</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.load_factor()</code></td>
<td>每个桶的平均元素数量，返回<code>float</code>值。</td>
</tr>
<tr>
<td><code>c.max_load_factor()</code></td>
<td><code>c</code>试图维护的平均比桶大小，返回<code>float</code>值。<code>c</code>会在需要时添加新的桶，以使得<code>load_factor&lt;=max_load_factor</code></td>
</tr>
<tr>
<td><code>c.rehash(n)</code></td>
<td>重组存储，使得<code>bucket_count&gt;=n</code>，且<code>bucket_count&gt;size/max_load_factor</code></td>
</tr>
<tr>
<td><code>c.reverse(n)</code></td>
<td>重组存储，使得<code>c</code>可以保存<code>n</code>个元素且不必<code>rehash</code>。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch10 泛型算法</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 27 Feb 2024 15:57:36 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</guid>
      <description>第十章 泛型算法 10.1 泛型算法 泛型算法本身不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作 必要的编程假定：算法（注意是标准库中的算法</description>
      <content:encoded><![CDATA[<h1 id="第十章-泛型算法">第十章 泛型算法</h1>
<h2 id="101-泛型算法">10.1 泛型算法</h2>
<ul>
<li>泛型算法本身不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作</li>
<li>必要的编程假定：算法（注意是标准库中的算法）永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但<strong>不能直接添加或者删除元素</strong>。</li>
</ul>
<h2 id="102-初识泛型算法">10.2 初识泛型算法</h2>
<h3 id="只读算法">只读算法</h3>
<ul>
<li>最好使用<code>cbegin</code>和<code>cend</code>。</li>
<li><code>accumulate</code>函数：计算一个序列的和。序列中的元素必须与第三个元素匹配，或者能转换为第三个参数的类型（accumulate函数是模板函数，类型由第三个参数推导而来，此类型决定了使用哪种加法运算符）</li>
<li><code>find</code>函数：接受一对迭代器范围和目标查找值，如果找到，则返回对应的迭代器，否则返回尾后迭代器</li>
<li><code>find_if</code>函数：接受一对迭代器范围和一个谓词，对范围内的每个元素调用给定谓词进行判断，返回第一个使谓词返回非零的元素，否则返回尾后迭代器。</li>
<li><code>find_first_of</code>，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的<code>end</code>迭代器。</li>
<li><code>equal</code>：确定两个序列是否保存相同的值。（顺序也相同）</li>
</ul>
<h3 id="写容器元素的算法">写容器元素的算法</h3>
<ul>
<li>修改算法
<ul>
<li><code>fill</code>： <code>fill(vec.begin(), vec.end(), 0);</code></li>
<li><code>fill_n</code>： <code>fill_n(vec.begin(), len, 0);</code></li>
<li><code>for_each</code>函数：接受一对迭代器和一个谓词，对范围内的每个元素调用谓词</li>
<li><code>transform</code>函数：接受三个迭代器和一个谓词，前两个迭代器指定一个输入序列的范围，第三个迭代器指定目的位置，它对输入序列中的每个元素调用谓词，并将结果写入到目的位置。</li>
</ul>
</li>
<li>拷贝算法
<ul>
<li><code>copy (src.begin(), src.end(), dst.begin());</code>前两个参数指定输入范围，第三个指向目标序列的起始位置。</li>
<li><code>replace(src.begin(), src.end(), old, new)</code>：将范围内old替换为new</li>
<li><code>replace_copy(src.begin(), src.end(), dst.begin(), old, new)</code>：基本同replace，但是保留原范围不变，将替换后的结果保存到dst位置</li>
<li>很多算法都提供copy版本，不会将新元素放回原序列，而是将结果保存到新序列中</li>
</ul>
</li>
<li>
<h3 id="重排容器元素的算法">重排容器元素的算法</h3>
</li>
<li>排序算法<code>sort</code>：接受两个迭代器，利用元素的<code>&lt;</code>运算符重排元素</li>
<li><code>stable_sort</code></li>
<li>消除重复<code>unique</code>：之前要先调用<code>sort</code>，返回的迭代器指向最后一个不重复元素之后的位置（最后一个不重复元素的尾后位置）；重复的元素在原来容器的后边，并没有真正删除。</li>
</ul>
<h2 id="103-定制操作">10.3 定制操作</h2>
<h3 id="向算法传递函数">向算法传递函数</h3>
<ul>
<li><a href="https://blog.csdn.net/caroline_wendy/article/details/15378055">谓词</a>（<code>predicate</code>）：是一个<strong>可调用的表达式</strong>，返回结果是一个能用作条件的值</li>
<li>接受谓词参数的算法会对输入序列中的元素调用谓词，因此序列的元素类型必须能转换为谓词的参数类型</li>
<li>可以向算法传递四种可调用对象：函数、函数指针、重载了函数调用运算符的类、lambda表达式</li>
</ul>
<h3 id="lambda表达式">lambda表达式</h3>
<ul>
<li>形式：<code>[capture list](parameter list) -&gt; return type {function body}</code>。
<ul>
<li><code>capture list</code>捕获列表是一个由<code>lambda</code>所在函数定义的局部变量的列表（通常为空）。不可忽略。捕获列表只能用于局部非static变量，lambda表达式可以直接使用局部static变量和所在函数之外声明的名字。</li>
<li><code>return type</code>是返回类型。可忽略（省略返回类型时，可以由return返回表达式的类型推断而来，否则返回类型为void），必须使用尾置返回。</li>
<li><code>parameter</code>是参数列表。可忽略（等价于指定空参数列表），不能有默认实参。</li>
<li><code>function body</code>是函数体。不可忽略。</li>
</ul>
</li>
<li>定义一个lambda表达式时，编译器生成一个与lambda对应的未命名的类类型
<ul>
<li>当向函数传递一个lambda时，传递的参数实际上就是这个未命名类的对象。</li>
<li>[[ch14-重载运算与类型转换#<code>lambda</code>是函数对象|lambda是函数对象]]</li>
</ul>
</li>
</ul>
<h3 id="lambda捕获和返回">lambda捕获和返回</h3>
<ul>
<li>捕获：lambda表达式将局部变量包含在捕获列表中，在捕获列表中的参数可以被lambda函数体所使用，<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=882c973c-544f-77c6-5d3d-ae7c1ecb678a&amp;page=378&amp;rect=238.800,400.080,306.010,407.280">lambda 捕获列表</a>
<ul>
<li>值捕获：被值捕获的变量的值是在lambda创建时拷贝，而非调用时拷贝。因此在lambda创建后改变被捕获的变量不会影响lambda中对应的值。</li>
<li>引用捕获：捕获的变量前加<code>&amp;</code>，此时修改局部变量会影响lambda内对应的值，但是必须确保被引用的对象在 lambda 执行时是存在的。</li>
</ul>
</li>
<li>隐式捕获：不显式列出捕获变量，而是编译器进行推断
<ul>
<li><code>&amp;</code>为引用捕获，<code>=</code>为值捕获</li>
</ul>
</li>
<li>混合显式捕获与隐式捕获
<ul>
<li>此时捕获列表第一个元素必须是<code>&amp;</code>或<code>=</code>，指定默认捕获方式，显式捕获的变量必须使用与隐式捕获不同的方式</li>
</ul>
</li>
<li>可变lambda：默认情况下，通过值捕获得到的变量（的拷贝），lambda无法修改其值，如果希望改变，可以在参数列表后加上<code>mutable</code>
<ul>
<li>通过引用捕获的变量，取决于变量是否为const</li>
</ul>
</li>
<li>如果lambda中除了return还有其他语句，此时应该指明返回类型；否则可以省略返回类型</li>
<li>lambda可以作为函数的返回值，此时lambda不能包含引用捕获。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span><span class="n">b</span><span class="o">+=</span><span class="n">c</span><span class="p">;</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;};</span> <span class="c1">// 隐式的值捕获(a),显式的引用捕获(b)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span><span class="n">a</span><span class="o">+=</span><span class="n">c</span><span class="p">;};</span> <span class="c1">// 隐式的引用捕获(a),显式的值捕获(b)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">gg</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span><span class="n">b</span><span class="o">+=</span><span class="n">c</span><span class="p">;</span> <span class="n">a</span><span class="o">+=</span><span class="n">c</span><span class="p">;</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">ff</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span><span class="n">b</span><span class="o">+=</span><span class="n">c</span><span class="p">;</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="参数绑定">参数绑定</h3>
<ul>
<li>例子：找到vector中第一个大于val的元素，即需要将二元谓词包装成一元谓词，可以使用bind绑定第二个参数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isBigger</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">isBigger</span><span class="p">);</span> <span class="c1">// 错误，find_if只能接受一元谓词，但是isBigger是二元谓词，可以使用bind进行参数绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bind</span><span class="p">(</span><span class="n">isBigger</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">val</span><span class="p">;};</span> <span class="c1">// 可以使用lambda表达式
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>标准库<code>bind</code>函数：<code>auto newCallable = bind(callable, arg_list);</code>
<ul>
<li>定义在头文件<code>functional</code>中，接受一个可调用对象和一些实参，生成一个新的可调用对象</li>
<li>我们在调用<code>newCallable</code>的时候，<code>newCallable</code>会调用<code>callable</code>并传递给它<code>arg_list</code>中的参数（将绑定的参数拷贝过去）。</li>
</ul>
</li>
<li>参数绑定和重排：<code>std::placeholder::_n</code>表示将<code>newCallable</code>的第n个参数放在占位符<code>_n</code>的位置</li>
<li>绑定引用参数：
<ul>
<li><code>ref</code>函数接受一个参数，返回一个可以拷贝的对象，该对象含有参数的引用。</li>
<li><code>cref</code>返回const的引用</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">show</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">d</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">e</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">out</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span><span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">d</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">e</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">show</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span> <span class="c1">// 将g的第一个参数放到placeholders::_1的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">show</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">);</span> <span class="c1">// 重排参数顺序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">g</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// 将e放到placeholders::_1的位置，将c放到placeholders::_2的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">h</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// show(a, b, _1, d, _2), 其中_1是e，_2是c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span> <span class="o">=</span> <span class="n">cout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">os</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span> <span class="c1">// 绑定引用参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>    
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="104-再探迭代器">10.4 再探迭代器</h2>
<h3 id="插入迭代器">插入迭代器</h3>
<ul>
<li>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素，定义在头文件iterator中
<ul>
<li><code>back_inserter</code>：创建一个调用<code>push_back</code>操作的迭代器。
<ul>
<li><code>back_inserter</code>是插入器，<code>back_insert_iterator&lt;vector&lt;int&gt;&gt;</code>是插入迭代器类型</li>
</ul>
</li>
<li><code>front_inserter</code>创建一个调用<code>push_front</code>操作的迭代器。</li>
<li><code>inserter</code>创建一个调用<code>insert</code>操作的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被插入到迭代器所指向的元素之前。
<ul>
<li>随着插入过程，inserter永远指向指定的元素，而不是永远指向某个特定的位置</li>
</ul>
</li>
</ul>
</li>
<li>每向插入器赋值一次就相当于调用一次相关操作，<code>*it, ++it, it++</code>等操作虽然存在，但不会有任何作用（仍返回it）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">back_insert_iterator</span><span class="o">&lt;</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">biter</span> <span class="o">=</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// 相当于永远指向尾后位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">front_insert_iterator</span><span class="o">&lt;</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">fiter</span> <span class="o">=</span> <span class="n">front_inserter</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 每赋值一次就相当于调用一次相关操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">biter</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">biter</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">fiter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">fiter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;});</span>  
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="流迭代器">流迭代器</h3>
<ul>
<li>流迭代器将对应的流当作一个特定类型的元素序列来处理
<ul>
<li><code>istream_iterator</code>：读取输入流
<ul>
<li>可以不绑定到流，相当于尾后迭代器</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=636cee62-4cbc-5f60-573a-a6e6aeb138c7&amp;page=386&amp;rect=230.650,377.520,312.490,384.480">istream_iterator 操作</a>：没有赋值操作，解引用操作相当于返回输入流中读取的值，需要递增操作</li>
<li><code>istream_iterator</code>允许使用懒惰求值，即标准库不保证迭代器可以立即从输入流中获取数据，但是保证迭代器第一次解引用操作之前，从流中读取数据的操作已经完成。</li>
</ul>
</li>
<li><code>ostream_iterator</code>：向输出流中写入数据
<ul>
<li><code>ostream_iterator</code>必须绑定到一个指定的流，不允许空的或者尾后位置</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=eccda81b-26b3-f633-d17a-d366513c237b&amp;page=387&amp;rect=216.870,462.809,302.170,472.183">ostream_iterator 操作</a>：赋值操作相当于输出流的输出操作，递增、解引用操作没有意义</li>
<li>向ostream_iterator赋值时，可以省略解引用和递增运算（实际上解引用和递增操作不会对ostream_iterator做任何事情）。但是不推荐省略，可以保持迭代器行为的一致性，便于修改。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_iter</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span> <span class="c1">// 可以将流迭代器绑定到一个流（输入流读取操作 就相当于 从流迭代器中取出值，流迭代器累加），
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_eof</span><span class="p">;</span> <span class="c1">// 默认初始化相当于尾后迭代器或eof
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">out_iter</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">);</span> <span class="c1">// 必须将ostream_iterator绑定到一个指定的流, 每个值后面跟着一个C风格字符串str
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 原始方式，注意输入时Ctrl+Z表示eof
</span></span></span><span class="line"><span class="cl"><span class="c1">// vector&lt;int&gt; v;
</span></span></span><span class="line"><span class="cl"><span class="c1">// for(; int_iter != int_eof; ++int_iter){
</span></span></span><span class="line"><span class="cl"><span class="c1">//     v.push_back(*int_iter);
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">int_iter</span><span class="p">,</span> <span class="n">int_eof</span><span class="p">);</span> <span class="c1">// 等价方式，更能体现流迭代器的特点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// for(int i: v){
</span></span></span><span class="line"><span class="cl"><span class="c1">//     *(out_iter++) = i; // 原始方式（先后置递增，返回旧值，再解引用），但是更推荐
</span></span></span><span class="line"><span class="cl"><span class="c1">//     // out_iter = i; // 等价方式，更简略
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">out_iter</span><span class="p">);</span> <span class="c1">// 最简单的写法，将序列范围直接复制到输出迭代器中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// copy(int_iter, int_eof, out_iter); // 直接将输入进行输出  
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="反向迭代器">反向迭代器</h3>
<ul>
<li>递增会移动到前一个元素</li>
<li>调用反向迭代器的base函数可以获得其对应的正向迭代器
<ul>
<li>rbegin()指向的是最后一个元素，而end()指向的是尾后元素；对应的，【反向迭代器】与【其调用base函数得到的正向迭代器】的关系类似于rbegin()与end()，指向的不是相同元素。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=e161d353-c64d-530c-5ed0-8bbc3f7bbdd0&amp;page=389&amp;rect=76.800,427.920,341.280,435.600">图示</a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="n">riter</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="c1">// 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="c1">// 尾后位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">riter</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="p">(</span><span class="o">--</span><span class="n">iter</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 5 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="p">(</span><span class="o">++</span><span class="n">riter</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">riter</span><span class="p">.</span><span class="n">base</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 4 5  
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="移动迭代器">移动迭代器</h3>
<h2 id="105-泛型算法结构">10.5 泛型算法结构</h2>
<h3 id="5类迭代器">5类迭代器</h3>
<ul>
<li>算法所要求的迭代器操作可以分为 5 类，C++ 标准指明了泛型算法的每个迭代器参数的最小类别。</li>
<li><code>vector&lt;int&gt;::iterator</code>迭代器是随机访问迭代器，<code>list&lt;int&gt;::iteraotr</code>迭代器是双向迭代器</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">迭代器类别</th>
<th style="text-align:center">解释</th>
<th style="text-align:center">支持的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">输入迭代器</td>
<td style="text-align:center">只读，不写；单遍扫描，只能递增</td>
<td style="text-align:center"><code>==</code>,<code>!=</code>,<code>++</code>,<code>*</code>,<code>-&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">输出迭代器</td>
<td style="text-align:center">只写，不读；单遍扫描，只能递增</td>
<td style="text-align:center"><code>++</code>,<code>*</code></td>
</tr>
<tr>
<td style="text-align:center">前向迭代器</td>
<td style="text-align:center">可读写；多遍扫描，只能递增</td>
<td style="text-align:center"><code>==</code>,<code>!=</code>,<code>++</code>,<code>*</code>,<code>-&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">双向迭代器</td>
<td style="text-align:center">可读写；多遍扫描，可递增递减</td>
<td style="text-align:center"><code>==</code>,<code>!=</code>,<code>++</code>,<code>--</code>,<code>*</code>,<code>-&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">随机访问迭代器</td>
<td style="text-align:center">可读写，多遍扫描，支持全部迭代器运算</td>
<td style="text-align:center"><code>==</code>,<code>!=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code>,<code>++</code>,<code>--</code>,<code>+</code>,<code>+=</code>,<code>-</code>,<code>-=</code>,<code>*</code>,<code>-&gt;</code>,<code>iter[n]</code>==<code>*(iter[n])</code></td>
</tr>
</tbody>
</table>
<h3 id="算法的形参模式">算法的形参模式</h3>
<ul>
<li><code>alg(beg, end, other args);</code></li>
<li><code>alg(beg, end, dest, other args);</code></li>
<li><code>alg(beg, end, beg2, other args);</code></li>
<li><code>alg(beg, end, beg2, end2, other args);</code>
其中，<code>alg</code>是算法名称，<code>beg</code>和<code>end</code>表示算法所操作的输入范围。<code>dest</code>表示输出范围或输出流迭代器，<code>beg2</code>、<code>end2</code>表示第二个输入范围</li>
</ul>
<h3 id="算法命名规范">算法命名规范</h3>
<ul>
<li>一些算法使用重载形式传递一个谓词，来代替<code>&lt;</code>或<code>==</code>，比如sort</li>
<li>接受谓词参数的算法都有附加的<code>_if</code>后缀，没有的一般都是接受元素值</li>
<li>将执行结果写入额外目的空间的算法都有<code>_copy</code>后缀（即拷贝版本）</li>
</ul>
<h2 id="106-特定容器算法">10.6 特定容器算法</h2>
<ul>
<li>对于<code>list</code>和<code>forward_list</code>，优先使用【成员函数版本的算法】而不是通用算法。</li>
<li>list和forward_list成员函数版本的算法：</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lst.merge(lst2)</code></td>
<td>将来自<code>lst2</code>的元素合并入<code>lst</code>，二者都必须是有序的，元素将从<code>lst2</code>中删除。</td>
</tr>
<tr>
<td><code>lst.merge(lst2, comp)</code></td>
<td>同上，给定比较操作。</td>
</tr>
<tr>
<td><code>lst.remove(val)</code></td>
<td>调用<code>erase</code>删除掉与给定值相等(<code>==</code>)的每个元素</td>
</tr>
<tr>
<td><code>lst.remove_if(pred)</code></td>
<td>调用<code>erase</code>删除掉令一元谓词为真的每个元素</td>
</tr>
<tr>
<td><code>lst.reverse()</code></td>
<td>反转<code>lst</code>中元素的顺序</td>
</tr>
<tr>
<td><code>lst.sort()</code></td>
<td>使用<code>&lt;</code>排序元素</td>
</tr>
<tr>
<td><code>lst.sort(comp)</code></td>
<td>使用给定比较操作排序元素</td>
</tr>
<tr>
<td><code>lst.unique()</code></td>
<td>调用<code>erase</code>删除同一个值的连续拷贝。使用<code>==</code>。</td>
</tr>
<tr>
<td><code>lst.unique(pred)</code></td>
<td>调用<code>erase</code>删除同一个值的连续拷贝。使用给定的二元谓词。</td>
</tr>
</tbody>
</table>
<ul>
<li>上面的操作都返回<code>void</code></li>
<li>链表特有版本的算法操作会改变底层容器
<ul>
<li>list和forward_list的splice函数可以进行容器合并，使用<code>lst.splice(args)</code>或<code>flst.splice_after(args)</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(p, lst2)</code></td>
<td><code>p</code>是一个指向<code>lst</code>中元素的迭代器，或者一个指向<code>flst</code>首前位置的迭代器。函数将<code>lst2</code>中的所有元素移动到<code>lst</code>中<code>p</code>之前的位置或是<code>flst</code>中<code>p</code>之后的位置。将元素从<code>lst2</code>中删除。<code>lst2</code>的类型必须和<code>lst</code>相同，而且不能是同一个链表。</td>
</tr>
<tr>
<td><code>(p, lst2, p2)</code></td>
<td>同上，<code>p2</code>是一个指向<code>lst2</code>中位置的有效的迭代器，将<code>p2</code>指向的元素移动到<code>lst</code>中，或将<code>p2</code>之后的元素移动到<code>flst</code>中。<code>lst2</code>可以是与<code>lst</code>或<code>flst</code>相同的链表。</td>
</tr>
<tr>
<td><code>(p, lst2, b, e)</code></td>
<td><code>b</code>和<code>e</code>表示<code>lst2</code>中的合法范围。将给定范围中的元素从<code>lst2</code>移动到<code>lst</code>或<code>first</code>中。<code>lst2</code>与<code>lst</code>可以使相同的链表，但<code>p</code>不能指向给定范围中的元素。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch09 顺序容器</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 27 Feb 2024 15:57:27 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</guid>
      <description>第九章 顺序容器 9.1 顺序容器概述 顺序容器（sequential container）：元素顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</description>
      <content:encoded><![CDATA[<h1 id="第九章-顺序容器">第九章 顺序容器</h1>
<h2 id="91-顺序容器概述">9.1 顺序容器概述</h2>
<ul>
<li><strong>顺序容器</strong>（sequential container）：元素顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</li>
</ul>
<h3 id="顺序容器类型">顺序容器类型</h3>
<table>
<thead>
<tr>
<th>容器类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vector</code></td>
<td>随机访问，尾部插入/删除快</td>
</tr>
<tr>
<td><code>deque</code></td>
<td>随机访问，头尾插入/删除快</td>
</tr>
<tr>
<td><code>list</code></td>
<td>双向链表。只支持双向顺序访问，任何位置插入/删除都快</td>
</tr>
<tr>
<td><code>forward_list</code></td>
<td>单向链表。只支持单向顺序访问。任何位置插入/删除都快</td>
</tr>
<tr>
<td><code>array</code></td>
<td>固定大小数组，随机访问。不能添加或者删除元素。</td>
</tr>
<tr>
<td><code>string</code></td>
<td>随机访问，尾部插入/删除速度快。</td>
</tr>
</tbody>
</table>
<ul>
<li>list 的额外内存开销相比其他大很多。</li>
<li>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。
<ul>
<li>如果不需要向中间插入数据，则先向vector中添加，再sort</li>
<li>如果一定要向中间插入数据，则先使用list，输入完成后再拷贝到vector中</li>
</ul>
</li>
</ul>
<h2 id="92-容器库概览">9.2 容器库概览</h2>
<h3 id="类型">类型</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iterator</code></td>
<td>此容器类型的迭代器类型</td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td>可以读取元素但不能修改元素的迭代器类型</td>
</tr>
<tr>
<td><code>size_type</code></td>
<td>无符号整数类型，足够保存此种容器类型最大可能的大小</td>
</tr>
<tr>
<td><code>difference_type</code></td>
<td>带符号整数类型，足够保存两个迭代器之间的距离</td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>元素类型</td>
</tr>
<tr>
<td><code>reference</code></td>
<td>元素的左值类型；和<code>value_type &amp;</code>含义相同</td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td>元素的<code>const</code>左值类型，即<code>const value_type &amp;</code></td>
</tr>
</tbody>
</table>
<ul>
<li>迭代器范围begin和end，其中end是指向尾后地址，左闭右开</li>
<li>当不需要修改时，尽量使用const iterator</li>
</ul>
<h3 id="构造函数">构造函数</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C c;</code></td>
<td>默认构造函数，构造空容器</td>
</tr>
<tr>
<td><code>C c1(c2);</code>或<code>C c1 = c2;</code></td>
<td>构造<code>c2</code>的拷贝<code>c1</code></td>
</tr>
<tr>
<td><code>C c(b, e)</code></td>
<td>构造<code>c</code>，将<strong>迭代器</strong><code>b</code>和<code>e</code>指定范围内的所有元素拷贝到<code>c</code></td>
</tr>
<tr>
<td><code>C c{a, b, c...}</code></td>
<td>列表初始化<code>c</code></td>
</tr>
<tr>
<td><code>C c(n)</code></td>
<td>只支持顺序容器，且不包括<code>array</code>，包含<code>n</code>个元素，这些元素进行了值初始化</td>
</tr>
<tr>
<td><code>C c(n, t)</code></td>
<td>包含<code>n</code>个初始值为<code>t</code>的元素</td>
</tr>
</tbody>
</table>
<ul>
<li>三种构造方式：
<ul>
<li>直接拷贝：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。</li>
<li>迭代器范围构造：不要求容器类型相同，容器内的元素类型也可以不同，但是要能进行类型转换</li>
<li>列表初始化</li>
</ul>
</li>
<li>array初始化
<ul>
<li>定义array需要同时指定元素类型和大小，默认初始化为0</li>
<li>array只能默认初始化或列表初始化，如果定义的数组很大并且需要初始化，可以先默认初始化然后用 fill 函数填充值。</li>
</ul>
</li>
</ul>
<h3 id="赋值和swap">赋值和<code>swap</code></h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c1 = c2;</code></td>
<td>将<code>c1</code>中的元素替换成<code>c2</code>中的元素</td>
</tr>
<tr>
<td><code>c1 = {a, b, c...}</code></td>
<td>将<code>c1</code>中的元素替换成列表中的元素（不适用于<code>array</code>）</td>
</tr>
<tr>
<td><code>c1.swap(c2)</code></td>
<td>交换<code>c1</code>和<code>c2</code>的元素</td>
</tr>
<tr>
<td><code>swap(c1, c2)</code></td>
<td>等价于<code>c1.swap(c2)</code></td>
</tr>
<tr>
<td><code>c.assign(b, e)</code></td>
<td>将<code>c</code>中的元素替换成迭代器<code>b</code>和<code>e</code>表示范围中的元素，<code>b</code>和<code>e</code>不能指向<code>c</code>中的元素，可以用不同但相容的类型赋值，或者用容器的子序列赋值</td>
</tr>
<tr>
<td><code>c.assign(il)</code></td>
<td>将<code>c</code>中的元素替换成初始化列表<code>il</code>中的元素</td>
</tr>
<tr>
<td><code>c.assign(n, r)</code></td>
<td>将<code>c</code>中的元素替换为<code>n</code>个值是<code>t</code>的元素</td>
</tr>
</tbody>
</table>
<ul>
<li>swap：
<ul>
<li>对于array，swap会真正交换它们的元素；对于其他元素，swap不交换元素，只交换数据结构，因此很快</li>
<li>对于 string，swap 后，指针、引用和迭代器会失效。对于其他容器，交换后指针指向了另一个容器的相同位置。</li>
<li>建议统一使用<code>swap(a,b)</code></li>
</ul>
</li>
<li>assign赋值：
<ul>
<li><code>assign</code>操作不适用于关联容器和<code>array</code></li>
<li><code>=</code>赋值要求两边类型相同，assign只要求可以转换即可</li>
</ul>
</li>
<li>array赋值：
<ul>
<li>不能对内置数组拷贝或赋值，但是 array 可以。</li>
<li>使用一个 array 对另一个 array 赋值，需要两个array 元素类型与大小都相同。</li>
<li>不能用花括号列表对 array 赋值（只可以初始化）</li>
</ul>
</li>
</ul>
<h3 id="大小">大小</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.size()</code></td>
<td><code>c</code>中元素的数目（不支持<code>forward_list</code>）</td>
</tr>
<tr>
<td><code>c.max_size()</code></td>
<td><code>c</code>中可保存的最大元素数目</td>
</tr>
<tr>
<td><code>c.empty()</code></td>
<td>若<code>c</code>中存储了元素，返回<code>false</code>，否则返回<code>true</code></td>
</tr>
</tbody>
</table>
<ul>
<li>forward_list支持max_size和empty，但是不支持size</li>
</ul>
<h2 id="93-顺序容器操作">9.3 顺序容器操作</h2>
<h3 id="添加元素">添加元素</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.push_back(t)</code></td>
<td>在<code>c</code>尾部创建一个值为<code>t</code>的元素，返回<code>void</code></td>
</tr>
<tr>
<td><code>c.emplace_back(args)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>c.push_front(t)</code></td>
<td>在<code>c</code>头部创建一个值为<code>t</code>的元素，返回<code>void</code></td>
</tr>
<tr>
<td><code>c.emplace_front(args)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>c.insert(p, t)</code></td>
<td>在迭代器<code>p</code>指向的元素之前创建一个值是<code>t</code>的元素，返回指向新元素的迭代器</td>
</tr>
<tr>
<td><code>c.emplace(p, args)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>c.insert(p, n, t)</code></td>
<td>在迭代器<code>p</code>指向的元素之前插入<code>n</code>个值为<code>t</code>的元素，返回指向第一个新元素的迭代器</td>
</tr>
<tr>
<td><code>c.insert(p, b, e)</code></td>
<td>将迭代器<code>b</code>和<code>e</code>范围内的元素，插入到<code>p</code>指向的元素之前</td>
</tr>
<tr>
<td><code>c.insert(p, il)</code></td>
<td><code>il</code>是一个花括号包围中的元素值列表，将其插入到<code>p</code>指向的元素之前</td>
</tr>
</tbody>
</table>
<ul>
<li>向vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。</li>
<li>头尾添加返回void，中间添加返回指向新添加元素的迭代器</li>
<li>push和insert传递的是元素类型的对象，emplace则将参数传递给元素类型的构造对象
<ul>
<li>传递给emplace的参数必须和元素类型的构造函数相匹配。</li>
</ul>
</li>
<li>insert 返回值是指向添加的元素中第一个元素的迭代器</li>
<li>添加的都是元素的拷贝，不是元素本身。</li>
</ul>
<h3 id="访问元素">访问元素</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.back()</code></td>
<td>返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><code>c.front()</code></td>
<td>返回<code>c</code>中头元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><code>c[n]</code></td>
<td>返回<code>c</code>中下标是<code>n</code>的元素的引用，<code>n</code>时候一个无符号整数。若<code>n&gt;=c.size()</code>，则函数行为未定义</td>
</tr>
<tr>
<td><code>c.at(n)</code></td>
<td>返回下标为<code>n</code>的元素引用。如果下标越界，则抛出<code>out_of_range</code>异常</td>
</tr>
</tbody>
</table>
<ul>
<li>访问成员函数返回的是引用。</li>
</ul>
<h3 id="删除元素">删除元素</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.pop_back()</code></td>
<td>删除<code>c</code>中尾元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td>
</tr>
<tr>
<td><code>c.pop_front()</code></td>
<td>删除<code>c</code>中首元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td>
</tr>
<tr>
<td><code>c.erase(p)</code></td>
<td>删除迭代器<code>p</code>指向的元素，返回一个指向被删除元素之后的元素的迭代器，若<code>p</code>本身是尾后迭代器，则函数行为未定义</td>
</tr>
<tr>
<td><code>c.erase(b, e)</code></td>
<td>删除迭代器<code>[b,e)</code>内的元素，返回指向最后一个被删元素之后元素的迭代器，若<code>e</code>本身就是尾后迭代器，则返回尾后迭代器</td>
</tr>
<tr>
<td><code>c.clear()</code></td>
<td>删除<code>c</code>中所有元素，返回<code>void</code></td>
</tr>
</tbody>
</table>
<ul>
<li>头尾删除返回void，特定位置删除，返回被删除元素之后元素的迭代器</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=dd002dda-960e-9445-3aa0-2abd00fd6c03&amp;page=341&amp;rect=98.640,543.263,241.920,556.097">添加、删除操作可能使迭代器失效</a></li>
</ul>
<h3 id="特殊的forward_list操作">特殊的forward_list操作</h3>
<ul>
<li>forward_list 是单向链表，添加和删除操作都会同时改变前驱和后继结点</li>
<li><code>forward_list</code>定义了<code>before_begin()</code>，即【首前（off-the-beginning）迭代器】，允许我们再在首元素之前添加或删除元素。</li>
<li>前面的insert都是在当前元素之前插入，insert_after插入到当前元素之后</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lst.before_begin()</code></td>
<td>返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。</td>
</tr>
<tr>
<td><code>lst.cbefore_begin()</code></td>
<td>同上，但是返回的是常量迭代器。</td>
</tr>
<tr>
<td><code>lst.insert_after(p, t)</code></td>
<td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象</td>
</tr>
<tr>
<td><code>lst.insert_after(p, n, t)</code></td>
<td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象，<code>n</code>是数量。若<code>n</code>是0则函数行为未定义</td>
</tr>
<tr>
<td><code>lst.insert_after(p, b, e)</code></td>
<td>在迭代器<code>p</code>之后插入元素。由迭代器<code>b</code>和<code>e</code>指定范围。</td>
</tr>
<tr>
<td><code>lst.insert_after(p, il)</code></td>
<td>在迭代器<code>p</code>之后插入元素。由<code>il</code>指定初始化列表。</td>
</tr>
<tr>
<td><code>lst.emplace_after(p, args)</code></td>
<td>使用<code>args</code>在<code>p</code>之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若<code>p</code>为尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td><code>lst.erase_after(p)</code></td>
<td>删除<code>p</code>指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若<code>p</code>指向<code>lst</code>的尾元素或者是一个尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td><code>lst.erase_after(b, e)</code></td>
<td>类似上面，删除对象换成从<code>(b,e)</code>指定的范围。</td>
</tr>
</tbody>
</table>
<h3 id="改变容器大小">改变容器大小</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.resize(n)</code></td>
<td>调整<code>c</code>的大小为<code>n</code>个元素，若<code>n&lt;c.size()</code>，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</td>
</tr>
<tr>
<td><code>c.resize(n, t)</code></td>
<td>调整<code>c</code>的大小为<code>n</code>个元素，任何新添加的元素都初始化为值<code>t</code></td>
</tr>
</tbody>
</table>
<h3 id="迭代器">迭代器</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.begin()</code>, <code>c.end()</code></td>
<td>返回指向<code>c</code>的首元素和尾元素之后位置的迭代器</td>
</tr>
<tr>
<td><code>c.cbegin()</code>, <code>c.cend()</code></td>
<td>返回<code>const_iterator</code></td>
</tr>
<tr>
<td><code>c.rbegin()</code>, <code>c.rend()</code></td>
<td>返回指向<code>c</code>的尾元素和首元素之前位置的迭代器</td>
</tr>
<tr>
<td><code>c.crbegin()</code>, <code>c.crend()</code></td>
<td>返回<code>const_reverse_iterator</code></td>
</tr>
</tbody>
</table>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=dd002dda-960e-9445-3aa0-2abd00fd6c03&amp;page=341&amp;rect=98.640,543.263,241.920,556.097">添加、删除操作可能使迭代器失效</a>
<ul>
<li>在向容器添加元素后：
<ul>
<li>如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。</li>
<li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。</li>
<li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器、指针和引用依然有效。</li>
</ul>
</li>
<li>在从一个容器中删除元素后：尾后迭代器总是会失效
<ul>
<li>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器、引用和指针仍然有效。</li>
<li>对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除<code>deque</code>的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是<code>deque</code>的头元素，这些也不会受影响。</li>
<li>对于<code>vector</code>和<code>string</code>，指向被删元素之前的迭代器、引用、指针仍然有效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="94-vector对象是如何增长的">9.4 vector对象是如何增长的</h2>
<p><code>vector</code>和<code>string</code>在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。</p>
<h3 id="管理容量的成员函数">管理容量的成员函数</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.shrink_to_fit()</code></td>
<td>将<code>capacity()</code>减少到和<code>size()</code>相同大小</td>
</tr>
<tr>
<td><code>c.capacity()</code></td>
<td>不重新分配内存空间的话，<code>c</code>可以保存多少个元素</td>
</tr>
<tr>
<td><code>c.reverse(n)</code></td>
<td>分配至少能容纳<code>n</code>个元素的内存空间(预分配，而且如果需求容量小于当前容量，什么都不做)</td>
</tr>
</tbody>
</table>
<ul>
<li><code>shrink_to_fit</code>只适用于<code>vector</code>、<code>string</code>和<code>deque</code></li>
<li><code>capacity</code>和<code>reverse</code>只适用于<code>vector</code>和<code>string</code>。</li>
</ul>
<h2 id="95-额外的string操作">9.5 额外的string操作</h2>
<h3 id="构造string的其他方法">构造string的其他方法</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string s(cp, n)</code></td>
<td><code>s</code>是<code>cp</code>指向的数组中前<code>n</code>个字符的拷贝，此数组至少有n个字符</td>
</tr>
<tr>
<td><code>string s(s2, pos2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符到末尾的拷贝。若<code>pos2 &gt; s2.size()</code>，则构造函数的行为未定义。</td>
</tr>
<tr>
<td><code>string s(s2, pos2, len2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的<code>len2</code>个字符的拷贝。</td>
</tr>
</tbody>
</table>
<ul>
<li>最初的构造函数：直接初始化（圆括号初始化）、迭代器范围初始化、列表初始化</li>
</ul>
<h3 id="substr操作">substr操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.substr(pos, n)</code></td>
<td>返回一个<code>string</code>，包含<code>s</code>中从<code>pos</code>开始的<code>n</code>个字符的拷贝。</td>
</tr>
</tbody>
</table>
<h3 id="改变string的其他方法">改变string的其他方法</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.insert(pos, args)</code></td>
<td>在<code>pos</code>之前插入<code>args</code>指定的字符。<code>pos</code>可以使是下标或者迭代器。接受下标的版本返回指向<code>s</code>的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td>
</tr>
<tr>
<td><code>s.erase(pos, len)</code></td>
<td>删除从<code>pos</code>开始的<code>len</code>个字符，如果<code>len</code>被省略，则删除后面所有字符，返回指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.assign(args)</code></td>
<td>将<code>s</code>中的字符替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。（args不变）</td>
</tr>
<tr>
<td><code>s.append(args)</code></td>
<td>将<code>args</code>指定的字符追加到<code>s</code>，返回一个指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.replace(range, args)</code></td>
<td>删除<code>s</code>中范围<code>range</code>中的字符，替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td>
</tr>
</tbody>
</table>
<h3 id="string搜索操作">string搜索操作</h3>
<ul>
<li><code>string</code>类提供了6个不同的搜索函数，每个函数都有4个重载版本。</li>
<li>每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。如果搜索失败则返回一个名为<code>string::npos</code>的<code>static</code>成员（类型是<code>string::size_type</code>，初始化值是-1，也就是<code>string</code>最大的可能大小）。</li>
</ul>
<table>
<thead>
<tr>
<th>搜索操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.find(args)</code></td>
<td>查找<code>s</code>中<code>args</code>第一次出现的位置</td>
</tr>
<tr>
<td><code>s.rfind(args)</code></td>
<td>查找<code>s</code>中<code>args</code>最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_of(args)</code></td>
<td>在<code>s</code>中查找<code>args</code>中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_last_of(args)</code></td>
<td>在<code>s</code>中查找<code>args</code>中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>在<code>s</code>中查找第一个不在<code>args</code>中的字符</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>在<code>s</code>中查找最后一个不在<code>args</code>中的字符</td>
</tr>
</tbody>
</table>
<p>args必须是一下的形式之一：</p>
<table>
<thead>
<tr>
<th><code>args</code>形式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c, pos</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找字符<code>c</code>。<code>pos</code>默认是0</td>
</tr>
<tr>
<td><code>s2, pos</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找字符串<code>s2</code>。<code>pos</code>默认是0</td>
</tr>
<tr>
<td><code>cp, pos</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的以空字符结尾的C风格字符串。<code>pos</code>默认是0</td>
</tr>
<tr>
<td><code>cp, pos, n</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的前<code>n</code>个字符。<code>pos</code>和<code>n</code>无默认值。</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 使用pos循环查找所有str包含的字符的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">((</span><span class="n">pos</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span> <span class="o">!=</span> <span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">pos</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">++</span><span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="scompare的几种参数形式">s.compare的几种参数形式</h3>
<p>逻辑类似于C标准库的<code>strcmp</code>函数，根据<code>s</code>是等于、大于还是小于参数指定的字符串，<code>s.compare</code>返回0、正数或负数。</p>
<table>
<thead>
<tr>
<th>参数形式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s2</code></td>
<td>比较<code>s</code>和<code>s2</code></td>
</tr>
<tr>
<td><code>pos1, n1, s2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td>
</tr>
<tr>
<td><code>pos1, n1, s2, pos2, n2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code>从pos2开始的n2个字符</td>
</tr>
<tr>
<td><code>cp</code></td>
<td>比较<code>s</code>和<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td><code>pos1, n1, cp</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td><code>pos1, n1, cp, n2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的地址开始<code>n2</code>个字符</td>
</tr>
</tbody>
</table>
<h3 id="string和数值转换">string和数值转换</h3>
<table>
<thead>
<tr>
<th>转换</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>to_string(val)</code></td>
<td>一组重载函数，返回数值<code>val</code>的<code>string</code>表示</td>
</tr>
<tr>
<td><code>stoi(s, p, b)</code></td>
<td>返回<code>s</code>起始子串（表示整数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0，<code>b</code>是转换所用的基数。返回<code>int</code></td>
</tr>
</tbody>
</table>
<h2 id="96-容器适配器adapter">9.6 容器适配器（adapter）</h2>
<ul>
<li><strong>适配器</strong>是使一事物的行为看起来像另一事物的行为的一种机制，例如<code>stack</code>可以使任何一种顺序容器以栈的方式工作。</li>
<li>默认情况下，stack和queue是基于deque实现的，priority_queue是基于vector实现的，基础容器不能是array和forward_list
<ul>
<li>因此可以直接使用一个deque来初始化stack和queue，使用一个有序vector初始化priority_queue</li>
<li>也可以指定实现的顺序容器： <code>stack&lt;string, vector&lt;string&gt; &gt; str_stk;</code></li>
</ul>
</li>
</ul>
<h3 id="适配器的通用操作和类型">适配器的通用操作和类型</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size_type</code></td>
<td>一种类型，须以保存当前类型的最大对象的大小</td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>元素类型</td>
</tr>
<tr>
<td><code>container_type</code></td>
<td>实现适配器的底层容器类型</td>
</tr>
<tr>
<td><code>A a;</code></td>
<td>创建一个名为<code>a</code>的空适配器</td>
</tr>
<tr>
<td><code>A a(c)</code></td>
<td>创建一个名为<code>a</code>的适配器，带有容器<code>c</code>的一个拷贝</td>
</tr>
<tr>
<td>关系运算符</td>
<td>每个适配器都支持所有关系运算符：<code>==</code>、<code>!=</code>、<code>&lt;</code>、 <code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>这些运算符返回底层容器的比较结果</td>
</tr>
<tr>
<td><code>a.empty()</code></td>
<td>若<code>a</code>包含任何元素，返回<code>false</code>;否则返回<code>true</code></td>
</tr>
<tr>
<td><code>a.size()</code></td>
<td>返回<code>a</code>中的元素数目</td>
</tr>
<tr>
<td><code>swap(a, b)</code></td>
<td>交换<code>a</code>和<code>b</code>的内容，<code>a</code>和<code>b</code>必须有相同类型，包括底层容器类型也必须相同</td>
</tr>
<tr>
<td><code>a.swap(b)</code></td>
<td>同上</td>
</tr>
</tbody>
</table>
<h3 id="stack">stack</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.pop()</code></td>
<td>删除栈顶元素，不返回。</td>
</tr>
<tr>
<td><code>s.push(item)</code></td>
<td>创建一个新元素，压入栈顶，该元素通过拷贝或移动<code>item</code>而来</td>
</tr>
<tr>
<td><code>s.emplace(args)</code></td>
<td>同上，但元素由<code>args</code>来构造。</td>
</tr>
<tr>
<td><code>s.top()</code></td>
<td>返回栈顶元素，不删除。</td>
</tr>
</tbody>
</table>
<ul>
<li>定义在<code>stack</code>头文件中。</li>
<li>stack可以基于deque（默认）、list、vector实现</li>
</ul>
<h3 id="queue和priority_queue">queue和priority_queue</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>q.pop()</code></td>
<td>删除队首元素，但不返回。</td>
</tr>
<tr>
<td><code>q.front()</code></td>
<td>返回队首元素的值，不删除。</td>
</tr>
<tr>
<td><code>q.back()</code></td>
<td>返回队尾元素的值，不删除。只适用于<code>queue</code></td>
</tr>
<tr>
<td><code>q.top()</code></td>
<td>返回具有最高优先级的元素值，不删除。</td>
</tr>
<tr>
<td><code>q.push(item)</code></td>
<td>在队尾压入一个新元素。</td>
</tr>
<tr>
<td><code>q.emplace(args)</code></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>定义在<code>queue</code>头文件中。</li>
<li>queue可以基于deque（默认）、list、vector实现，priority_queue可以基于deque（默认）、vector实现</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch08 IO库</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch08-io%E5%BA%93/</link>
      <pubDate>Tue, 27 Feb 2024 15:57:17 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch08-io%E5%BA%93/</guid>
      <description>第八章 IO库 前面章节已经在用的IO库设施 istream：输入流类型，提供输入操作。 ostream：输出流类型，提供输出操作 cin：一个ist</description>
      <content:encoded><![CDATA[<h1 id="第八章-io库">第八章 IO库</h1>
<h2 id="前面章节已经在用的io库设施">前面章节已经在用的IO库设施</h2>
<ul>
<li><strong>istream</strong>：输入流类型，提供输入操作。</li>
<li><strong>ostream</strong>：输出流类型，提供输出操作</li>
<li><strong>cin</strong>：一个<code>istream</code>对象，从标准输入读取数据。</li>
<li><strong>cout</strong>：一个<code>ostream</code>对象，向标准输出写入数据。</li>
<li><strong>cerr</strong>：一个<code>ostream</code>对象，向标准错误写入消息。</li>
<li><strong>&raquo;运算符</strong>：用来从一个<code>istream</code>对象中读取输入数据。</li>
<li><strong>&laquo;运算符</strong>：用来向一个<code>ostream</code>对象中写入输出数据。</li>
<li><strong>getline函数</strong>：从一个给定的<code>istream</code>对象中读取一行数据，存入到一个给定的<code>string</code>对象中。</li>
</ul>
<h2 id="81-io类">8.1 IO类</h2>
<h3 id="标准库定义的io类型">标准库定义的IO类型</h3>
<ul>
<li><code>iostream</code>头文件：从标准流中读写数据，<code>istream</code>、<code>ostream</code>等。</li>
<li><code>fstream</code>头文件：从文件中读写数据，<code>ifstream</code>、<code>ofstream</code>等。</li>
<li><code>sstream</code>头文件：从内存string中读写数据，<code>istringstream</code>、<code>ostringstream</code></li>
</ul>
<h3 id="io对象不可复制或赋值">IO对象不可复制或赋值</h3>
<ul>
<li>不能拷贝或赋值IO对象，因此形参和返回类型也不能是流类型，一般是流的<strong>引用</strong>。</li>
<li>读写一个IO对象会改变其状态，因此引用不能是<code>const</code>的。</li>
</ul>
<h3 id="条件状态">条件状态</h3>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>strm:iostate</code></td>
<td>是一种机器无关的<strong>类型</strong>，提供了表达条件状态的完整功能</td>
</tr>
<tr>
<td><code>strm:badbit</code></td>
<td>用来指出流已经崩溃（不可恢复的读写错误，此时流无法使用）</td>
</tr>
<tr>
<td><code>strm:failbit</code></td>
<td>用来指出一个IO操作失败了（可恢复的错误）</td>
</tr>
<tr>
<td><code>strm:eofbit</code></td>
<td>用来指出流到达了文件结束</td>
</tr>
<tr>
<td><code>strm:goodbit</code></td>
<td>用来指出流未处于错误状态，此值保证为零</td>
</tr>
<tr>
<td><code>s.eof()</code></td>
<td>若流<code>s</code>的<code>eofbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.fail()</code></td>
<td>若流<code>s</code>的<code>failbit</code>置位或<code>badbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.bad()</code></td>
<td>若流<code>s</code>的<code>badbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.good()</code></td>
<td>若流<code>s</code>处于有效状态，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>将流<code>s</code>中所有条件状态位复位，将流的状态设置成有效，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.clear(flags)</code></td>
<td>将流<code>s</code>中指定的条件状态位复位（覆盖原始流状态），返回<code>void</code></td>
</tr>
<tr>
<td><code>s.setstate(flags)</code></td>
<td>根据给定的标志位，将流<code>s</code>中对应的条件状态位置位（叠加原始流状态），返回<code>void</code></td>
</tr>
<tr>
<td><code>s.rdstate()</code></td>
<td>返回流<code>s</code>的当前条件状态，返回值类型为<code>strm::iostate</code></td>
</tr>
</tbody>
</table>
<ul>
<li>其中<code>strm</code>是一种IO类型比如<code>istream</code>， <code>s</code>是一个流对象。</li>
<li>到达文件结束位置，eofbit和failbit都会置位</li>
<li>如果badbit、failbit、eofbit任何一个被置位，检测流状态的条件都会失败</li>
<li>检查流的状态：<code>while(cin &gt;&gt; word); // cin&gt;&gt;word 表达式返回流的状态</code></li>
<li>设置某个标志位：<code>cin.clear(cin.rdstate() &amp; ~cin.failbit); // 将failbit复位</code></li>
</ul>
<h3 id="管理输出缓冲">管理输出缓冲</h3>
<ul>
<li>每个输出流都管理一个缓冲区，输出可能立即打印或是暂存在缓冲区中</li>
<li>IO操纵符（显式刷新缓冲区）：
<ul>
<li><code>endl</code>：输出一个换行符并刷新缓冲区。</li>
<li><code>flush</code>：刷新流，单不添加任何字符。</li>
<li><code>ends</code>：在缓冲区插入空字符<code>null</code>，然后刷新。</li>
<li><code>unitbuf</code>：告诉流接下来每次操作之后都要进行一次<code>flush</code>操作，默认情况对cerr是设置unitbuf的</li>
<li><code>nounitbuf</code>：重置流，回到正常的缓冲方式</li>
</ul>
</li>
<li>程序异常终止时，输出缓冲区不会被刷新</li>
<li>关联输入和输出流
<ul>
<li>当一个输入流关联到一个输出流，每次从该输入流读取数据前都会先刷新关联的输出流。</li>
<li>标准库将cout和cin关联在一起</li>
<li>输入流的成员函数<code>tie</code>，（无参数时）可以返回关联的输出流的指针，（有参数时）可以设定关联到某个输出流</li>
<li>每个输入流同时最多关联一个输出流，但是多个输入流可以同时关联同一个输出流</li>
</ul>
</li>
</ul>
<h2 id="82-文件输入输出">8.2 文件输入输出</h2>
<ul>
<li>头文件<code>fstream</code>定义了三个类型来支持文件IO：
<ul>
<li><code>ifstream</code>从一个给定文件读取数据。</li>
<li><code>ofstream</code>向一个给定文件写入数据。</li>
<li><code>fstream</code>可以读写给定文件。</li>
</ul>
</li>
<li>当要读写一个文件时，创建一个文件流对象并将之绑定到该文件。</li>
</ul>
<h3 id="fstream特有的操作">fstream特有的操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fstream fstrm;</code></td>
<td>创建一个未绑定的文件流。</td>
</tr>
<tr>
<td><code>fstream fstrm(s);</code></td>
<td>创建一个文件流，并打开名为<code>s</code>的文件，<code>s</code>可以是<code>string</code>也可以是<code>char</code>指针，自动调用open</td>
</tr>
<tr>
<td><code>fstream fstrm(s, mode);</code></td>
<td>与前一个构造函数类似，但按指定<code>mode</code>打开文件</td>
</tr>
<tr>
<td><code>fstrm.open(s)</code></td>
<td>打开名为<code>s</code>的文件，并和<code>fstrm</code>绑定；如果 open 失败，failebit 会被置位</td>
</tr>
<tr>
<td><code>fstrm.close()</code></td>
<td>关闭和<code>fstrm</code>绑定的文件，注意close并不会重置流的条件状态，需要使用clear重置。当一个 fstream 对象被销毁时，close 函数会自动被调用。</td>
</tr>
<tr>
<td><code>fstrm.is_open()</code></td>
<td>返回一个<code>bool</code>值，指出与<code>fstrm</code>关联的文件是否成功打开且尚未关闭</td>
</tr>
</tbody>
</table>
<h3 id="文件模式">文件模式</h3>
<table>
<thead>
<tr>
<th>文件模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>in</code></td>
<td>以<strong>读</strong>的方式打开，与ifstream对象关联的文件默认以in模式打开</td>
</tr>
<tr>
<td><code>out</code></td>
<td>以<strong>写</strong>的方式打开，与ofstream对象关联的文件默认以out模式打开</td>
</tr>
<tr>
<td><code>app</code></td>
<td>每次写操作前均定位到文件末尾。设置了trunc就不能再设置app模式；在app模式下，即使没有设定out模式，文件也是以输出方式打开</td>
</tr>
<tr>
<td><code>ate</code></td>
<td>打开文件后立即定位到文件末尾</td>
</tr>
<tr>
<td><code>trunc</code></td>
<td>截断文件，只有设置了 out 才能设置trunc模式，只设置out模式会默认也设置trunc模式</td>
</tr>
<tr>
<td><code>binary</code></td>
<td>以二进制方式进行IO操作。</td>
</tr>
</tbody>
</table>
<ul>
<li>与fstream对象关联的文件默认以in和out模式打开</li>
<li>默认情况下以 out 模式打开文件会使文件内容被清空，如果要保留文件内容
<ul>
<li>需要同时指定app模式：数据追加到末尾</li>
<li>或是同时指定in模式：同时进行读写操作</li>
</ul>
</li>
</ul>
<h2 id="83-string流">8.3 string流</h2>
<ul>
<li>头文件<code>sstream</code>定义了三个类型来支持读写string：
<ul>
<li><code>istringstream</code>从<code>string</code>读取数据。</li>
<li><code>ostringstream</code>向<code>string</code>写入数据。</li>
<li><code>stringstream</code>可以读写给定<code>string</code>。</li>
</ul>
</li>
</ul>
<h3 id="stringstream特有的操作">stringstream特有的操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sstream strm</code></td>
<td>定义一个未绑定的<code>stringstream</code>对象</td>
</tr>
<tr>
<td><code>sstream strm(s)</code></td>
<td>用<code>s</code>初始化对象</td>
</tr>
<tr>
<td><code>strm.str()</code></td>
<td>返回<code>strm</code>所保存的<code>string</code>的拷贝</td>
</tr>
<tr>
<td><code>strm.str(s)</code></td>
<td>将<code>s</code>拷贝到<code>strm</code>中，返回<code>void</code></td>
</tr>
</tbody>
</table>
<ul>
<li>上表中<code>sstream</code>是头文件<code>sstream</code>中任意一个类型。<code>s</code>是一个<code>string</code>。</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=dc0a09be-f4e4-9da7-0d9a-eccec71bb7f4&amp;page=314&amp;rect=87.840,397.200,204.000,405.600">使用例子</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch07 类</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch07-%E7%B1%BB/</link>
      <pubDate>Tue, 27 Feb 2024 15:57:08 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch07-%E7%B1%BB/</guid>
      <description>第七章 类 7.1 定义抽象数据类型 类成员 必须在类的内部声明，不能在其他地方增加成员。 成员可以是数据，函数，类型别名。 类的const成员函数不会修改类</description>
      <content:encoded><![CDATA[<h1 id="第七章-类">第七章 类</h1>
<h2 id="71-定义抽象数据类型">7.1 定义抽象数据类型</h2>
<h3 id="类成员">类成员</h3>
<ul>
<li>必须在类的内部声明，不能在其他地方增加成员。</li>
<li>成员可以是数据，函数，类型别名。</li>
<li><strong>类的const成员函数</strong>不会修改类的数据成员：<code>void func() const;</code>
<ul>
<li>const成员函数的声明和定义处都要加const</li>
<li>const成员函数不能调用本类的非const成员函数</li>
</ul>
</li>
<li><strong>内联函数</strong>
<ul>
<li>定义在类内部的函数是隐式inline函数</li>
<li>inline成员函数应该与类定义同一个头文件中</li>
</ul>
</li>
<li><strong>可变数据成员</strong> （mutable data member）：表示数据成员永远可变
<ul>
<li><code>mutable int cnt;</code>，这样即使在const成员函数中也可以修改cnt的值</li>
</ul>
</li>
<li><strong>[[ch07-类#返回<code>this</code>的成员函数|返回this的成员函数]]</strong></li>
<li><strong>构造函数</strong>
<ul>
<li>构造函数初始值列表：<code>Sales_item(): units_sold(0), revenue(0.0) { }</code> ^742596
<ul>
<li>但是类内初始值必须使用等号或者花括号进行初始化</li>
</ul>
</li>
<li>当一个类没有定义任何构造函数时，编译器才会生成一个默认构造函数（也称合成的默认构造函数），使用<code>=default</code>要求编译器使用合成的默认的构造函数。 ^15282e</li>
</ul>
</li>
</ul>
<h3 id="非成员函数">非成员函数</h3>
<ul>
<li>和类相关的非成员函数，定义和声明都应该在类的外部。</li>
</ul>
<h2 id="72-访问控制与封装">7.2 访问控制与封装</h2>
<ul>
<li>访问说明符（access specifiers）：<code>public</code>、<code>private</code>、<code>protected</code></li>
<li><code>class</code>与<code>struct</code>都可以被用于定义一个类，唯一的却别在于默认访问权限：
<ul>
<li><code>class</code>：默认成员是 <code>priavte</code>的。</li>
<li><code>struct</code>：默认成员是 <code>public</code>的。</li>
</ul>
</li>
</ul>
<h3 id="友元">友元</h3>
<ul>
<li>在类A中设置友元B（函数或类），即允许B访问A中的非共有成员</li>
<li>语法相关：
<ul>
<li>通常将友元声明成组地放在类定义的开始或者结尾，但友元不是类的成员，不受public/private的约束</li>
<li>如果类想把一组重载函数声明为友元，需要对这组函数中的每一个分别声明。</li>
<li>友元关系不存在传递性。</li>
<li>把其他类的成员函数声明为友元时，必须明确指定该函数所属的类名。</li>
<li>友元函数可以直接定义在类的内部（隐式内联），但是必须在类外部提供相应声明，并且要在调用之前进行声明
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">X</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">friend</span> <span class="kt">void</span> <span class="nf">fir</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* do something */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="kt">void</span> <span class="n">pub</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="kt">void</span> <span class="n">pri</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">X</span><span class="o">::</span><span class="n">pub</span><span class="p">()</span> <span class="p">{</span> <span class="n">fir</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// 错误：友元函数fri在类外必须进行声明且需要在调用之前进行声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">fir</span><span class="p">();</span> <span class="c1">// 类X的友元函数fri，在类外进行声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">X</span><span class="o">::</span><span class="n">h</span><span class="p">()</span> <span class="p">{</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span>     
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="73-类的其他特性">7.3 类的其他特性</h2>
<h3 id="this"><code>this</code></h3>
<ul>
<li>每个成员函数都有一个额外的、隐含的形参<code>this</code>，<code>this</code>总是指向调用该成员函数的对象
<ul>
<li>在普通成员函数中，this是一个<code>T *const</code>类型的指针</li>
<li>在const成员函数中，this是一个<code>const T *const</code>类型的指针（因此数据成员无法修改）</li>
<li>静态函数中不能使用this指针</li>
</ul>
</li>
<li>const对象或是const对象的指针/引用，只能调用const成员函数；否则均可</li>
<li><code>return *this;</code>可以让成员函数<strong>连续调用</strong>。</li>
</ul>
<h3 id="类类型">类类型</h3>
<ul>
<li>可以声明一个类而暂时不定义它，称为<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=6fbd93d1-81be-2584-6f7d-5147c71be3ad&amp;page=276&amp;rect=148.810,525.840,185.290,534.000">前向声明</a>，用于引入类的名字；在前向声明之后、定义之前是一个不完全类型</li>
<li>可以定义指向不完全类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或返回值类型的函数</li>
</ul>
<h3 id="ch07-类友元友元">[[ch07-类#友元|友元]]</h3>
<h2 id="74-类的作用域">7.4 类的作用域</h2>
<p>类型别名如果在类外已经定义过，不能在类内再次定义。</p>
<h2 id="75-构造函数再探">7.5 构造函数再探</h2>
<ul>
<li>使用初始值列表进行初始化才是真正的初始化，在构造函数体中进行“初始化”只是赋值
<ul>
<li>如果是const成员或是引用类型，则必须在<strong>构造函数初始值列表</strong>中将其初始化（圆括号初始化）<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=e5af4ab3-b656-c156-52ca-a970eb1e7843&amp;page=284&amp;rect=251.230,38.650,397.440,46.810">例子</a></li>
</ul>
</li>
</ul>
<h3 id="委托构造函数-delegating-constructor">委托构造函数 （delegating constructor）</h3>
<p>委托构造函数通过其他构造函数来执行自己的初始化过程
- <code>Sale_data(): Sale_data(&quot;&quot;, 0, 0) {}</code></p>
<h3 id="隐式的类型转换">隐式的类型转换</h3>
<ul>
<li><strong>转换构造函数</strong>：如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的<strong>隐式转换机制</strong>，因此可以叫做转换构造函数。</li>
<li>编译器只会自动进行<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=b361b56d-3b61-5fee-5d3f-33c8af531492&amp;page=290&amp;rect=69.360,424.320,173.280,432.720">一步的隐式类型转换</a></li>
<li>将转换构造函数声明为<code>explicit</code>从而抑制隐式类型转换
<ul>
<li>explicit关键字只对接受一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，因此也无须将其指定为explicit</li>
<li>只在类内声明构造函数时使用explicit，在类外部定义时不应重复</li>
<li><code>explicit</code>构造函数只能用于直接初始化（圆括号初始化），不能用于拷贝赋值初始化（<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=3ce3ab3e-72e2-25d6-75ab-fe76a0f0014e&amp;page=291&amp;rect=52.560,293.290,222.961,301.930">例子</a>）</li>
</ul>
</li>
</ul>
<h3 id="聚合类obsidianbooknotetypeannotationbookcpp_primer-e99885e8afbbe7ac94e8aeb0primer20ce7acac5e78988pdfid2b69f080-2a9d-5995-2c7e-1e0b9bfa85ebpage292rect95760180960123120190080"><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=2b69f080-2a9d-5995-2c7e-1e0b9bfa85eb&amp;page=292&amp;rect=95.760,180.960,123.120,190.080">聚合类</a></h3>
<h3 id="字面值常量类">字面值常量类</h3>
<ul>
<li><code>constexpr</code>函数的参数和返回值必须是字面值。</li>
<li><strong>字面值类型</strong>：算数类型，引用，指针，聚合类</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=bb154d0b-92ba-c46f-65db-80fd7cd1e67b&amp;page=293&amp;rect=54.720,75.840,144,84.480">constexpr 构造函数</a></li>
</ul>
<h2 id="76-类的静态成员">7.6 类的静态成员</h2>
<ul>
<li>语法相关：
<ul>
<li>静态成员可以是public或是private的</li>
<li>静态成员可以是常量、指针、引用、类</li>
<li>静态成员函数不包含this指针，不能声明为const成员函数</li>
<li>定义和初始化
<ul>
<li>在类内声明，类外定义并初始化。</li>
<li>在类外定义时，不能重复 static 关键字，static 只出现在类内的声明中。</li>
<li>只有<code>constexpr</code>类型的静态数据成员可以在类内定义。</li>
</ul>
</li>
</ul>
</li>
<li>使用：
<ul>
<li>使用作用域运算符<code>::</code>直接访问静态成员:<code>r = Account::rate();</code></li>
<li>也可以使用类的对象访问：<code>r = ac.rate();</code></li>
</ul>
</li>
<li>特殊场景：<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=8c7bfe7a-bc18-a299-2930-8fb9548b9898&amp;page=297&amp;rect=61.920,395.040,260.640,403.680">例子</a>
<ul>
<li>静态数据成员的类型可以是不完全类型，比如可以是它所属的类类型，而普通变量不能（只能声明为所属类类型的指针或引用）</li>
<li>可以使用静态成员变量作为函数的默认实参</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch06 函数</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch06-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 27 Feb 2024 15:56:57 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch06-%E5%87%BD%E6%95%B0/</guid>
      <description>第六章 函数 6.1 函数基础 调用运算符：一对圆括号 ()，作用于函数指针 函数调用过程： 主调函数（calling function）的执行被中断，使用实参</description>
      <content:encoded><![CDATA[<h1 id="第六章-函数">第六章 函数</h1>
<h2 id="61-函数基础">6.1 函数基础</h2>
<ul>
<li>调用运算符：一对圆括号 <code>()</code>，作用于函数指针</li>
<li>函数调用过程：
<ul>
<li>主调函数（calling function）的执行被中断，使用实参初始化对应的形参</li>
<li>控制权移交给被调函数，被调函数（called function）开始执行。</li>
</ul>
</li>
<li>函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。</li>
</ul>
<h3 id="局部对象">局部对象</h3>
<ul>
<li><strong>生命周期</strong>：对象的生命周期是程序执行过程中该对象存在的一段时间。</li>
<li><strong>局部静态对象</strong>： <code>static</code>类型的局部变量，在程序执行路径第一次经过对象定义语句时进行初始化，直到程序终止才被销毁</li>
</ul>
<h3 id="函数声明">函数声明</h3>
<ul>
<li>函数声明不需要形参的名字</li>
<li>函数三要素：返回类型，函数名，形参类型</li>
</ul>
<h2 id="62-参数传递">6.2 参数传递</h2>
<ul>
<li>形参初始化的机理和变量初始化一样
<ul>
<li>形参的顶层<code>const</code>被忽略：<code>void func(const int i)</code>与<code>void func(int i)</code>具有相同的函数签名 ^f06638
<ul>
<li>原因：引用没有顶层const；如果传值，传递的是实参的副本，不会改变实参的值</li>
<li>但是前面这个函数体中i是const的，连副本也无法修改</li>
</ul>
</li>
</ul>
</li>
<li>两种传参方式：
<ul>
<li>传值参数（值传递，传值调用）</li>
<li>传引用参数（引用传递，传引用调用）
<ul>
<li>如果无需改变引用形参的值，最好将其声明为常量引用。</li>
<li>不能将const对象、字面值或需要类型转换的对象传递给普通引用形参，但是可以传递给常量引用形参</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数组形参">数组形参</h3>
<ul>
<li>数组有两个特殊性质：不允许拷贝数组、使用数组时通常会将其转换为指针</li>
<li>数组形参：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 以下几种方式形参等价，编译器只会检查传参类型是否为const int*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">[])</span> <span class="c1">// 可以看出函数意图是传递数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="c1">// 可以提示数组长度
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针，因此也要传入数组长度</li>
</ul>
</li>
<li>数组引用形参：形参是数组引用，实参要传递相同类型及大小的数组
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)[</span><span class="mi">5</span><span class="p">]){}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>传递多维数组：数组第二维（及更多维）的大小都是数组类型的一部分，不能省略
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">matrix</span><span class="p">)[</span><span class="mi">10</span><span class="p">],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">){}</span> <span class="c1">// matrix是一个指针，指向int[10]类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">matrix</span><span class="p">[][</span><span class="mi">10</span><span class="p">],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">){}</span> <span class="c1">// 等价定义
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="main处理命令行选项">main处理命令行选项</h3>
<ul>
<li><code>int main(int argc, char *argv[]) {}</code>
<ul>
<li>argc代表参数的个数；argv是一个数组，数组元素是char*（或者说char数组），第一个元素是程序的名字或一个空字符串，</li>
</ul>
</li>
</ul>
<h3 id="可变形参">可变形参</h3>
<ul>
<li>处理不同数量实参的函数
<ul>
<li>如果所有实参类型相同，可以传递一个<code>initializer_list</code>标准库类型</li>
<li>如果实参类型不同，可以定义可变参数模板</li>
<li>省略符形参：<code>void func(param_list, ...)</code>
<ul>
<li>一般只用于与C函数交互的接口程序，便于CPP访问某些C代码</li>
<li>大多数类类型的对象在传递给省略符形参时都无法正确拷贝</li>
<li>省略符形参对应的实参无须类型检查</li>
</ul>
</li>
</ul>
</li>
<li><code>initializer_list</code>：定义在同名头文件中的模板类型
<ul>
<li><code>initializer_list</code>与vector类似，但是它元素永远是常量</li>
<li><code>initializer_list</code>只能使用列表初始化</li>
<li>含有<code>initializer_list</code>形参的函数也可以有其他形参</li>
<li>其他容器使用列表初始化本质上都是采用了<code>initializer_list</code>形参的构造函数进行初始化的</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=67eed969-0ae3-b578-5007-a926384feff5&amp;page=224&amp;rect=218.650,632.400,316.320,640.080">initializer_list 提供的操作</a>：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span><span class="p">;</span><span class="c1">//默认初始化:空列表 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">initlst</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span><span class="c1">//initlast 的元素数量与初始值一样多
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">lst1</span><span class="p">(</span><span class="n">initlst</span><span class="p">);</span> <span class="c1">// 直接初始化，lst1与initlst共享元素（不会复制）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">lst2</span><span class="p">(</span><span class="n">initlst</span><span class="p">);</span> <span class="c1">// 赋值初始化，lst2与initlst共享元素（不会复制）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">lst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">});</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h2 id="63-返回类型和return语句">6.3 返回类型和return语句</h2>
<ul>
<li>不要返回局部对象的引用或指针</li>
<li><strong>引用返回左值</strong>：调用一个返回引用的函数得到左值，其他返回类型得到右值。</li>
<li>列表初始化返回值：函数可以返回花括号包围的值的列表，并对函数返回的临时量进行初始化。
<ul>
<li><code>vector&lt;int&gt; func() { return {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; }</code></li>
<li>这样可以减少一次拷贝？
<ul>
<li>相关：RVO</li>
<li>参考：《程序员的自我修养》P305（声明狼藉的C++返回对象）</li>
</ul>
</li>
</ul>
</li>
<li>main的返回值：cstdlib头文件定义了两种预处理变量来表示成功（<code>EXIT_FAILURE</code>）与失败（<code>EXIT_SUCCESS</code>）</li>
</ul>
<h3 id="返回数组指针">返回数组指针</h3>
<ul>
<li>取别名比较方便</li>
<li>可以使用尾置返回类型</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// int ( *p )[10]; // 数组指针：指向数组的指针
</span></span></span><span class="line"><span class="cl"><span class="c1">// int ( *func(params) )[10]; // 返回数组指针：函数参数是params，返回指向int[10]的数组指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 形式： Type (*function (parameter_list))[dimension]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="p">(</span> <span class="o">*</span><span class="n">func1</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="mi">5</span><span class="p">])</span> <span class="p">)[</span><span class="mi">5</span><span class="p">]{</span> <span class="c1">// 传入数组指针，返回数组指针, int (*arr)[5]是传入的数组指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">),</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ed</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用类型别名进行简化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">arrT</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// typedef int arrT[10]; // 感觉没有using直观
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">arrT</span><span class="o">*</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arrT</span><span class="o">*</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span> <span class="c1">// 使用别名，传入数组指针，返回数组指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 数组指针解引用得到数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用尾置返回类型，简化函数的声明和定义（尤其当返回值比较复杂时）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 在形参列表后面跟一个-&gt;，表示真正的返回值类型跟在形参列表之后，开头返回值用auto代替
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">func3</span><span class="p">(</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">5</span><span class="p">]{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">),</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ed</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 还可以使用 `decltype`，见P206
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// p是指向数组的指针， p的内容是数组首地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">arrT</span><span class="o">*</span> <span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// pp同样是数组的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">func1</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">),</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ed</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">it</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">func2</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">),</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ed</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">it</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">a3</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">func3</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">a3</span><span class="p">),</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">a3</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ed</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">it</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="64-函数重载">6.4 函数重载</h2>
<ul>
<li>语法相关：
<ul>
<li>不允许两个函数除了返回类型以外的其他所有要素都相同，或者说返回值与重载无关</li>
<li>因为[[ch06-函数#^f06638|形参的顶层const被忽略]]，所以在重载函数中，一个有顶层const形参，另一个重载函数相应参数是普通形参，相当于重复声明，但是可以区分底层const。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=4f33a9d7-1eec-b511-c252-e9aeb4459a80&amp;page=234&amp;rect=115.200,519.130,429.360,526.810">例子</a></li>
</ul>
</li>
<li>使用：
<ul>
<li>一个函数的形参可能有常量引用和非常量引用两种版本，可以使用const_cast进行类型的转换
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* do something*/</span><span class="p">}</span> <span class="c1">// 底层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">func</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>重载和作用域：因为C++中名字查找发生在类型检查之间，所以编译器一旦在当前作用域内找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。
<ul>
<li>因此，不同的重载版本要定义在同一作用域中，一般是全局作用域</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="65-特殊用途语言特性">6.5 特殊用途语言特性</h2>
<h3 id="默认实参">默认实参</h3>
<ul>
<li>形参顺序：普通形参，不怎么使用默认值的形参，经常使用默认值的形参
<ul>
<li>设置默认值的形参必须放在没有默认值的形参之后</li>
<li>一旦某个形参被赋予（或使用）默认值，那么它之后的形参都必须要有默认值</li>
</ul>
</li>
<li>虽然多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">screen</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="o">=</span><span class="sc">&#39; &#39;</span><span class="p">);</span> <span class="c1">// 第一次声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">screen</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// 第二次声明，添加了默认实参
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>默认实参只能出现在函数声明和定义其中一处，通常应该在头文件中的函数声明中指定默认实参。</li>
<li>局部变量不能作为函数的默认实参，全局变量和字面值都可以</li>
</ul>
<h3 id="内联inline函数">内联（inline）函数</h3>
<ul>
<li>在函数声明和定义中都能使用关键字inline，但是建议只在函数定义时使用。</li>
<li>一般来说，内联机制适用于优化规模较小、流程直接、调用频繁的函数。内联函数中不允许有循环语句和switch语句，否则函数会被编译为普通函数。</li>
</ul>
<h3 id="constexpr-函数obsidianbooknotetypeannotationbookcpp_primer-e99885e8afbbe7ac94e8aeb0primer20ce7acac5e78988pdfid08ac9451-c1bd-d611-0716-98d876b07c54page240rect62650382800131280391200"><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=08ac9451-c1bd-d611-0716-98d876b07c54&amp;page=240&amp;rect=62.650,382.800,131.280,391.200">constexpr 函数</a></h3>
<p>不是很理解，个人理解是在编译器就能确定返回值的函数</p>
<ul>
<li>内联函数和constexpr函数通常定义在头文件中。</li>
</ul>
<h3 id="调试帮助">调试帮助</h3>
<p>调试帮助：用类似头文件保护的方式，有选择的执行调试代码。即在开发过程中，程序可以包含一些用于调试的代码，当程序发布时，需要先屏蔽掉调试代码。调试帮助通常包含两种预处理功能：<code>assert</code>和<code>DNEBUG</code></p>
<ul>
<li><code>assert</code>是一种预处理宏（preprocessor macro）：<code>assert(expr);</code>
<ul>
<li>当表达式为假时，assert输出信息并终止程序；如果真，assert什么都不做</li>
<li>常用来检查不能发生的条件</li>
</ul>
</li>
<li><code>NDEBUG</code>预处理变量：关闭调试状态
<ul>
<li>可以使用<code>#define NDEBUG</code>来定义<code>NDEBUG</code>，但很多编译器都提供了命令行选项<code>-D NDEBUG</code></li>
<li>如果定义了<code>NDEBUG</code>，则assert什么都不做；默认情况下没有定义<code>NDEBUG</code></li>
<li>几个用于调试的变量名称：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">变量名称</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__func__</code></td>
<td style="text-align:center">当前函数名称</td>
</tr>
<tr>
<td style="text-align:center"><code>__FILE__</code></td>
<td style="text-align:center">当前文件名称</td>
</tr>
<tr>
<td style="text-align:center"><code>__LINE__</code></td>
<td style="text-align:center">当前行号</td>
</tr>
<tr>
<td style="text-align:center"><code>__TIME__</code></td>
<td style="text-align:center">文件编译时间</td>
</tr>
<tr>
<td style="text-align:center"><code>__DATE__</code></td>
<td style="text-align:center">文件编译日期</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="cp">#ifndef NDEBUG </span><span class="c1">// 默认情况下没有定义NDEBUG，可以在这里编写自己的调试代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 如果定义了NDEBUG，则跳过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">__func__</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="66-函数匹配">6.6 函数匹配</h2>
<p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=ff2868c8-59a4-9b72-c42c-92a021d43cec&amp;page=235&amp;rect=350.170,216.730,389.050,225.850">函数匹配</a>（或称为重载确定）</p>
<ul>
<li>重载函数匹配的三个步骤：
<ul>
<li>找候选函数：同名函数</li>
<li>选可行函数：形参实参数量相等，类型匹配或者能进行转换</li>
<li>寻找最佳匹配：实参类型和形参类型越接近，它们匹配越好
<ul>
<li>精确匹配、从数组类型或函数类型转换为对应的指针类型、添加/删除顶层const</li>
<li>const转换</li>
<li>类型提升</li>
<li>算数类型转换、指针转换</li>
<li>类类型转换</li>
</ul>
</li>
<li>如果有若干个匹配，但没有一个最佳匹配时，编译器可能报告二义性调用的信息</li>
</ul>
</li>
</ul>
<h2 id="67-函数指针">6.7 函数指针</h2>
<ul>
<li>对于重载函数，函数指针类型必须与重载函数中某一个精确匹配
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">Func</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="kt">int</span> <span class="nf">Func2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数类型，等价于Func
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">using</span> <span class="n">FuncP</span> <span class="o">=</span>  <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数指针类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">FuncP2</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数指针类型，等价于FuncP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="nf">add</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">op1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">op2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">Func</span><span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);}</span> <span class="c1">// 函数不能做形参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">op3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">FuncP</span> <span class="n">fp</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">1</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="n">FuncT</span><span class="p">;</span> <span class="c1">// 函数类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">FuncTP</span><span class="p">);</span> <span class="c1">// 函数指针类型，decltype返回函数类型，需要在别名类型前加上*表示函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  	<span class="n">Func</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  	<span class="n">FuncP</span> <span class="n">g</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">op1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">add</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">op2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">op3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">g</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>函数指针可以作为形参
<ul>
<li>形参类型可能为函数类型，传入的也可能是函数名，但是最终都是转换为函数指针</li>
</ul>
</li>
<li>函数指针可以作为返回值，函数类型不可以作为返回值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Func</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">FuncP</span> <span class="o">=</span>  <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数指针类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret_func1</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 一个名为ret_func1的函数，其参数为params，返回一个int(*)(int, int)类型的函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">ret_func2</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 尾置返回类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Func</span><span class="o">*</span> <span class="nf">ret_func3</span><span class="p">(</span><span class="n">params</span><span class="p">);</span> <span class="c1">// 使用别名，返回指向函数类型的指针，不能返回Func
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">FuncP</span> <span class="nf">ret_func4</span><span class="p">(</span><span class="n">params</span><span class="p">);</span> <span class="c1">// 使用别名，返回函数指针
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>复杂例子：假设函数指针类型是<code>int(*)(int, int)</code>，数组指针类型是<code>int (*)[5]</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">FuncP</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Arr</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>返回值是函数指针，函数形参是数组指针
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span> <span class="o">*</span><span class="n">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">5</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">FuncP</span> <span class="nf">f</span><span class="p">(</span><span class="n">Arr</span><span class="o">*</span> <span class="n">arr</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>返回值是函数指针，函数形参是函数指针
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">))</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">FuncP</span> <span class="nf">f</span><span class="p">(</span><span class="n">FuncP</span> <span class="n">fp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>返回值是数组指针，函数形参是函数指针
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span> <span class="o">*</span><span class="n">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="p">)[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">Arr</span><span class="o">*</span> <span class="nf">f</span><span class="p">(</span><span class="n">FuncP</span> <span class="n">fp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>返回值是数组指针，函数形参是数组指针
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="p">))[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">Arr</span><span class="o">*</span> <span class="nf">f</span><span class="p">(</span><span class="n">Arr</span><span class="o">*</span> <span class="n">arr</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch05 语句</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch05-%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Tue, 27 Feb 2024 15:56:48 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch05-%E8%AF%AD%E5%8F%A5/</guid>
      <description>第五章 语句 简单语句 表达式语句：一个表达式末尾加上分号，就变成了表达式语句。 空语句：有时语法上需要一个语句，但是逻辑上不需要，可以直接写一个分</description>
      <content:encoded><![CDATA[<h1 id="第五章-语句">第五章 语句</h1>
<h2 id="简单语句">简单语句</h2>
<ul>
<li><strong>表达式语句</strong>：一个表达式末尾加上分号，就变成了表达式语句。</li>
<li><strong>空语句</strong>：有时语法上需要一个语句，但是逻辑上不需要，可以直接写一个分号。</li>
<li><strong>复合语句（块）</strong>：用花括号 <code>{}</code>包裹起来的语句和声明的序列。一个块就是一个作用域。空块等价于空语句。</li>
</ul>
<h2 id="条件语句">条件语句</h2>
<ul>
<li><strong>悬垂else</strong>（dangling else）：用来描述在嵌套的<code>if else</code>语句中，如果<code>if</code>比<code>else</code>多时如何处理的问题。C++使用的方法是<code>else</code>匹配最近没有配对的<code>if</code>。</li>
</ul>
<h2 id="迭代语句">迭代语句</h2>
<ul>
<li>range-for中不能改变序列的元素数量，因为预存了end()的值，改变预存的值失效</li>
</ul>
<h2 id="try语句块和异常处理">try语句块和异常处理</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">throw</span> <span class="nf">runtime_error</span><span class="p">(</span><span class="s">&#34;Data must be same as size&#34;</span><span class="p">);</span> <span class="c1">// throw抛出使用字符串初始化的异常类型的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">catch</span><span class="p">(</span><span class="n">runtime_error</span> <span class="n">err</span><span class="p">)</span><span class="c1">//异常类型对象的声明（也称异常声明）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">// catch子句也称为异常处理代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">err</span><span class="p">.</span><span class="n">what</span><span class="p">();</span><span class="c1">//每个标准异常类都有一个what成员函数，返回初始化对象时使用的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">catch</span><span class="p">(...){</span> <span class="cm">/* 捕获所有异常*/</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=92e04fc5-9bef-d3e3-c183-01b5c1524a37&amp;page=202&amp;rect=104.160,508.320,151.680,518.160">标准异常</a>及其继承关系：
<img src="https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-09-14-15:34:43.png" alt="image.png" style="zoom:50%;" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch04 表达式</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 27 Feb 2024 15:56:40 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>第四章 表达式 4.1 表达式基础 左值和右值： 一个对象被用作左值时，使用的是对象的身份（在内存中的地址，左值可以按名访问，而且其地址可以被赋值） 一个对</description>
      <content:encoded><![CDATA[<h1 id="第四章-表达式">第四章 表达式</h1>
<h2 id="41-表达式基础">4.1 表达式基础</h2>
<ul>
<li><strong>左值和右值</strong>：
<ul>
<li>一个对象被用作左值时，使用的是对象的身份（在内存中的地址，左值可以按名访问，而且其地址可以被赋值）</li>
<li>一个对象被用作右值时，使用的是对象的值（内容）
<ul>
<li>（自己的理解）即使一个对象可以按名访问，但如果该对象的内容在只读数据段，该对象也是右值</li>
</ul>
</li>
<li>需要右值的地方可以使用左值代替，但是反过来不行</li>
<li><code>decltype</code>作用于表达式（注意不是变量），推导出来是左值还是右值，与表达式返回值是左值还是右值相同</li>
</ul>
</li>
<li><strong>求值顺序</strong>：
<ul>
<li>如果改变了某个运算对象的值，在同一表达式中不要再使用该运算对象，<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=b7e91651-45ab-3457-d6fd-6d7d5772b8d8&amp;page=149&amp;rect=100.800,520.213,148.320,533.047">参考</a></li>
<li>只有四种运算符明确规定了求值顺序：<code>&amp;&amp;</code>、<code>||</code>、<code>?:</code>、<code>,</code></li>
</ul>
</li>
</ul>
<h2 id="42-算术运算符">4.2 算术运算符</h2>
<ul>
<li>整数除法的结果向0舍入</li>
<li>取余运算m%n，结果符号与被除数m相同</li>
</ul>
<h2 id="43-逻辑和关系运算符">4.3 逻辑和关系运算符</h2>
<ul>
<li>短路求值</li>
</ul>
<h2 id="44-赋值运算符">4.4 赋值运算符</h2>
<ul>
<li>C++11允许使用花括号括起来的初始值列表作为右侧运算对象，初始化列表为空时进行值初始化</li>
<li>赋值运算的<strong>返回结果是它的左侧运算对象</strong>，是一个左值</li>
<li>赋值运算符满足<strong>右结合律</strong>，这点和其他二元运算符不一样。
<ul>
<li>比如：<code>ival = jval = 0;</code>等价于<code>jval = 0; ival = jval;</code></li>
</ul>
</li>
<li>复合赋值运算符只求值一次，而普通运算符需要两次。
<ul>
<li>比如：a=a+1 要先求一次 a+1，再将结果赋值给 a</li>
</ul>
</li>
</ul>
<h2 id="45-递增和递减运算符">4.5 递增和递减运算符</h2>
<ul>
<li>前置版本<code>j = ++i</code>，先i加一，后给j赋值，优先使用</li>
<li>后置版本<code>j = i++</code>，先给j赋值，后i加一</li>
</ul>
<ul>
<li>混用解引用和递增运算符：<code>*p++</code> 等价于 <code>*(p++)</code>
<ul>
<li>首先进行自加，p指向下一个位置，返回原来对象的副本</li>
<li>将原来对象的副本进行解引用
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">!=</span><span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">iter</span><span class="o">++&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>	<span class="c1">// 输出当前值，指针向前移1
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h2 id="46-成员访问运算符">4.6 成员访问运算符</h2>
<p><code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code></p>
<h2 id="47-条件运算符">4.7 条件运算符</h2>
<ul>
<li>条件运算符（<code>?:</code>）：<code>cond? expr1: expr2</code></li>
<li>可以嵌套使用，右结合律，从右向左顺序组合</li>
</ul>
<h2 id="48-位运算符">4.8 位运算符</h2>
<ul>
<li>位运算符是作用于整数类型的运算对象。</li>
<li>向左移（<code>&lt;&lt;</code>），向右移（<code>&gt;&gt;</code>），位取反（<code>~</code>）（逐位求反）、与（<code>&amp;</code>）、或（<code>|</code>）、异或（<code>^</code>）</li>
<li>有符号数负值可能移位后变号，所以强烈建议位运算符仅用于无符号数。</li>
</ul>
<h2 id="49-sizeof运算符">4.9 sizeof运算符</h2>
<ul>
<li>语法：
<ul>
<li><code>sizeof (type)</code>：返回类型的大小</li>
<li><code>sizeof expr</code>：返回表达式结果类型的大小</li>
<li>返回类型是 <code>size_t</code>的常量表达式</li>
</ul>
</li>
<li><code>sizeof</code>并不实际计算其运算对象的值。</li>
<li>对数组执行<code>sizeof</code>运算得到整个数组所占空间的大小。</li>
<li>对<code>string</code>或<code>vector</code>对象执行<code>sizeof</code>运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。</li>
</ul>
<h2 id="410-逗号运算符">4.10 逗号运算符</h2>
<p>从左向右依次求值，左侧求值结果丢弃，返回结果是右侧表达式的值。</p>
<h2 id="411-类型转换">4.11 类型转换</h2>
<p>C++不会直接将两个不同类型的值相加，会先通过类型转换将运算对象的类型统一之后再求值</p>
<h3 id="隐式类型转换">隐式类型转换</h3>
<ul>
<li>整型提升</li>
<li>数组转换成指针：大多数情况下，数组名字自动转换成指向数组首元素的指针
<ul>
<li>decltype关键词参数、取地址符、sizeof、typeid不会发生这种转换</li>
</ul>
</li>
<li>指针的转换：
<ul>
<li>常量整数值0或字面值nullptr能转换成任意指针类型</li>
<li>指向任意非常量的指针能转换成void*</li>
<li>指向任意对象的指针能转换成const void*</li>
<li>指向派生类的指针自动转换为指向基类的指针</li>
</ul>
</li>
<li>转换成布尔类型</li>
<li>转换成常量：指向非常量类型的指针能转换成指向相应的常量类型的指针
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">i</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="c1">// 可以通过i修改变量的值，但是不能通过p和r修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">r</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>类类型的转换</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">);</span> <span class="c1">//将cin转换为bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;value&#34;</span><span class="p">;</span> <span class="c1">// 将字符数组转换为string
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="显式类型转换即强制类型转换">显式类型转换（即强制类型转换）</h3>
<ul>
<li>形式：<code>cast_name&lt;type&gt;(expression);</code>
<ul>
<li>type: 转换的目标类型，如果type是引用类型，则结果是左值</li>
<li>cast_name: static_case, dynamic_cast, const_cast, reinterpret_cast中的一种</li>
</ul>
</li>
<li><strong>static_cast</strong>：任何明确定义的类型转换，只要不包含底层const，都可以使用
<ul>
<li>把一个较大的算数类型赋值给较小的类型（可能有精度损失）</li>
<li>找回<code>void*</code>中的值</li>
</ul>
</li>
<li><strong>const_cast</strong>：只能改变运算对象的底层const，一般用于去除const属性
<ul>
<li>只有const_cast可以改变表达式的const属性（顶层const或底层const都可以）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// i是底层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">j</span><span class="p">;</span> <span class="c1">// 3 3 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// i是底层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">j</span><span class="p">;</span> <span class="c1">// 2 3 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// i是顶层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">j</span><span class="p">;</span> <span class="c1">// 4 4 4
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>const_cast常用于有函数重载的上下文中</li>
</ul>
</li>
</ul>
</li>
<li><strong>reinterpret_cast</strong>：通常为运算对象的位模式提供低层次上的重新解释，慎重使用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 但是c所指的真实对象是一个int而非char
</span></span></span><span class="line"><span class="cl"><span class="c1">// char *c = (char*) i; // 旧式的强制类型转换，等价
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>[[ch19-特殊工具与技术#<code>dynamic_cast</code>运算符|dynamic_cast]]</strong>：在运行时，将基类类型转换为派生类类型</li>
<li>旧式的强制类型转换本质上采用了static_cast, const_cast, reinterpret_cast中的一种，但是旧式的强制类型转化不够清晰，出了问题难以追踪</li>
</ul>
<h2 id="412-运算符优先级表">4.12 运算符优先级表</h2>
<p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=e8f768ae-b715-ec24-f9b5-63dc8a39ede3&amp;page=173&amp;rect=233.760,379.680,286.800,387.120">运算符优先级表</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch03 字符串、向量和数组</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch03-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 27 Feb 2024 15:56:30 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch03-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</guid>
      <description>第三章 字符串、向量和数组 3.1 using声明 可以对单个名字进行独立的using声明，比如using std::cin 头文件中不应该包含using声明。 3.2 string 初始化</description>
      <content:encoded><![CDATA[<h1 id="第三章-字符串向量和数组">第三章 字符串、向量和数组</h1>
<h2 id="31-using声明">3.1 using声明</h2>
<ul>
<li>可以对单个名字进行独立的using声明，比如<code>using std::cin</code></li>
<li>头文件中不应该包含<code>using</code>声明。</li>
</ul>
<h2 id="32-string">3.2 string</h2>
<p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=467e5bc5-4466-39dd-367f-26093fa90577&amp;page=102&amp;rect=221.040,426.480,318.960,433.680">初始化 string 对象的方式</a></p>
<ul>
<li>拷贝初始化（copy initialization）：<code>=</code></li>
<li>直接初始化（direct initialization）：<code>()</code>
<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=b66ffae2-0b25-c3f7-5000-10c3e96afd8b&amp;page=103&amp;rect=238.800,502.080,289.440,509.520">string 的操作</a></li>
<li><strong>字符串字面值和string是不同的类型</strong>（为了与C兼容）
<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=50978ba0-9d42-3196-6cdc-1a1b534f55e0&amp;page=108&amp;rect=219.600,570.720,310.560,577.920">cctype头文件中定义了一组标准库函数来处理string的字符</a></li>
</ul>
<h2 id="33-vector">3.3 vector</h2>
<p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=bcbb23e1-52b0-4bb1-9a3a-020d5bb6db24&amp;page=113&amp;rect=220.320,136.320,320.890,143.760">初始化 vector 对象的方法</a></p>
<ul>
<li>列表初始化： <code>vector&lt;string&gt; v{&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};</code> （C++11）</li>
<li>拷贝初始化：<code>=</code></li>
<li>直接初始化：<code>()</code></li>
<li>数组初始化：<code>vector&lt;int&gt; v(arr.begin(), arr.end());</code><br>
<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=3d543f80-e7cb-0287-ab58-cf692b1ef0c3&amp;page=117&amp;rect=229.930,167.290,301.210,174.730">vector 支持的操作</a></li>
<li>范围<code>for</code>语句内不应该改变其遍历序列的大小。</li>
<li><code>vector</code>对象（以及<code>string</code>对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。</li>
</ul>
<h2 id="34-迭代器iterator">3.4 迭代器iterator</h2>
<h3 id="使用迭代器">使用迭代器</h3>
<ul>
<li>养成使用迭代器和<code>!=</code>的习惯（泛型编程），循环判断中少使用<code>&lt;</code>（因为所有标准库迭代器都定义了<code>==</code>和<code>!=</code>，但是只有很少一部分定义了<code>&lt;</code>）。</li>
<li>但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</li>
</ul>
<h2 id="35-数组">3.5 数组</h2>
<h3 id="定义和初始化内置数组">定义和初始化内置数组</h3>
<ul>
<li>初始化：列表初始化
<ul>
<li>字符数组可以用字符串字面值进行初始化，结尾<code>\0</code>也拷贝到字符数组中</li>
</ul>
</li>
<li>数组不允许直接拷贝或赋值给另一个数组。
<ul>
<li>想复制可以使用<code>memcpy(void *dst, void *src, size_t size)</code></li>
</ul>
</li>
<li>复杂的数组声明，<strong>指向数组的指针</strong>，<strong>绑定到数组的引用</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span> <span class="p">};</span> <span class="c1">// arr是int[10]类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pa</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// pa是指向arr(int[10]类型)的指针，右边当然要取地址（虽然arr==&amp;arr）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="p">(</span> <span class="p">(</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span> <span class="c1">// *pa是数组指针解引用，即得到arr（即为数组名）;剩下部分即为通常的指针访问数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// cout&lt;&lt; (*pa)[i] &lt;&lt; &#34; &#34;;  // 或者这样访问元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ra</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="c1">// ra是绑定到arr(int[10]类型)的引用，右边即为对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="p">(</span><span class="n">ra</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// cout&lt;&lt; ra[i] &lt;&lt;&#34; &#34;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">},{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">},{</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// 左边是指向int[5]类型的指针，右边是&amp;m[0]（即为m）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="c1">// p+i表示指向哪一个int[5]类型，解引用即为者5个int数组的数组名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 等价写法：p[i][j], *(p[i] + j), *(*(p+i) + j)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">[</span><span class="mi">10</span><span class="p">])[</span><span class="mi">5</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">// 首先pp与[10]结合，表明这是一个数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 剩下的部分就是数组元素的类型：int (*)[5]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 即每个数组元素是一个指针，指向int[5]类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><a href="https://blog.csdn.net/stephen_999/article/details/128381419?spm=1001.2014.3001.5502">各类指针的详细介绍</a></li>
</ul>
<h3 id="数组与指针">数组与指针</h3>
<ul>
<li>很多情况下，编译器会将数组名自动替换为指向数组首元素的指针（相当于顶层const指针）</li>
<li>数组的类型推断
<ul>
<li>当auto变量基于数组名进行类型推断时，得到的是对应类型的指针</li>
<li>当使用decltype进行类型推断时，返回数组类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">ptr</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>  <span class="c1">//ptr是int*类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="n">arr2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="c1">// 相当于arr2的类型是int[3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">i</span><span class="p">:</span> <span class="n">arr2</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>  <span class="c1">// 输出是4 5 0而非4 5 3
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>数组名不是指针
<ul>
<li>证据一：sizeof(数组名) = 整个数组所占内存大小，如果数组名是指针，则为4或8</li>
<li>证据二：<strong>对数组名取地址得到的是整个数组的地址</strong>，如果数组名是指针，则对数组名取地址是另外一个地址（指针的地址）
<ul>
<li><code>arr</code>（数组首个元素的地址）与<code>&amp;arr</code>（数组地址）在值上是相等的，但是意义不同
<img src="https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-09-14-10:36:07.png" alt="image.png" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-09-14-10:53:38.png" alt="image.png" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
</li>
<li>函数传参和接受参数时，传递的都是指针，即使形参是<code>int arr[]</code>这样表示整个数组（可能情形是，外面传入的实参是数组名，但是形参实例化时自动转换为指针）
<ul>
<li>否则需要进行数组的拷贝，效率低</li>
<li><code>int arr[x]</code>中即使带数组容量，也会被忽略，x随便取都无所谓</li>
</ul>
</li>
<li>参考
<ul>
<li>好文章：<a href="https://blog.csdn.net/stephen_999/article/details/128404620?spm=1001.2014.3001.5502"># 指针与数组的联系与区别【一万六千字超详解】</a></li>
</ul>
</li>
</ul>
<h3 id="c风格字符串">C风格字符串</h3>
<ul>
<li>C风格字符串：以空字符<code>\0</code>结束的char数组</li>
<li>相互使用：
<ul>
<li>可以直接将char字符数组赋值给string字符串</li>
<li>字符串到字符数组：<code>const char *arr = str.c_str();</code>
<ul>
<li><code>str, arr</code>使用的是同一块数据</li>
</ul>
</li>
</ul>
</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=0936f168-007c-c836-4956-d0006aed1236&amp;page=135&amp;rect=234,416.890,313.930,424.330">C 风格字符串的函数</a>：<code>strlen, strcmp, strcat, strcpy</code>
<ul>
<li>传入参数必须是字符数组，注意列表初始化字符数组时必须最后带<code>\0</code></li>
</ul>
</li>
<li>字符串与字符数组：
<ul>
<li>字符串：使用字符指针指向只读数据段的一片区域</li>
<li>字符数组：放在栈中或者数据段</li>
<li><a href="https://blog.csdn.net/stephen_999/article/details/128381419?spm=1001.2014.3001.5502#t6">参考</a></li>
</ul>
</li>
</ul>
<h2 id="36多维数组">3.6多维数组</h2>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=8fe9e178-9a57-074e-9b52-6af58f495f7f&amp;page=138&amp;rect=69.120,174.960,437.760,196.330">多维数组阅读顺序由内向外</a></li>
<li>多维数组的初始化
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ib</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化部分元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">ic</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span> <span class="mi">0</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">4</span> <span class="p">}};</span> <span class="c1">// 初始化第一列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">id</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span> <span class="c1">// 初始化第一行
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>使用range-for语句时，除了最内层的循环外，外层循环的控制变量都应该是<strong>引用</strong>类型。
<ul>
<li>否则编译器自动将数组名转换为指针，无法使用range-for语法</li>
</ul>
</li>
<li>遍历：<code>int ia[2][4] = { {0, 1, 2, 3}, {4, 5, 6, 7} };</code>
<ul>
<li>range-for：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// row为int[4]类型，如果row不是引用类型（不加&amp;），编译器会自动将row从int[4]类型转变为指针，无法遍历指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">row</span><span class="p">:</span> <span class="n">ia</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">item</span><span class="p">:</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">item</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 不使用auto，写出变量类型：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">row</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span><span class="o">:</span> <span class="n">ia</span><span class="p">)</span> <span class="c1">// 理解山相当于：int[4] &amp;row
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">item</span><span class="p">:</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">item</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>使用i，j下标进行访问</li>
<li>使用指针访问
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">ia</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">q</span><span class="o">!=</span> <span class="o">*</span><span class="n">p</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">q</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 不使用auto：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">ia</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">q</span> <span class="o">!=</span> <span class="o">*</span><span class="n">p</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">q</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用类型别名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">arr</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// typedef int arr[4]; // 看起来比较奇怪
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="n">arr</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">ia</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">q</span> <span class="o">!=</span> <span class="o">*</span><span class="n">p</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">q</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h2 id="其他">其他</h2>
<h3 id="const指针和引用多维数组">const、指针和引用、多维数组</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r_m</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// r_m是一个绑定到int[4]数组的引用，
</span></span></span><span class="line"><span class="cl"><span class="c1">// int* (&amp;rr_m)[3] = m; // rr_m是一个绑定到(int*)[3]数组的引用，即绑定到大小为3的指针数组；但是m[0], m[1], m[2]各自都是一个int[4]数组的引用，m的类型是int[3][4]，类型都不匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rr_m</span><span class="p">)[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// rr_m是一个绑定到int[3][4]的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// p是一个指向int[4]数组的指针（即每个元素是int[4]数组，即m）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">pp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]};</span> <span class="c1">// m[0], m[1], m[2]每个是一维数组的数组名，只是编译器将数组名转换为指针，{m[0], m[1], m[2]}就变成了一个指针数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// int* (&amp;r)[3] = {m[0], m[1], m[2]}; // 报错，因为{m[0], m[1], m[2]}是右值，尝试将右值赋值给引用
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>也进行顶层const和底层const的区分</li>
</ul>
<h3 id="动态数组">动态数组</h3>
<ul>
<li>使用 <code>new</code>和 <code>delete</code>表达和c中<code>malloc</code>和<code>free</code>类似的功能，即在堆中分配存储空间。</li>
<li>定义： <code>int *pia = new int[n];</code></li>
<li>释放： <code>delete [] pia;</code>，注意不要忘记<code>[]</code>。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch02 变量和基本类型</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch02-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 27 Feb 2024 15:56:20 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch02-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</guid>
      <description>第二章 变量和基本类型 2.1 基本内置类型 1 2 sizeof(int) = 4; sizeof(long int) = 8; sizeof(long long int) = 8; sizeof(float) = 4; sizeof(double) = 8; sizeof(long double) = 16; 字面值常量（literal） 分多行书写字符串：C++ 允许在</description>
      <content:encoded><![CDATA[<h1 id="第二章-变量和基本类型">第二章 变量和基本类型</h1>
<h2 id="21-基本内置类型">2.1 基本内置类型</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="字面值常量literal">字面值常量（literal）</h3>
<blockquote>
<p>分多行书写字符串：C++ 允许在一条语句中自动连接多个双引号字符串（连接处无空格）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="nl">std</span><span class="p">:</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;wow, a really, really long string&#34;</span>
</span></span><span class="line"><span class="cl">       <span class="s">&#34;literal that spans two lines&#34;</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<h2 id="22-变量">2.2 变量</h2>
<h3 id="声明和定义">声明和定义</h3>
<ul>
<li>初始化（initialize）：初始化不是赋值
<ul>
<li>初始化 = 创建变量 + 赋予初始值</li>
<li>赋值 = 擦除对象的当前值 + 用新值代替</li>
</ul>
</li>
<li>变量的声明（declaration）和定义（define）
<ul>
<li>声明使得名字为程序所知；定义负责创建与名字关联的实体（分配内存）。</li>
<li>extern：表示符号的定义在模块外部，但如果包含了初始值，就变成了定义</li>
<li>C和C++关于声明和定义、强符号和弱符号、变量在ELF节中的位置规定似乎不同
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// a.c（或a.cpp）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// b.c（或b.cpp）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><code>gcc a.c b.c -o test1</code>：编译链接并运行，正常
<code>gcc a.cpp b.cpp -o test2</code>：链接出错：x多重符号定义</li>
</ul>
</li>
</ul>
<h3 id="作用域">作用域</h3>
<ul>
<li>同时存在同名的全局和局部变量时，在内层作用域中可以使用<code>::reused</code>显式访问全局变量reused。</li>
</ul>
<h2 id="23-复合类型">2.3 复合类型</h2>
<p>复合类型的含义：比如int型是基本类型，但是引用和指针（即&amp;、*称为<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=dab1f6ae-b5a8-1f74-69e0-5435b1e6c1d0&amp;page=77&amp;rect=262.413,167.040,307.736,175.680">类型修饰符</a>）可以再作为声明符的一部分（类型修饰符+变量标识符），构成复合类型</p>
<ul>
<li>类型修饰符是声明符的一部分，因此<code>int *a, b, &amp;c;</code>中只有a是指针，c是引用</li>
<li>但是理解上类型修饰符可以看作是类型的一部分，比如<code>int *&amp;pa=a;</code>中pa是对int*类型（指向int的指针）的引用</li>
<li>判断类型是从右向左读，最靠近变量名的类型修饰符说明这是一个什么复合类型，其余符号和基本类型共同说明指向/引用何种（复合）类型</li>
</ul>
<h3 id="左值引用">(左值)引用</h3>
<ul>
<li>引用必须初始化。</li>
<li>引用和它的初始值是绑定在一起的，而<strong>不是拷贝</strong>。一旦定义就不能更改绑定为其他的对象</li>
<li>引用只能绑定到对象上，不能与字面值或某个表达式的计算结果绑定</li>
<li>引用不是对象</li>
</ul>
<h3 id="指针">指针</h3>
<ul>
<li><code>void*</code>指针可以存放任意对象的地址。因无类型，仅操作内存空间，对所存对象无法访问（不能直接操作void*指向的对象）。</li>
<li>指针的类型要与所指向的对象严格匹配，两个例外：
<ul>
<li>可以使用指向常量的指针指向非常量</li>
<li>可以使用基类的指针指向派生类</li>
</ul>
</li>
<li>注意不能直接给指针赋值一串地址，给指针赋值应该是另一个指针或是变量取地址
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>    <span class="c1">// a是int型, p是int型的指针(int *)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>     <span class="c1">// q也是int型的指针, 将p赋值给q
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>  <span class="c1">// pp是指向int*类型变量的指针
</span></span></span><span class="line"><span class="cl"><span class="c1">// 不能是 int *pp = &amp;p, 即犯了直接把内存地址赋值给指针的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">**</span> <span class="o">*</span><span class="n">ppp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pp</span><span class="p">;</span> <span class="c1">// ppp是指向int**类型的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">***</span> <span class="o">&amp;</span><span class="n">r_ppp</span> <span class="o">=</span> <span class="n">ppp</span><span class="p">;</span>    <span class="c1">// r_ppp是指向int***类型的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;**</span><span class="n">pp</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;***</span><span class="n">ppp</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;***</span><span class="n">r_ppp</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><a href="https://blog.csdn.net/stephen_999/article/details/128381419?spm=1001.2014.3001.5502"># 各类指针的详细介绍</a></li>
</ul>
<h3 id="指针与引用">指针与引用</h3>
<ul>
<li>不同
<ul>
<li>指针存储一个变量地址，是一个对象；而引用只是变量的一个别名</li>
<li>引用在定义时必须要进行初始化，而指针不用</li>
<li>指针可以在任意时候改变指向，引用在初始化时绑定对象后就无法改变绑定的对象</li>
<li>sizeof(引用)=引用类型的大小，sizeof(指针)=4或8（地址空间所占字节数）</li>
<li>自加效果不同</li>
<li>有多级指针，但是没有多级引用</li>
<li>存在指向指针的指针，无引用的引用，不能定义指向引用的指针，可以定义指向指针的引用。</li>
</ul>
</li>
<li>编译器实际上是将对引用的操作翻译成对指针的操作
<ul>
<li>[# 简谈 C++ 中指针与引用的底层实现](# 简谈 C++ 中指针与引用的底层实现)</li>
</ul>
</li>
</ul>
<h2 id="24-const限定符">2.4 const限定符</h2>
<h3 id="初始化和const">初始化和const</h3>
<ul>
<li>const表示<strong>编译器限制</strong>该变量只能是只读的，修改变量时编译器会报错，因此const对象必须在一开始声明时进行赋值
<ul>
<li>在C中，可以使用指针指向const对象，进行修改（不要这样写）</li>
<li>在CPP中，使用非const指针指向const对象会报错（但是可以将const指针强转为普通指针进而修改，不要这样写）</li>
</ul>
</li>
<li>const变量默认不能被其他文件访问（作用域在本模块中）
<ul>
<li>如果非要共享const对象，不管是声明还是定义，都要加上extern关键字（因此C++中const变量从内部变量转变为extern const的外部变量，如果再初始化就变成强符号）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">-</th>
<th style="text-align:center">const</th>
<th style="text-align:center">extern const</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">global</td>
<td style="text-align:center">global</td>
<td style="text-align:center">global</td>
</tr>
<tr>
<td style="text-align:center">C++</td>
<td style="text-align:center">global</td>
<td style="text-align:center"><strong>local</strong></td>
<td style="text-align:center">global</td>
</tr>
</tbody>
</table>
<p><a href="https://blog.csdn.net/audio_algorithm/article/details/79420067">两个例子</a></p>
<ul>
<li>参考
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/55984950">const关键字到底该怎么用</a></li>
<li><a href="https://blog.csdn.net/hyb612/article/details/102868198">C++和C中的const关键字有何区别？</a></li>
<li>好文章：<a href="https://blog.csdn.net/bendanfly/article/details/95492816">const在C语言和C++中的区别</a></li>
</ul>
</li>
</ul>
<h3 id="引用和const">引用和const</h3>
<ul>
<li><strong>reference to const</strong>（对常量的引用，简称为常量引用）：指向const对象的引用
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span> <span class="c1">// 常量引用，指向常量的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span> <span class="c1">// 错误：非常量引用绑定一个常量对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>引用的类型必须与所引用对象的类型一致
<ul>
<li>例外：在初始化常量引用时允许用任意表达式作为初始值</li>
<li>因此，对const的引用（常量引用）可能引用一个非const的对象
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 可以修改a的值,但是不能通过引用r来修改值
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>原理：如果不一致，则中间使用临时量进行类型转换，引用指向这个临时量
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">dval</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span> <span class="c1">// 常量引用r1的类型int与所引用对象dval的类型double不同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/* 相当于：
</span></span></span><span class="line"><span class="cl"><span class="cm">const int tmp = dval; // 临时未命名对象（临时量）
</span></span></span><span class="line"><span class="cl"><span class="cm">const int &amp;r1 = tmp; // 因此修改dval的值，不会影响r1
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 除了初始化常量引用时，普通引用的类型必须与所引用对象的类型一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span> <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/* 相当于：
</span></span></span><span class="line"><span class="cl"><span class="cm">int tmp = dval;
</span></span></span><span class="line"><span class="cl"><span class="cm">int &amp;r2 = tmp; // 引用绑定的是一个临时量，C++规定非法
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">int变量</th>
<th style="text-align:center">const int常量</th>
<th style="text-align:center">double变量</th>
<th style="text-align:center">const double变量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int&amp;普通引用</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">const int&amp;常量引用</td>
<td style="text-align:center">√<br/>（可以修改int的值，但是不能通过引用来修改）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">warning<br/>（见<code>dval</code>）</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<h3 id="指针和const">指针和const</h3>
<ul>
<li><strong>pointer to const</strong>（指向常量的指针）：<code>const int i = 0; const int *p = &amp;i;</code>
<ul>
<li>变量p的类型是指针<code>*</code>，指向的类型是<code>const int</code></li>
<li>指向常量的指针可以指向一个非常量对象，但是不允许通过指针修改变量的值</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=1cb755a7-24e7-fbf3-704b-36dfb03ca19f&amp;page=83&amp;rect=275.760,153.540,324.970,163.210">底层 const</a>属性
<ul>
<li>底层const属性对元素赋值有影响：等号两边需要有相同的底层const资格，或者非常量转换为常量</li>
</ul>
</li>
</ul>
</li>
<li><strong>const pointer</strong>（常量指针）：<code>int i = 0; int *const ptr = &amp;i;</code>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=1a81ddb3-2c02-e84b-1d72-bcb87c8a7093&amp;page=83&amp;rect=378.240,168.730,430.800,179.770">顶层const</a>属性：这个类型的变量是只读的
<ul>
<li>对于常量指针而言，指针本身是常量（即指针固定指向某个地址）</li>
<li>顶层const属性对指向元素的拷贝无影响</li>
</ul>
</li>
<li>变量ptr的类型是常量指针<code>*const</code>，指向的类型是<code>int</code></li>
</ul>
</li>
</ul>
<h3 id="constexpr和常量表达式">constexpr和常量表达式</h3>
<ul>
<li>常量表达式：值不会改变，且在编译过程中就能得到计算结果的表达式。</li>
<li><code>constexpr</code>
<ul>
<li>背景：有时很难判断一个初始值是否为常量表达式（因为有的const对象的值直到运行时才能知道）</li>
<li>使用：<code>C++11</code>规定，将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量的表达式，constexpr对象的值必须在编译期间确定。
<ul>
<li>定义在函数体内部的变量，地址在编译器无法确定，无法用来初始化constexpr指针</li>
<li>定义在函数体外部的变量，地址固定，可以用来初始化constexpr指针</li>
</ul>
</li>
<li>constexpr指针相当于顶层const</li>
</ul>
</li>
<li>constexpr表示真正的常量，const表示只读</li>
</ul>
<h2 id="25-处理类型">2.5 处理类型</h2>
<h3 id="类型别名">类型别名</h3>
<ul>
<li>传统别名：使用typedef来定义类型的同义词：<code>typedef int* ptr</code></li>
<li>C++11 <strong>别名声明</strong>（alias declaration）： <code>using ptr=int*;</code></li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=b55f6917-ca80-3c5f-978c-4dbac344e382&amp;page=87&amp;rect=61.690,460.800,430.330,482.400">不能将类型别名像宏一样代回进行理解</a>，类型别名本身就表示一种类型</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">ptr</span> <span class="n">p_a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// p_a是const ptr类型的对象，即指向int的常量指针（顶层const）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// p是指向const int的指针（底层const）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">ptr</span><span class="o">*</span> <span class="n">pp_a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p_a</span><span class="p">;</span> <span class="c1">// pp_a是指向const ptr的指针，即指向int的常量指针的指针（底层const）
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="auto类型说明符">auto类型说明符</h3>
<ul>
<li>一条声明语句中只能有一个基本数据类型，但可以有复合类型（比如指针和引用）</li>
<li>复合类型自动推导
<ul>
<li>auto会忽略引用类型：
<ul>
<li><code>int i = 0, &amp;r = i; auto a = r;</code> 推断<code>a</code>的类型是<code>int</code>而非<code>int&amp;</code></li>
<li>用 auto 定义引用时，必须用&amp;指明要定义的是引用</li>
</ul>
</li>
<li>auto会忽略顶层const，但保留底层const：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">pi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">// 底层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span> <span class="c1">// *pi类型是const int，推断a的类型是int，auto忽略顶层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span> <span class="c1">// 如果希望是顶层const需要自己加const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pi</span><span class="p">;</span> <span class="c1">// 推断p的类型是const int*，auto保留底层const
</span></span></span><span class="line"><span class="cl"><span class="c1">// *p = 2; // 报错
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="decltype类型指示符">decltype类型指示符</h3>
<ul>
<li>背景：希望获得表达式的类型但是不需要值（编译器分析类型但是不求值）</li>
<li>使用
<ul>
<li>不会忽略顶层const和引用</li>
<li>当获得的类型是引用时，必须进行初始化</li>
<li>如果表达式不是一个变量，返回表达式结果对应的类型，比如<code>b</code></li>
<li>一些表达式比如【指针解引用、变量加括号、赋值操作】的结果均为引用类型</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="n">r_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// r_a是int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// b是int型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="n">r_a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// r_a2是int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">((</span><span class="n">a</span><span class="p">))</span> <span class="n">r_a3</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// r_a3是int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">)</span> <span class="n">r_a4</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//r_a4是int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="26-自定义数据结构">2.6 自定义数据结构</h2>
<h3 id="struct">struct</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 复杂写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">student</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">student</span> <span class="n">xiaoli</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 简单写法：使用typedef取别名，不用写struct student，而是直接写stu
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">student</span> <span class="p">{}</span> <span class="n">stu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">stu</span> <span class="n">xiaozhang</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="编写自己的ch01-开始头文件头文件">编写自己的[[ch01-开始#头文件|头文件]]</h3>
<h2 id="其他">其他</h2>
<h3 id="各种符">各种“符”</h3>
<ul>
<li>声明符（declarator）：类型修饰符（可有可无）+变量名（也称标识符）</li>
<li>类型修饰符：*，&amp;</li>
<li>标识符（identifier）：变量名</li>
<li>类型说明符（type specifier）：int，char，void等</li>
<li><a href="https://www.runoob.com/cplusplus/cpp-modifier-types.html">数据类型修饰符</a>：unsigned等</li>
<li><a href="https://www.runoob.com/cplusplus/cpp-modifier-types.html">类型限定符（qualifier）</a>：const，static等</li>
<li>访问限定符：public, private, protected</li>
</ul>
<h3 id="const和指针引用的组合">const和指针、引用的组合</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">ca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>常量指针（const pointer）：<code>int *const p = &amp;a</code>，是顶层const</li>
<li>指向常量的指针（pointer to const）：<code>const int *p = &amp;a;*</code>，是底层const</li>
<li>对常量的引用（reference to const）：<code>const int &amp;r = a;</code></li>
<li>常量引用（const reference）：不存在</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch01 开始</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch01-%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Tue, 27 Feb 2024 15:55:43 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch01-%E5%BC%80%E5%A7%8B/</guid>
      <description>第一章 开始 查看程序运行状态：echo $? 返回上一个命令的状态 程序正常运行，返回0，表示没有错误 返回值-1，打印255；返回值3，打印3；返回值</description>
      <content:encoded><![CDATA[<h1 id="第一章-开始">第一章 开始</h1>
<ul>
<li>
<p>查看程序运行状态：<code>echo $?</code> 返回上一个命令的状态</p>
<ul>
<li>
<p>程序正常运行，返回0，表示没有错误</p>
</li>
<li>
<p>返回值-1，打印255；返回值3，打印3；返回值-3，打印打印253</p>
</li>
</ul>
</li>
<li>
<p>endl：这是一个被称为操纵符（manipulator）的特殊值，效果是结束当前行，并将设备关联的缓冲区（buffer）中的内容刷到设备中。</p>
</li>
<li>
<p>UNIX和Mac下键盘输入文件结束符：<code>ctrl+d</code>，Windows下：<code>ctrl+z</code></p>
</li>
<li>
<p>库文件：</p>
<ul>
<li>库文件包含了一系列库函数，一般以二进制文件（链接库）的形式存放</li>
<li>源代码进行预处理编译汇编生成可重定位目标文件后，与库文件进行链接</li>
</ul>
</li>
</ul>
<h2 id="头文件">头文件</h2>
<ul>
<li>背景：不同代码写在不同模块中分别编译，链接时变量或函数需要“有且仅有一次定义，但可以多次声明”，头文件为使用模块的用户提供接口
<ul>
<li>extern进行外部变量的声明（如果对extern变量进行显式初始化则相当于进行了变量的定义）</li>
<li>使用头文件相当于将头文件中每个变量和函数的声明复制到源文件中</li>
<li>不同.cpp将可以include相同的头文件，如果.cpp编译汇编出来的目标文件进行链接，相当于进行多次声明</li>
</ul>
</li>
<li>使用：
<ul>
<li>可以将<strong>函数原型，#define预编译指令，const定义，结构声明，类声明，模板声明，内联函数</strong>放在头文件中，其定义放在对应.cpp文件中</li>
<li>头文件不会参与编译</li>
<li>使用时进行include，就相当于预处理器将extern声明插入到源代码</li>
<li>一般情况下，头文件不能放变量或函数的定义（因为可能被多个.cpp文件包含，进而链接时产生多重定义），特殊情况有：
<ul>
<li>可以定义const变量：const修饰的全局变量作用域只在当前文件中，因此不同文件中的同名const变量是不相同的两个变量，同时const保证了变量值都是常量（static变量虽然作用域只在当前文件中，但是变量值不是常量）</li>
<li>可以定义static变量和static函数</li>
<li>可以定义内联函数：编译器将内联函数进行展开，因此编译期就需要得到内联函数的完整定义</li>
<li>头文件可以定义类（否则编译器无法知道类的成员和偏移，也无法分配内存大小），而且建议头文件名字和类名一致：
<ul>
<li>对于数据成员，需要等到具体的对象创建时才被定义（分配空间）</li>
<li>对于函数成员，定义类时即被创建：可以将函数成员的实现放在类定义中，此时编译器视这个函数为内联的（不确定）；也可以将函数成员的实现单独放在一个.cpp文件中</li>
</ul>
</li>
</ul>
</li>
<li>头文件中的模板：<a href="https://zhuanlan.zhihu.com/p/387773355">模板实现为会放到头文件中</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/weixin_43354152/article/details/128651270">两种加载头文件的方式</a>：搜索顺序不同，先找到哪个就使用哪个
<ul>
<li>标准库的头文件使用<code>&lt;&gt;</code>：编译时指定的头文件目录（<code>-I</code>参数指定）、系统环境变量<code>CPLUS_INCLUDE_PATH</code>（C++）或<code>C_INCLUDE_PATH</code>（C）指定的目录、gcc默认目录
<ul>
<li>标准库的头文件、操作系统相关头文件、安装的特定库的头文件</li>
</ul>
</li>
<li>非标准库的头文件使用<code>&quot;&quot;</code>：源文件所在目录、<code>&lt;&gt;</code>头文件搜索目录</li>
</ul>
</li>
<li>防止重复包含
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef HEADFILE_H_ </span><span class="c1">// 判断是否定义过预处理变量HEADFILE_H_（即没有include该头文件）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define HEADFILE_H_ </span><span class="c1">// 将一个名字设定为预处理变量（即定义HEADFILE_H_变量）；预处理变量的名称需要唯一（无视作用域的规则），且保持全部大写。
</span></span></span><span class="line"><span class="cl"><span class="c1">// Definition of Sales_itemclass and related functions goes here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif </span><span class="c1">// 一旦检查预处理变量的结果为真，则执行后续操作，直到遇到#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>高级IDE中可以使用<code>#pragma once</code>来防止头文件的重复包含</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/369949041">C++头文件源文件详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346839633">C++理论梳理3——深刻理解头文件的作用</a></li>
<li>好文章：<a href="https://zhuanlan.zhihu.com/p/387773355">细说C++头文件</a></li>
</ul>
</li>
<li>more reading
<ul>
<li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/">C++风格指南-头文件</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/345399752">【C语言精华】头文件组织与包含原则！纯干货，这是一篇有价值的文章！</a></li>
<li><a href="https://blog.csdn.net/fengcq126/article/details/103016917">C语言中头文件包含的处理原则</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
