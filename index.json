[{"content":"Git配置相关 （全局）配置：如果是局部配置，每个仓库都需要进行配置\n1 2 3 4 5 6 7 8 # 设置全局配置 # git config --global user.name \u0026#34;zhangqingan\u0026#34; # git config --global user.email \u0026#34;zhangqingannn@bupt.edu.cn\u0026#34; # git config --global https.proxy http://127.0.0.1:7890 # git config --global https.proxy http://127.0.0.1:7890 # 清除全局配置 # git config --global unset user.name # git config --global unset user.email 如果是针对仓库的局部配置\n1 2 3 git config --local user.name \u0026#34;zhangqingan\u0026#34; git config --local user.email \u0026#34;zhangqingannn@bupt.edu.cn\u0026#34; # git config --local --list 生成密钥对\n1 2 3 4 ssh-keygen -t rsa -C \u0026#34;zhangqingannn@bupt.edu.cn\u0026#34; # 并且后续生成密钥的位置自定义，注意win上这里是一个目录，linux上是文件名 ssh-keygen -l -f key # 查看密钥的contents（SHA256+comments） 添加私钥\n1 2 3 4 # ssh-agent bash ssh-add private_key # 将私钥添加到本地 ssh-add -l # 查看当前添加的私钥 ssh agent详解\n修改配置文件：修改~/.ssh/config\n1 2 3 4 5 Host github(bupt) User QinganZhang HostName ssh.github.com IdentityFile /home/zqg/.ssh/github/bupt Port 443 # or 22 reference and more reading\nGit多用户配置 如何为Git设置代理 相关概念 顶层概念：\nWorkspace：工作区，本地的工作目录 Repository：包含.git目录的工作区，其中.git为版本库，其中保存了stage暂存区、第一个分支main、指向main的指针HEAD Index/Stage：暂存区 Remote：远程仓库 底层概念：from missing semester中的Git\n文件称为Blob对象（数据对象），目录称为tree，每个commit即为一个对文件和目录的快照的指针（保存了当前的整个仓库，或者说追踪最顶层的树）\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 文件就是一组数据 type blob = array\u0026lt;byte\u0026gt; // 一个包含文件和目录的目录 type tree = map\u0026lt;string, tree | blob\u0026gt; // 每个提交都包含一个父辈，元数据和顶层树 type commit = struct { parent: array\u0026lt;commit\u0026gt; // 一个commit可能有多个parent author: string message: string snapshot: tree // 追踪最顶层的树 } 对象可以是文件、目录或者commit，对象通过SHA-1哈希进行按名存取（文件和目录好说，但是commit就不好访问了，因此统一使用SHA-1哈希）\n1 2 type object = blog | tree | commit objects = map\u0026lt;string, object\u0026gt; 为了方便好记，使用引用来指向最近一次的commit，而不是来记一串哈希值。因此，分支就是可变的引用，而标签就是绑定到特定commit的引用，HEAD指向当前的commit\n1 references = map\u0026lt;string, string\u0026gt; 因此，Repository保存的就是对象和引用。\n前面说commit是一个对文件和目录的快照，是通过向暂存区进行若干次操作，确认保存操作的结果，即形成一个快照\n其他概念：\ntrack/untrack：文件或目录是否纳入到git的版本控制范围内 基础操作 常用操作 git init -b main：创建.git文件夹，将当前目录变成一个仓库，默认分支为main\ngit add：将文件添加到暂存区（stage），相当于创建了快照，否则文件就是untracked的\ngit diff：比较当前工作区和暂存区快照之间的差异，即修改之后还没有暂存起来的变化内容 git commit -m \u0026quot;comment\u0026quot;：将暂存区的修改提交到分支（多次add之后进行一次commit），commit就是一个快照\ngit diff --staged：比较暂存区快照和最近一次commit之间的差异 git commit -a -m \u0026quot;comment\u0026quot; ：将所有跟踪过的文件暂存起来一起提交，跳过了git add步骤 git status：查看当前文件夹中文件的状态\ngit rm --cached \u0026lt;file\u0026gt;：取消对file的跟踪\ngit diff：\ngit diff命令，官方文档 git diff输出结果解读 git diff输出中 \\ No newline at end of file的含义 git log：查看commit历史，最近的排在最上面\n-p (--path)：显示每次提交所引入的差异（按补丁的格式输出） 补丁：即两次文件的差异 --stat：显示每次提交的简略统计信息 --ptetty：设置输出模式，可以自定义输出格式 --decorate：查看各个分支当前所指向的对象 --graph： -n：限制输出长度 --since, --until --grep：搜索提交说明中的关键字 -S：pickaxe选项，接受一个字符串，搜索那些添加或删除了该字符串的提交 -- path：输出某些文件或目录的历史提交，注意这个参数是放在最后的（因此用两个短线隔开） 版本控制 版本回退\ngit reset --hard HEAD^：返回到最近一次commit HEAD指向最近一次的commit，HEAD^和HEAD^^分别表示上一个commit和上上个commit git reset --hard commitId：返回到特定的commit git log --pretty=oneline ：显示所有提交过的commit，不包括已经回退的commit记录 怎么才能看懂git log的线 git reflog：显示所有提交过的commit，包括回退的操作，比如回退之后又反悔了，需要使用reflog来找到新版本对应的commit id 撤销修改\n如果只是在本地工作区修改了，还没有git add：git restore \u0026lt;file\u0026gt;或者git checkout -- \u0026lt;file\u0026gt; 如果在本地工作区修改之后，已经git add：git restore --staged \u0026lt;file\u0026gt;或者git reset HEAD \u0026lt;file\u0026gt; 如果已经git commit，则进行版本回退 重新提交：如果上一次commit完成后，发现漏了些文件，此时先git add，然后使用git commit --ament，这样只会有一次提交，后一次的提交会覆盖前一次的提交\n远程库 对远程库的操作实际上都是对远程库中远程分支的操作，默认远程库为origin，远程分支为 与当前本地仓库分支 同名的远程分支\n远程库的几种使用场景：\n克隆别人的仓库：git clone默认只有main分支，使用git checkout -b dev origin/dev在本地创建dev分支，并且与远程的dev分支关联起来\n自己在GitHub上新建一个仓库，然后clone下来进行开发\n自己在本地目录下，先git init创建本地仓库，然后将本地仓库与远程仓库关联起来：git remote add \u0026lt;shortname\u0026gt; \u0026lt;url\u0026gt;\n\u0026lt;url\u0026gt;支持多种协议，\u0026lt;shortname\u0026gt;即代表了该url\n一般远程库的名字就叫origin\n可以关联多个远程库，比如本地仓库关联一个共有的和一个私有的仓库\n查看远程库信息：git remote -v\n远程库可能有多个 获取远程库的更新：\ngit fetch \u0026lt;remote\u0026gt;：只会将远程库的更新下载到本地仓库，不会自动进行合并 git pull：如果当前分支设置了跟踪远程分支，则git pull会拉取更新，并自动进行合并。如果有冲突，需要手动解决冲突。 详解git pull和git fetch的区别 将本地库的内容推送到远程库：git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;\n默认remote是origin，默认将本地分支推送到远程的同名分支上 git push -u origin main：第一次push时，远程库是空的，此时不但会将本地库的内容推送到远程库，而且将本地的main分支和远程库的main分支关联起来 如果他人先于你push到远程，你的push会被拒绝，此时需要拉取更新，手动修改冲突的部分，合并之后才能再push 查看某个远程仓库：git remote show \u0026lt;remote\u0026gt;\n远程仓库重命名：git remote rename old-name new-name\n解除本地和远程库之间的关联关系：git remote rm origin\n分支管理 分支是指向commit的可变指针，默认名字为main，main分支在每次提交时都自动向前移动\nHEAD是一个指向当前所在的本地分支的指针（可以想象为当前分支的别名）\n基本操作 注意这些操作都是在本地仓库的\n创建分支：git branch dev\n--merged：查看哪些分支已经合并到当前分支 --no-merged：查看所有包含未合并工作的分支（即没有汇聚到当前分支的那些分支） 重命名当前分支：git branch -M newname\n切换分支：git checkout dev\n创建并切换分支：git checkout -b dev或者git switch -c dev\n合并指定分支到当前分支：git merge dev\n如果当前分支main和待合并分支dev存在冲突，此时进行了合并，但是没有创建一个新的commit，需要先解决冲突，再手动进行commit，解决冲突就是手动将git merge失败的文件手动进行编辑，可以使用git status查看unmerged的文件，然后使用git merge --continue继续合并过程。 Git官方文档-3.2分支的新建与合并 Git冲突详细处理步骤及案例 如何避免Git冲突 git解决冲突（超详细图文版及常用命令） 因此使用分支时应该在main分支中生成多个dev分支，最后选择合适的dev分支进行合并，而非直接在main分支上进行修改 默认合并分支时使用Fast forward模式，此时删除分支之后，会丢掉分支信息。如果禁用fast forward模式（--no-ff），git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 fast forward模式的含义：比如dev是master的直接后继，即master之后没有分叉，此时将dev merge到master上时，直接移动master的指针即可 查看分支：git branch\n-vv：列出每一个分支正在跟踪的远程分支，以及ahead和behind信息 如果需要查看最新的信息，则需要更新远程的信息，git fetch --all; git branch -vv 删除分支：git branch -d dev\n如果当前分支还没有被合并，而且需要删除当前分支，需要使用git branch -D dev强行删除 远程分支 远程跟踪分支是远程分支状态的引用，相当于书签。比如远程仓库命名为origin，拉取该仓库的main分支，因此本地就将对应的commit叫做origin/main，在本地仓库同样有一个main分支，比如本地进行多个commit会ahead of origin/main。Git官方文档-3.5远程分支\n比如当拉取本地没有的、位于远程的新的分支b时，本地只会有一个不可修改的origin/b指针，本地不会自动生成一份可编辑的副本。因此，需要使用git merge origin/b将远程分支b合并到本地当前分支，或者git checkout -b b origin/b将远程分支拉取到本地的新分支b上（如果本地仓库没有分支b，而且远程分支只有一个叫做b的分支，则一个快捷方式为：git checkout b） 修改或设置跟踪的上游分支 ：git branch -u origin/b 删除远程分支：git push origin --delete b 这个操作只是从服务器上移除这个指针，实际物理删除需要等到过一段时间git服务器进行垃圾回收时，因此误删通常是容易恢复的 最佳实践-修复Bug 背景：比如main分支上有一个bug，但是当前在dev分支上，而且针对dev的工作还没有完成（即当前不能commit到dev分支，从而清空status） 大致流程为： 使用git stash将当前工作区保存起来，此时工作区恢复到最近一次commit时的状态 然后修复bug：先切换到main分支，创建修复bug的分支，修复bug，然后再合并到main分支，同时也需要将修复bug这个commit合并到其他dev分支，切换到dev分支，然后git cherry-pick git cherry-pick commit_id：复制一个特定的commit到当前分支（相当于在dev分支上将修复bug的操作重新进行commit，因此生成的commit id和在main分支上的commit id不同） 修复完bug再恢复当前工作区 查看暂存的工作区：git stash list 恢复暂存的工作区： git stash apply：恢复之前保存的工作区，但是保存的工作区内容还在stash中，需要使用git stash drop进行删除。可以恢复指定的工作区：git stash apply stash{0} git stash pop：恢复工作区的公式，也将保存在stash中的内容删除 Rebase 用来将一组commit按照顺序（即某一分支上的commit）合并到一个特定的commit后面（即另一个分支的最后）\n万能公式：git rebase --onto \u0026lt;base\u0026gt; \u0026lt;start\u0026gt; \u0026lt;end\u0026gt; 变基原则：如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，则不要进行变基 参考 Git官方文档-3.6变基 万能公式来源：强烈推荐：git rebase有哪些用法？elpie-kay的回答 标签管理 标签就是指向commit的指针，但是分支可以移动，标签不能移动\n在关键commit节点，使用commit id不方便，因此标签绑定到该commit id\n打标签：git tag v1.0\n在某个特定的commit上打tag，并添加说明：git tag -a v1.0 -m \u0026quot;comments\u0026quot; commitId 这里说的标签指的是轻量标签（某个特定提交的引用），附注标签指的是上面添加的说明 查看所有标签：git tag\n标签不是按照时间顺序列出，而是按照字母排列列出 查看标签信息：git show v1.0 删除标签：git tag -d v0.9可以删除本地标签\n删除远程标签时，先从本地删除，然后使用从远程删除。从远程删除： 第一种方法：git push origin :refs/tags/v0.9（即将冒号前面的空值推送到远程） 第二种方法：git push origin --delete v0.9 推送标签到远程：git push origin v1.0\n默认情况下git push不会将标签推送到远程仓库上 一次性推送所有标签到远程：git push origin --tags 检出标签：git checkout \u0026lt;tag\u0026gt;，即将HEAD移动到指向某个标签，此时仓库处于detached HEAD状态\n自定义Git 忽略特殊文件.gitignore 一些.gitignore模板\n虽然某个文件可以匹配到gitignore的规则，但是需要强制添加：git add -f myfile\n或者某个文件应该可以添加但仍然被忽略了，说明gitignore规则有问题，找出对应的规则条目：git check-ignore -v myfile\n在线生成gitignore文件：Gitignore Online Generator\n配置别名 几个例子：\ngit config --global alias.st status\ngit config --global alias.unstage 'restore --stage'：将add到暂存区的修改撤销掉\ngit config --global alias.last 'log -1'：显示最后一次提交信息\ngit config --global alias.lg \u0026quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset' --abbrev-commit\u0026quot;：自定义git log显示\n删除别名时，只需要在仓库的配置文件.git/config或是用户的配置文件.gitconfig的[alias]段落中，删除掉特定的行即可\n工作流 向一个项目贡献 提交准则 提交不应包含trailing whitespace。git apply应用补丁时会检测空白错误,默认情况下,尾部空白,包含空白的空行,初始tab缩进之后紧跟的空白字符会被认为是错误。参考\n在git apply patch时，应该先git diff --check，将会找到可能的whitespace errors并列出来 By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.\n—— from git-diff\n让每个commit解决一个问题，不要多个问题混在一个commit中\n重视写commit message\n一个好的commit message模板 私有开发项目 Git文档中一个私有开发项目的例子\n私有管理团队 多个开发者在feature分支上工作，只有整合者才能将feature分支merge到master分支\nGit文档中一个私有管理团队的例子\n派生的公开项目 先fork公开项目，然后自己进行修改，最后通过Pull Request请求合并\nGit文档中一个派生的公开项目的例子\n通过邮件的公开项目 使用git format-patch生成mbox文件，它将每一个提交转换为一封电子邮件，其中保留了所有的提交信息。最后通过git send-email发送补丁。\n维护项目 在主题分支中工作 应用来自邮件的补丁 使用git apply应用补丁 补丁是通过git diff生成的，可以对补丁进行检查git apply --check git apply要么全部应用补丁，要么全部不应用，不会部分应用补丁 git apply之后，需要手动暂存并提交 使用git am应用补丁（推荐） 补丁是通过git format-patch生成的，此时补丁中包含了作者信息和commit message，因此更加推荐 git am是为了读取mbox文件而构建的，mbox是一种用来在单个文本文件中存储一个或多个电子邮件消息的简单纯文本格式 git am会自动创建一个新的提交，作者信息和提交消息来自于mbox文件，并自动应用mbox指向的补丁 如果发生冲突，则同样需要手动进行修改，然后暂存，再git am --resolved继续应用下一个补丁 git生成patch和打patch 检出远程分支 背景：别人fork了自己的仓库，并且在某个分支上进行了修改，想提交贡献，此时我得到了它的仓库的URL和对应的分支 如果想与他人建立长期的合作交流：将其仓库添加为远程仓库，fetch到本地并在本地checkout到该分支，进行测试 如果别人只是偶尔提供一个贡献 直接pull到本地（不会将该URL添加为远程仓库），然后切换分支并进行测试 或者使用电子邮件来接受patch（或者使用托管服务） 确定引入了哪些东西 检查main分支未包含的commit，比如检查某个分支contrib上引入的修改：git log contrib --not main\n如果想具体查看contrib分支上相对于原来main，到底有什么区别（即diff），使用git diff main...contrib，即对contrib分支的最新提交和两个分支的最近共同祖先进行比较（注意三个点）\n因为在进行contrib分支上的工作时，main分支可能同时继续向前，diff比较时的main分支应该为原来的位置，即为contrib和现在main分支的最近共同祖先 将贡献的工作整合进来 合并工作流：将主题分支合并到main分支，然后删除主题分支\n如果项目很重要，可以使用两阶段循环合并，即维护两个长期分支（main和develop分支），新代码首先合并到develop分支，打标签发布时才将main分支更新到稳定的develop分支 为了保持线性的提交历史，可以在 main分支上对贡献来的工作进行变基而不是直接合并。另一种类似效果的方式是，提取分支的补丁，然后应用到当前分支上\nRerere：重用已记录的冲突解决方案，是一种简化冲突解决的方法。当启用 rerere 时，Git 将会维护一些成功合并之前和之后的镜像，当 Git 发现之前已经修复过类似的冲突时， 便会使用之前的修复方案，而不需要你的干预。\n发布 为发布打标签 生成一个构建号 创建一个归档文件 制作提交简报 基于Github的工作流 常见问题 ssh -T git@github.com 连接超时 示例：\nssh -T git@github.com的含义：\n解决方法：\n如果使用ssh协议：修改HostName或者修改Port\n在.ssh文件夹下的config文件中修改：参考\n1 2 3 4 Host github.com HostName ssh.github.com User xxx IdentityFile xxx 如果使用https协议：参考\n","permalink":"https://qinganzhang.github.io/posts/git%E7%AC%94%E8%AE%B0/","summary":"Git配置相关 （全局）配置：如果是局部配置，每个仓库都需要进行配置 1 2 3 4 5 6 7 8 # 设置全局配置 # git config --global user.name \u0026#34;zhangqingan\u0026#34; # git config --global user.email \u0026#34;zhangqingannn@bupt.edu.cn\u0026#34; # git config --global https.proxy http://127.0.0.1:7890 # git config --global","title":"Git笔记"},{"content":"[toc]\ntags：【双指针】，【前缀和】，【原地哈希】\n【好题】，【不会】，【重要】\n方法 双指针 前后定长双指针 前后快慢双指针 左右双向双指针 611.有效三角形的个数 方法一：二重循环a、b，对c进行二分查找（查找最后一个满足a+b\u0026lt;c的c） 方法二：遍历c，左右双指针表示a(nums[i])和b(nums[j])，参考 if(nums[i] + nums[j] \u0026gt; c) ，此时有j-i个三角形，j向左走（i向右走无用） if(nums[i] + nums[j] \u0026lt;= c) ，此时有0个三角形，i向右走（j向左走无用） 11.盛最多水的容器：盛水体积只取决于左右两隔板的高度（木桶理论） 区别于接雨水，雨水可能分布在不连续的凹陷处 两分支双指针 165.比较版本号 滑动窗口 904. 水果成篮\n基于双指针的滑动窗口 必须使用滑动窗口保证水果是连续的，如果只使用哈希表，则可能出现中间有中断的情况 76. 最小覆盖子串：代码\n对t统计词频，得到相同的两个ump：tump和tmp_ump 只移动右指针，找到s中第一个包含t的区间 移动右指针的过程中，逐步递减并erasetmp_ump中的元素，直到tmp_ump为空，此时就找到了s中第一个包含t的区间，同时维护区间的词频win_ump 窗口进行移动：将c=s[left++]从win_ump中减一，同时左指针向右移动了一位， 如果此时win_ump[c] \u0026gt;= tump[c]，说明c不在t中，或者c是t中是多余重复的，因此continue 如果此时win_ump[c] \u0026lt; tump[c]，说明c是t中的，需要右指针向右移动，再次找到c字符，因此得到了新的窗口 技巧：可以s+=' '，避免最后跳出循环还要移动左指针， 3.无重复字符的最长子串 【重要】\n1004.最大连续1的个数Ⅲ\n两种思路 复杂的代码：维护窗口内0的数量，但同时也分情况讨论左右断点的情况 简洁的代码：找出一个最长的子数组，该子数组中最多有k个0，因此只需要维护窗口内0的数量即可 数组【二刷】 模拟题 498.对角线遍历：i+j==level\n48.旋转图像\n最重要的是找到原来(i,j)位置的元素，旋转之后在什么位置（(j,n-i-1)） 矩阵变换的方法也是从上面的对应关系来的 先转置(j,i)，再水平翻转(j,n-i-1) 或者先垂直翻转(n-i-1,j)，再转置(j,n-i-1) 54.螺旋矩阵 和 59. 螺旋矩阵 II\n按圈遍历，设定四个逐步减小的边界 每圈遍历中，判断新到达的位置是否超出边界，若是则改变方向 (二分)查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 假设v非递减 int find_first_ge(vector\u0026lt;int\u0026gt;\u0026amp; v, int target) { // 返回第一个\u0026gt;=target的元素的索引（lower_bound） int left = 0, right = v.size(), mid = -1; while(left \u0026lt; right){ mid = left + (right - left) / 2; if(v[mid] \u0026gt; target) right = mid; // target is in left part else if(v[mid] \u0026lt; target) left = mid + 1; // target is in right part else right = mid; // v[mid] == target, } return left; // now left == right } int find_first_gt(vector\u0026lt;int\u0026gt;\u0026amp; v, int target) { // 返回第一个\u0026gt;target的元素的索引（upper_bound） int left = 0, right = v.size(), mid = -1; while(left \u0026lt; right){ mid = left + (right - left) / 2; if(v[mid] \u0026gt; target) right = mid; else if(v[mid] \u0026lt; target) left = mid + 1; else left = mid + 1; // difference } return left; } int find_last_le(vector\u0026lt;int\u0026gt;\u0026amp; v, int target) { // 返回最后一个\u0026lt;=target的元素的索引 return find_first_gt(v, target) - 1; // 即第一个\u0026gt;target的元素的前一个位置 } int find_last_lt(vector\u0026lt;int\u0026gt;\u0026amp; v, int target) { // 返回最后一个\u0026lt;target的元素的索引 return find_first_ge(v, target) - 1; // 即第一个\u0026gt;=target的元素的前一个位置 } 240.搜索二维矩阵Ⅱ 方法一：从右上开始，按照搜索二叉树的逻辑查找 方法二：每行进行一次二分查找 162.寻找峰值 方法一：分治，类似归并排序，递归找最大值 方法二：类似二分查找，判断nums[mid]与nums[mid+1]的大小关系（即判断中点是上坡还是下坡），从而修改左右索引 原理是因为开始时left和right都是最小值，此后mid部分永远是高点 细节：在函数体中，left与right不相等，因此mid永远不会等于right，同时left与right是左闭右闭，代码 搜索旋转排序数组系列：是否有重复数字 33.搜索旋转排序数组：首先二分找到分界点，然后在左边或者右边再次进行二分（此时范围是有序的） 81.搜索旋转排序数组Ⅱ：尝试将问题转换到33.搜索旋转排序数组，我的题解 154.寻找旋转排序数组中的最小值Ⅱ 排序 快排：在partition时，如果选left作为pivot，则需要先移动右边的指针，原理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void qSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ // [left, right] if(left \u0026gt;= right) return ; if(left+1 == right){ if(nums[left] \u0026lt;= nums[right]) return ; else {swap(nums[left], nums[right]); return ;} } // 左中右，取中间大小的值，放在最左边 int begin = left, end = right, mid = (left + right) / 2; int pivot = max(min(nums[left], nums[right]), nums[mid]); if(nums[right] == pivot) swap(nums[left], nums[right]); else if(nums[mid] == pivot) swap(nums[left], nums[mid]); // 注意元素是覆盖的 while(left \u0026lt; right){ while(left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026gt;= pivot) --right; nums[left] = nums[right]; while(left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026lt;= pivot) ++left; nums[right] = nums[left]; } // now: left == right nums[left] = pivot; // 缩小中轴范围，尤其针对重复元素多的数组 while(left \u0026gt; begin \u0026amp;\u0026amp; nums[left] == nums[left-1]) --left; while(right \u0026lt; end \u0026amp;\u0026amp; nums[right] == nums[right+1]) ++right; qSort(nums, begin, left-1); qSort(nums, right+1, end); } 归并排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 归并排序需要辅助数组，因为前后两个有序数组是连着的， void mergeSort(vector\u0026lt;int\u0026gt;\u0026amp; out, int begin, int end, vector\u0026lt;int\u0026gt;\u0026amp; in){ // [begin, end) if(begin \u0026gt;= end || begin+1 == end) return ; int mid = (begin + end) / 2; mergeSort(out, begin, mid, in); // [begin, mid) mergeSort(out, mid, end, in); // [mid, end) // now left part and right part are all sorted, merge them into out int i = begin, j = mid, k = begin; while(i \u0026lt; mid \u0026amp;\u0026amp; j \u0026lt; end){ if(in[i] \u0026lt;= in[j]) out[k++] = in[i++]; // stable else out[k++] = in[j++]; } while(i \u0026lt; mid) out[k++] = in[i++]; while(j \u0026lt; end) out[k++] = in[j++]; // copy out back to in for(int s = begin; s \u0026lt; end; ++s) in[s] = out[s]; } 堆排序\n第一种方法：数组原地构建最大堆，数组原地进行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void heapSort(vector\u0026lt;int\u0026gt;\u0026amp; nums){ buildMaxHeap(nums); int len = nums.size(); for(int i = len-1; i \u0026gt;0; --i){ swap(nums[0], nums[i]); // 将最大堆的首元素（最大元素）放在数组后面位置 adjust(nums, 0, --len); // 首元素变了，因此需要调整，同时堆的长度减一 } } void buildMaxHeap(vector\u0026lt;int\u0026gt;\u0026amp; nums){ int n = nums.size(); for(int i = n/2-1; i \u0026gt;= 0; --i){ // n/2-1是最后一个非叶节点，依次向上检测和调整每个非叶节点 adjust(nums, i, n); } } void adjust(vector\u0026lt;int\u0026gt;\u0026amp; nums, int idx, int len) { // 当前节点的索引为idx，在[0, len)范围内是最大堆 while(idx * 2 + 1 \u0026lt; len){ int leftSon = idx * 2 + 1; int rightSon = idx * 2 + 2; int largeIdx = idx; // largeIdx指向{根节点，左孩子，右孩子}中较大的值 if(leftSon \u0026lt; len \u0026amp;\u0026amp; nums[leftSon] \u0026gt; nums[idx]) largeIdx = leftSon; if(rightSon \u0026lt; len \u0026amp;\u0026amp; nums[rightSon] \u0026gt; nums[largeIdx]) largeIdx = rightSon; if(largeIdx != idx){ swap(nums[idx], nums[largeIdx]); idx = largeIdx; }else break; } } 第二种方法：数组构建最小堆，依次弹出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 手写堆 class minHeap{ private: vector\u0026lt;int\u0026gt; heap; int len = -1; public: minHeap(vector\u0026lt;int\u0026gt;\u0026amp; nums): heap(nums) { len = heap.size(); // build minHeap for(int i = n/2-1; i \u0026gt;= 0; --i) adjust(i); } void adjust(int idx){ while(idx * 2 + 1 \u0026lt; len){ int leftSon = idx * 2 + 1; int rightSon = idx * 2 + 2; int largeIdx = idx; // largeIdx指向{根节点，左孩子，右孩子}中较大的值 if(leftSon \u0026lt; len \u0026amp;\u0026amp; heap[leftSon] \u0026gt; heap[idx]) largeIdx = leftSon; if(rightSon \u0026lt; len \u0026amp;\u0026amp; heap[rightSon] \u0026gt; heap[largeIdx]) largeIdx = rightSon; if(largeIdx != idx){ swap(heap[idx], heap[largeIdx]); idx = largeIdx; }else break; } } int top() { return heap[0];} // return min value void pop() { swap(heap[0], heap[--len]); adjust(0); } }; // 或者调用优先队列 vector\u0026lt;int\u0026gt; heapSort(vector\u0026lt;int\u0026gt;\u0026amp; nums){ priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; for(int n: nums) pq.push(n); vector\u0026lt;int\u0026gt; ans; while(!pq.empty()) {ans.push_back(pq.top()); pq.pop();} return ans; } 179.最大数\n巧妙的自定义排序规则：a+b\u0026lt;b+a 215.数组中的第k个最大元素 【重要】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int begin, int end, int k){ // [begin, end), 快排逻辑 if(begin+1 == end) return nums[begin]; if(begin+2 == end){ if(k == begin) return max(nums[begin], nums[begin+1]); if(k == begin+1) return min(nums[begin], nums[begin+1]); } int left = begin, right = end-1; // [left, right] int pivot = nums[left]; while(left \u0026lt; right){ while(left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026lt;= pivot) --right; nums[left] = nums[right]; while(left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026gt;= pivot) ++left; nums[right] = nums[left]; } int mid = left; // now left == right nums[mid] = pivot; if(k-1 == mid) return pivot; else if(k-1 \u0026lt; mid){ while(mid \u0026gt; k-1 \u0026amp;\u0026amp; nums[mid] == nums[mid-1]) --mid; return findKthLargest(nums, begin, mid+1, k); // 注意这里还是传入[begin, mid+1)而非[begin, mid)，因为经过while优化，此时mid可以退到和begin位置相同 } else{ // k-1 \u0026gt; mid while(mid \u0026lt; k-1 \u0026amp;\u0026amp; nums[mid] == nums[mid+1]) ++mid; return findKthLargest(nums, mid, end, k); // 注意这里还是传入[mid, end)而非[mid+1, end) } } 剑指40.最小k个数：快排逻辑\n套路题 14.最长公共前缀 按行比，按列比，都行 209.长度最小的子数组 方法一：贪心+双指针 方法二：前缀和+二分 细节较多：前缀和是inclusive的还是exculsive的（这里用的是exculsive的），二分找的是第一个大于val的位置 剑指21.调整数组顺序使奇数位于偶数前面 如果不需要保持奇数/偶数内部的相对顺序，左右双指针向内走 169.多数元素 投票法：维护一个元素值value和计数值cnt，数组元素等于value时累加cnt，不等于value时递减cnt，当cnt==0时更新value 可以保证最后众数的cnt至少为1 128.最长连续序列 哈希表unordered_map\u0026lt;int, bool\u0026gt;（bool表示是否使用过该数字），元素往前往后分别试探 31.下一个排列 ： 题解 与556.下一个更大元素Ⅲ相同 从后往前遍历，找到一个最长的后缀，这个后缀是逆序的（即该后缀从前往后看递减，从后往前看递增） 该最长后缀前面一个元素nums[idx]，是小于最长后缀的第一个元素的 在该最长后缀中，找到最后一个\u0026gt;nums[idx]的元素nums[pos]，然后交换（因此最长后缀又变长了一位） 最后reverse[idx+1, end)，因此数组前面部分不动，后面部分得到了下一个排列 综合 560.和为K的子数组：【前缀和】+【哈希表】 通过前缀和可以将区间和转换为两个点的查询 通过哈希表记录遍历过的位置的前缀和（value是特定前缀和的计数） 现在已知一个点和中间差值，通过哈希找到另一个点 区别209.长度最小的子数组 字符串 模拟 415.字符串相加 43.字符串相乘 443.压缩字符串 6.Z字形变换 468.验证IP地址：先判断有.还是:，然后根据.或者:分割之后，逐段判断 7.整数反转：用字符串表示数字 166.分数到小数：首先注意符号问题，然后注意能否整除，最后逐次*10模拟竖式除法 套路 翻转字符串的妙用：局部翻转后再整体反转（或反过来），达到子串位置颠倒的效果\n151. 反转字符串中的单词\nLCR 182. 动态口令\nKMP系列\n实现strStr 链表【二刷】 206. 反转链表\n注意递归写法\n1 2 3 4 5 6 7 ListNode* reverseList(ListNode* head) { // 递归，返回反转链表的头 if(head==nullptr || head-\u0026gt;next==nullptr) return head; // 当前是空节点，或者是最后一个节点 ListNode* newHead = reverseList(head-\u0026gt;next); // 已经将head-\u0026gt;next部分的链表处理完毕 head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = nullptr; return newHead; } 迭代写法1：遍历，修改相邻节点的指针指向\n迭代写法2：创建虚拟头节点，进行头插法（遍历链表，插入到虚拟头节点之后）\n142. 环形链表 II 【好题】\n快慢指针可以判断有环 如何找到这个环的入口 148.排序链表\n递归方法：（自顶向下的）归并排序，时间复杂度O(n logn)，空间复杂度O(logn) 迭代方法：自底向上的归并排序，时间复杂度O(n logn)，空间复杂度O(1) 143.重排链表 【好题】\n先快慢指针寻找中点，然后后半段链表原地反转，最后两个链表合并 23.合并K个升序链表\n最小堆：priority_queue\u0026lt;ListNode*, vector\u0026lt;ListNode*\u0026gt;, decltype(cmp)\u0026gt; pq; 445.两数相加Ⅱ\n一种方法是反转链表，另一种是使用栈进行计算 LRU缓存 【好题】\n两点注意： 设置dummyHead与dummyTail，可以避免专门判断head与tail是否为空（因为是双向链表，所以要设置头尾两个dummyNode） 在Node中需要同时包含key和value，因为当删除某个node时，需要知道其对应的key，从而删除哈希表中对应的表项 递归 递归写法代码量一般比较少，也比较优雅，尤其在没有头节点的情况下避免对头节点另外判断\n138.随机链表的复制\n21.合并两个有序链表\n哈希表【二刷】 有时可以直接使用数组进行哈希，有时需要使用map（unordered_map）或set（unordered_set）进行哈希，注意如果键无法进行哈希，则无法使用unordered_map或unordered_set（比如vector容器就没有hash方法，不能作为unordered_map或unordered_set的键）\n202.快乐数：使用哈希表空间复杂度为O(n)，将其视为快慢指针此时空间复杂度为O(1)\nn数之和系列：给定n数之和\n给定一个数组，要求返回其中一个元组下标：哈希\n1. 两数之和 给定一个数组，要求返回所有元组下标：先排序，外层遍历，内层左右指针向中移动，根据当前三数之和确定左指针还是右指针移动，同时注意跳过相同的数字\n15. 三数之和\n18. 四数之和：注意四数之和可能超过int的范围\n给定多个数组，要求返回元组的个数：哈希\n454. 四数相加 II 【原地哈希】\n例题：LCR 120.寻找文件副本：可能有多个重复数字，返回任意其一\n调整数组为nums[i]==i，如果将i写入到nums[i]时发现原来已经nums[i]==i，说明i就是重复数字 方法：通过交换实现调整 442.数组中重复的数据：数字出现1或2次，返回所有出现两次的数字\n287.寻找重复数：只有一个重复数，返回之；但是不能修改原数组\nFloyd判圈 268.丢失的数字：只有一个缺失的数字，返回之\n41.缺失的第一个正数 ：首先要判断数字是否在[0,n]的范围内\n总结：虽然原地哈希的核心部分都是判断当前位置j的元素j=nums[i]为索引时，是否已经写入j?=nums[j]，但是中间很多细节略微不同\n974.和可被K整除的子数组：前缀和+哈希表\n前缀和实际上是前缀和的取模，使用哈希表记录模和其计数 12.整数转罗马数字\n哈希表记录数字到字符串的映射，注意使用map\u0026lt;int, string, greater\u0026lt;int\u0026gt;\u0026gt;将key从大到小排列 栈与队列【二刷】 用栈模拟队列：一个输入栈，一个输出栈 用队列模拟栈：只需要一个队列，将元素进行循环弹入弹出 优先队列 注意优先队列如何自定义比较顺序 栈 基本计算器Ⅱ：遇到加减法入栈（即栈内都进行加法运算），有两种不太相同的写法：比如a+b*c\n方法一：暂存数字。比如解析+时，暂存的是数字a，此时可以入栈；比如解析*时，暂存的是数字b（运算符前面的数字），此时先不能入栈，需要继续向后解析完c之后，更新暂存的数字 方法二：暂存数字前的运算符，更简洁。比如解析b时，当前暂存的运算符是+（数字前面的运算符），因此遇到新的运算符*时，根据需要出栈入栈 技巧：将a+b*c处理成a+b*c+0，且开始时暂存的运算符是+ 394.字符串解码：【重要】\n方法一：【双栈】写法，数字栈与string栈 字符串出栈时，每个元素需要先reverse，连起来字符串之后要再次reverse（因为出栈是逆序的，每个元素内部有时顺序的） 数字栈使用stack\u0026lt;int\u0026gt;，string栈使用deque\u0026lt;string\u0026gt;进行模拟，方便最后进行出栈 方法二：递归写法 全局的索引idx，函数传参string和重复数量cnt 如果遇到[，则进入递归；如果遇到]，则退出递归 递归就是顺着累加字符串，不需要reverse 678.有效的括号字符串：\n方法一：【双栈】 括号一个栈st，星号一个栈star_st，栈内存放下标 括号按照传统方法出入栈，星号直接入星号栈 在遍历完成之后，括号栈依次出栈， 如果当前是(，需要保证star_st.top()大于(的下标 如果当前是)，需要保证star_st.top()小于)的下标（极其注意需要当前star_st.top()可能大于)的下标，需要while依次出栈，与上面逻辑不同） 方法二：贪心 维护未匹配的(的数量可能的最大值和最小值，遇到星号时，最小值减一，最大值加一 如果最大值\u0026lt;0，则字符串无效 遍历完成后，只有最小值=0时，字符串才可能有效 最小栈 参考\n方法一：【双栈】 一个普通栈，一个最小栈（用来记录最小值） 如果当前元素==minStack.top()，也要push/pop最小栈 方法二：使用一个栈，并维护当前最小值minVal 入栈：如果当前元素\u0026lt;=minVal，则先将minVal入栈，然后再将当前元素入栈，同时更新minVal的值；否则直接入栈 技巧：minVal初始值设定为最大值 方法三：使用一个栈 每次入栈元素为当前元素-minVal -\u0026gt; st.top()，如果结果是负数，说明minVal需要更新minVal=当前元素 每次出栈或top，如果栈顶元素是正数，则原来的元素=minVal+st.top()；如果栈顶元素是负数，则说明当前minVal经过更新变得更小，原来的元素=minVal，复原原来的minVal=原来的元素(即旧的minVal)-st.top() 单调队列 239. 滑动窗口最大值 方法一：大根堆，维护一个大根堆，里面存放数组索引，但是比较方法是按照对应元素大小进行比较，出队列时肯定是当前最大元素，而且可以判断该元素是否在窗口范围内 最坏情况如果是一个递增序列，每次push都是log(i)的复杂度，总的复杂度为sum(log(i))=O(n log(n)) 方法二：单调队列，维护一个递增的deque，里面存放数组索引，从后面pop_back可以比较当前元素与队尾元素，保持队列递增；从前面pop_front可以保持元素位于窗口范围内 最坏情况是O(n) 单调栈 739. 每日温度：从左往右，找到第一个比当前元素大的元素\n单调递增栈（从栈顶到栈底递增，栈顶元素为已经遍历过部分的最小值），如果当前元素nums[i]大于栈顶元素nums[top]，则从左往右nums[top]第一个比它大的元素是nums[i]\n496. 下一个更大元素 I：单调栈+哈希表\n503. 下一个更大元素 II：朴素想法是将循环数组展开，但是可以相同的单调栈代码跑两遍（第二遍继续使用第一遍剩下的单调栈）\n42. 接雨水 【重要】\n方法一：单调栈，从栈顶到栈底递增（反映到柱子上就是往下的台阶）\n横着接水：如果当前元素height[i]高于栈顶的柱子H=height[st.top()]，则栈顶的柱子H为最低高度，pop之后的栈顶为左边比H更高的位置，当前位置i为右边比H更高的位置，横着按层累加 时间复杂度O(n)，空间复杂度O(n) 方法二：双指针\n竖着接水：维护左右边历史最高柱子，往中间移动的过程中： 如果右边低，当前水位最高只能按照低的来，ans += rightHeight - height[right--] 左边同理 时间复杂度O(n)，空间复杂度O(1) 方法三：两个数组，分别从左向右和从右向左记录当前最高水位，也是竖着接水\n84. 柱状图中最大的矩形 【重要】\n单调栈，从栈顶到栈底递减（反应到柱子上就是往上的台阶）\n找每个柱子左右两边第一个低于该柱子的位置：如果当前元素height[i]低于栈顶的柱子H=height[st.top()]，有： i-1位置的柱子一定不低于H pop之后的栈顶位置+1一定不低于H（注意与接雨水的细微区别） 因此可以算面积 时间复杂度O(n)，空间复杂度O(n)\n技巧：在原来height数组开头height.insert(heights.begin(), 0)，在结尾height.push_back(0)，可以保证最后栈中无元素\n85.最大矩形\n每行统计高度，因此每行跑一个84. 柱状图中最大的矩形 时间/空间复杂度均为O(mn) 402. 移掉 K 位数字\n单调栈：从栈底到栈顶递增，同时维护栈的顺序和k\u0026gt;0 优先队列 347.前K个高频元素：小根堆，遍历过程中逐步弹出堆顶，剩下的就是高频元素\n注意优先队列的写法：\n1 2 auto cmp = [](pair\u0026lt;int, int\u0026gt;\u0026amp; p1, pair\u0026lt;int, int\u0026gt;\u0026amp; p2){return p1.second \u0026gt; p2.second;}; priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, decltype(cmp)\u0026gt; pq(cmp); 手写堆\n二叉树【二刷】 遍历 DFS 递归写法：\n确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑 迭代写法：\n道理：当前arrive（或access）的节点，未必就是要add进数组的节点\n前序：第一次arrive的节点，就是add进数组的节点 中序：第二次arrive的节点，就是add进数组的节点 前序：空节点不入栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; v; stack\u0026lt;TreeNode*\u0026gt; st; if(root == nullptr) return v; st.push(root); while(!st.empty()){ TreeNode* now = st.top(); st.pop(); v.push_back(now-\u0026gt;val); if(now-\u0026gt;right) st.push(now-\u0026gt;right); if(now-\u0026gt;left) st.push(now-\u0026gt;left); } return v; } 中序：空节点可以入栈，使用now指向当前arrive的节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; v; stack\u0026lt;TreeNode*\u0026gt; st; TreeNode* now = root; while(now != nullptr || !st.empty()){ // 比如中间-\u0026gt;可能now指向空指针，此时stack不能为空 // -\u0026gt;可能stack为空，但是now指向右节点 // 最后now指向某个节点的右空树，且stack都出栈已经为空，此时就是结束 if(now == nullptr){ now = st.top(); st.pop(); // st.top()是第二次访问，可以add进数组 v.push_back(now-\u0026gt;val); now = now-\u0026gt;right; } else{ // now != nullptr st.push(now); now = now-\u0026gt;left; } } return v; } 后序：可以按照【根右左】的顺序遍历，然后reverse（即左右根）\nBFS 迭代写法：注意是否要分层；如果不用分层，则不用计算每层的size，更简单一些\n递归写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vv; bfs(root, vv, 0); return vv; } void bfs(TreeNode* root, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; vv, int depth){ if(root == nullptr) return ; if(vv.size() == depth) vv.push_back(vector\u0026lt;int\u0026gt;()); vv[depth].push_back(root-\u0026gt;val); if(root-\u0026gt;left) bfs(root-\u0026gt;left, vv, depth+1); if(root-\u0026gt;right) bfs(root-\u0026gt;right, vv, depth+1); } 199.二叉树的右视图：注意递归的写法，将深度和当前数组的size比较 二叉树 222.完全二叉树的节点个数 【好题】\n如何判断满二叉树？向左递归深度==向右递归深度 完全二叉树中，某个节点左子树和右子树中，至少有一个是满二叉树，参考 复杂度分析： 每次递归需要计算当前节点的高度，O(log n) 最多需要调用“树的高度”次，O(log n) 相乘，O(log n) * O(log n) 110.平衡二叉树\n注意二叉树节点【深度】和【高度】的差异 高度：该节点到叶子节点的最长，求高度适合用前序遍历 深度：根节点到该节点的路径，求深度适合用后序遍历 112.路径总和\n注意分辨递归什么时候有返回值 不用完整搜索整棵二叉树，找到其中一条路径即可，需要返回值（比如本题），比如if判断当前节点后直接返回。或者说遍历的思维 需要完整搜索整棵二叉树，或者说二叉树与回溯的结合 需要返回值（比如递归求深度） 不需要返回值 124.二叉树中的最大路径和 【好题】，【不会】\n递归写法 236.二叉树的最近公共祖先 【好题】\n递归方法： 后序遍历：分别在左右子树中找p和q的最近公共祖先，然后根据找到的情况进行处理 如果子树递归返回nullptr，说明子树不包含p或者q 如果子树递归返回非nullptr，说明子树包含p、或q、或pq 理解返回值：返回值是以root为根的子树中，p或q的最近公共祖先，如果该子树不包含p或者q，则返回nullptr 如果root==p || root==q，则当前root至少为一个节点祖先，另一个节点可能在这个子树上，也可能不在这个子树上，但至少返回root 如果当前root为根的子树，没有p或者q（左右子树都是nullptr），只能返回nullptr 如果当前root为根的子树，左右子树分别有p和q，则root为最近公共祖先，返回root 如果当前root为根的左子树或右子树其中一个，同时有p和q，则只能将其最近公共祖先向上返回 迭代方法：使用map记录子节点到父节点的映射，再使用一个map记录p到root的路径，最后q向上回到root过程中找到最近同时访问的节点 543.二叉树的直径\n维护一个计算每个节点最大深度的递归函数deepest 在计算节点左右子树的过程中，更新树的直径 662.二叉树最大宽度：中间nullptr也算\npair\u0026lt;TreeNode*, unsigned long long\u0026gt;保存节点和其id，×2得到其左节点id，×2+1得到其右节点id，最后id相减 116.填充每个节点的下一个右侧节点指针\n常规方法：使用队列进行迭代 递归方法：递归函数中传入两个节点指针 671.二叉树中第二小的节点：root是最小的，遍历一遍，比root大的其中最小的\n区分572.另一棵树的子树 和 LCR 143.子结构判断(这个题目关于空节点本身没有说清楚)\n863.二叉树中所有距离为K的结点\n遍历一遍得到子节点到父节点的map，从而变树为图，然后dfs 297.二叉树的序列化与反序列化 【好题】\n第一种方法：使用括号表示编码（BNF编码）进行序列化，使用递归函数进行反序列化，代码 BNF编码：比如postOrder BNF编码(左)(右)(根) 反序列化时，递归函数中需要使用栈，从而确定左右子树在字符串中的范围 第二种方法：使用逗号表示编码按照层序遍历进行序列化，使用迭代方法进行反序列化，代码 序列化方式与leetcode样例给出方式相同，不需要特殊表示换层 反序列化同样使用队列，字符串遍历的过程中入栈出栈 第三种方法：使用逗号表示编码进行序列化，使用递归函数进行反序列化，代码 序列化表示形式与第二种方法相同，但是好像只能使用前序遍历 如果使用中序/后序，字符串中第一个元素解码后是nullptr，在反序列化的递归函数中第一个元素就直接返回，不会处理后面的字符串了 如果使用前序，字符串中第一个元素肯定不为nullptr，可以递归下去 反序列化过程需要维护一个全局的索引，从而在不同的递归函数之间确定当前处理的元素的位置 652.寻找重复的子树\n使用基于后序遍历的二叉树序列化，模板类似297.二叉树的序列化与反序列化中第一种方法，但是序列化格式可以简化 在后序遍历进行序列化的过程中，同时维护unordered_map\u0026lt;string, pair\u0026lt;TreeNode*, int\u0026gt;\u0026gt;的映射 二叉搜索树 98.验证二叉搜索树 530.二叉搜索树中的最小绝对差 501.二叉搜索树中的众数\n原理：二叉搜索树中序遍历是有序的 可以是递归写法：维护一个全局变量，记录上一个节点的指针pre 可以是迭代写法：中序迭代写法 98.验证二叉搜索树极易想成简单左右子树判断，但此时根节点和右子树的左孩子的关系是无法判断的，只能中序遍历判断有序 450.删除二叉搜索树中的节点 【好题】\n对比递归方法与迭代方法：都是五种情况 迭代方法：小心删除根节点时的特判 递归方法：使用root-\u0026gt;left或root-\u0026gt;right接受返回值，避免记录pre节点（同时也避免了删除根节点时pre==nullptr的判断） LCR 174.二叉搜索树的第k大节点\n中序倒序，维护全局变量的计数器 426.将二叉搜索树转换为有序的双向链表\n递归函数返回有序双向链表的头 LCR 152.验证二叉搜索树的后序遍历序列\n注意是二叉搜索树，因此可以确定根与左右子树，从而递归判断 第二种方法：单调栈+后序逆序，代码，参考，不太会 比如当前是根节点（栈顶） 如果下一个节点大于栈顶元素，则在右侧，因此入栈 如果下一个节点小于栈顶元素，则出栈（该节点在其祖先节点的右边），找到其祖先节点，后序节点应该都在该祖先节点的左边 假设有一个极大的虚拟根节点，整棵树都在其左边 99.恢复二叉搜索树\n遍历过程中，记录这两个节点，参考 综合 437.路径总和Ⅲ 【好题】，【二叉树】+【前缀和】+【回溯】\n递归方法：以每个节点为root（O(n)），再计算包含root时的路径数量（O(n)），复杂度O(n^2)\n前缀和：在前序遍历的过程中，记录当前节点的前缀和，并遍历过的节点的前缀和保存到map中（value是特定前缀和的个数）\n根据当前前缀和和root-\u0026gt;val，可以得到当前分支上符合要求的路径的个数 当当前root返回时，当前的前缀和也需要从map中复原 回溯 回溯\n思路：二叉树/多叉树的递归遍历\n视为二叉树的话，每个元素选择或不选，每个dfs中有两条路径 视为多叉树的话，在每个for循环中进行选择，注意选择之后的回溯复原就表示没有选择当前元素，然后可以选择后面的元素 写法：数组直接作为全局变量，进行多叉树的遍历时使用一个startIdx来表示当前搜索数组的位置\n细节问题：\n使用startIdx还是从0开始 能否对数组排序？ 能，如果需要去重，维护一个全局的used数组 used数组的索引，表示nums的下标（一般是这个），还是nums元素的值 不能，如果需要去重，则每一层应该维护一个局部的set 组合问题：从N个数中选k个数，有几种选法\n77.组合：模板题 216.组合总数Ⅲ：直接在for循环中进行剪枝 17.电话号码的字母组合：使用字符串数组（或者二维数组）来进行数字到字符串的对应 39.组合总和： 40.组合总和Ⅱ：使用used数组进行去重，初始化used=false： 当数组中相邻两个元素相等且used=true时，表示这两个元素在同一个树枝上（在一个分支上），此时不用去重（即组合内部使用了相同的元素） 当数组中相邻两个元素相等且user=false时，表示这两个元素在递归的同一层（同一树层上），此时表示后面会有相同的组合出现，因此需要去重（continue） 切割问题：一个字符串不同切割方式，有几种方式\n131.分割回文串：逐个分割每个元素进行判断，同样是递归的树形结构 93.复原IP地址：感觉写成三叉树的递归方式，而非是for循环的递归方式更直观和易于理解 三叉树方式：从当前位置开始的子串，分别作为一个字符、两个字符、三个字符进行匹配 子集问题：N个数中相关子集的个数\n78.子集：递归的树形结构的所有节点 90.子集Ⅱ：理解“树枝去重”与“树层去重”的逻辑，对于相同的数字，前面的可以选或不选，后面的必须不能选 491.递增子序列：同样需要去重，但不能使用全局的used数组来去重 90.子集Ⅱ中数组是有序的，可以保证相同的数字都是挨着的， 491.递增子序列中数组无序，如果按上面的方式，只能保证相同的连着的数字是去重的，相同的不挨着的数字会重复，因此只能每一层维护一个局部的used数组，动态判断该数字之前是否出现过 排列问题：N个数的不同排列方式\n46.全排列：\n方法一：使用used数组记录该数字是否使用过，仔细考虑for循环和回溯（回退）的过程 方法二：使用swap和startIdx，每次减小排列的规模 47.全排列Ⅱ：对比491.递增子序列\n332.重新安排行程：\n错误理解和写法：每个机场只到一次（因此使用一个数组记录该节点是否到过） 正确理解：所有路径都走且只走一次（可能比如北京到上海有好几张票，都要使用，因此使用unordered_map\u0026lt;string, map\u0026lt;string, int\u0026gt;\u0026gt;来进行建图，然后dfs,回溯更新int的值） 棋盘问题：\n51.N皇后：画出搜索的树形结构，dfs中逐层放置皇后 37.解数独： 二维的递归，注意最外层for循环的是数组/棋盘，而不是各种可能性或组合（即选或不选） 判断合法性时，只是判断当前元素是否行、列、方格重复 贪心 区间贪心 55. 跳跃游戏：维护一个当前可以跳跃到的最右边界 45.跳跃游戏Ⅱ 435.无重叠区域 当有重叠区域时，更新右端点right = min(right, v[1]);的含义：如果重叠，使得右端点最小 如果旧的right更小，则移除掉新来的区间 如果新来的区间v[1]更小，则移除原来的区间 452.用最少数量的箭引爆气球 对比435.无重叠区域 按照每个点的start进行排序，当前重叠范围为[start, right]，start递增，维护逐渐缩小的重叠区间right = min(right, points[i][1]) 两个维度贪心 406.根据身高重建队列：先从高到低排队，再插队，复杂度O(n^2) 上下坡 376.摆动序列 方法一：贪心，也就是统计一共有几次变化 方法二：带空间优化的动规，up[i], down[i]为以nums[i]为结尾（最后一个是上升或下降）的摆动序列长度 135.分发糖果：正着统计上坡，反着统计上坡 122.买卖股票的最佳时机Ⅱ：直接累加上坡的差值 134.加油站：找剩余油量的前缀和中最小的位置 动态规划 总结 动规五部曲：\n确定dp数组的含义和下标的含义 确定递推公式 确定dp数组的初始化 确定遍历顺序 举个例子 单纯动规 直接寻找/使用最优子结构 97.交错字符串\n91.解码方法\n最优子结构好找（相当于递推），只是中间判断有点多 139.单词拆分\n322.零钱兑换\n343.整数拆分\n221.最大正方形\n子结构需要从三个方向考虑 使用滚动数组优化，注意有斜向上的依赖，需要使用一个变量记录 576.出界的路径数：题目一般，就像递推\n931.下降路径最小和\n120.三角形最小路径和\n剑指 Offer 47. 礼物的最大价值 同 64.最小路径和\n剑指Ⅱ 091.粉刷房子\n174.地下城游戏\n从右下到左上的动规 823.带因子的二叉树\n01背包 494.目标和：要装满背包，有几种方法 注意，0可以特殊处理，也可以不用特殊处理 416.分割等和子集： 给定背包容量，能不能装满这个背包 方法一：dp[j]就表示背包容量为j时，能否将背包装满 方法二：视为标准01背包，物品价值和重量相等，最后看容量为j的背包里最大价值 1049.最后一块石头的重量Ⅱ 1049.最后一块石头的重量Ⅱ： 首先转换成标准01背包：分成两堆石头，一堆小，一堆大，让小的那堆尽量接近一半 474.一和零：给定背包容量，装满背包最多有多少个物品 注意背包是二维的（长对应0的数量，宽对应1的数量） 排列数与组合数 377.组合总和Ⅳ：算组合数 22.爬楼梯：进阶版爬楼梯（每次可以爬[1 - m]个台阶）其实是一个完全背包下计算组合数的问题 参考 打家劫舍系列 198.打家劫舍： 不要硬套01背包，01背包只是动规中很套路的一个模板；除了直接题目可以直接套模板，剩下的还是要具体分析出来递推公式 213.打家劫舍Ⅱ 拆环为链，拆分成两种情况，各跑一遍 337.打家劫舍Ⅲ：树形DP 每个节点有一个状态数组 在后序遍历中，得到左右子树的状态，更新当前节点的状态 买卖股票的最佳时机系列 121.买卖股票的最佳时机\ndp数组表示持有/不持有股票，第0天持有即买入 划分状态 首先为什么标准01背包不需要针对每个背包的容量分成两种状态的数组？ 动规原理是最优子结构，标准01背包中物品之间是相互独立的，不存在某件放入a物品后必须放入b物品这样的关联 其次为什么打家劫舍问题也不需要针对每一间房屋分成两种状态的数组？ 首先可以分，而且公式写出来也很清晰，在比如树形DP中还必须要分 但是打家劫舍中，只是相邻两个房屋之间有关联，公式中可以直接将关联表示出来 买卖股票中为什么必须要分成两种状态的数组？ 因为买卖股票的两天之间的关联不是固定的 买卖股票中还需要注意两种状态的定义：是持有/不持有，而非买入/卖出 什么是状态？ 第i天进行第j笔交易，是持有还是不持有 注意如何保证只买入一次？区别122.买卖股票的最佳时机Ⅱ 加上手续费相同714.买卖股票的最佳时机含手续费 122.买卖股票的最佳时机Ⅱ\n123.买卖股票的最佳时机Ⅲ\n每天有多种状态：第i天进行第j笔交易，是持有还是不持有\n有一个技巧可以将空间复杂度降到O(1)，参考\n188.买卖股票的最佳时机Ⅳ 同理\n309.最佳买卖股票时机含冷冻期\n细化状态（比如不持有股票可以细分为今天卖出还是维持原来不持有的状态） 画出状态转移图 序列问题 递增序列/数组 300.最长递增子序列 LIS\n更像是记忆化搜索或者递推，而非动规\n对比674.最长连续递增序列（或者可称为最长递增数组？），是否连续决定是否内部要使用一个for循环找到比当前元素小的位置\n可以使用贪心+二分实现更低的复杂度\n贪心：d[len]表示长度为len的LIS，末尾元素的最小值，最小值越小越好\n二分：d[]数组单调递增\n1 2 3 4 5 6 7 8 9 // d[len]:长度为len的LIS，末尾元素的最小值 if(nums[i] \u0026gt; d[len]) d[++len] = nums[i]; else{ // 二分查找：find max l, nums[i] \u0026gt; d[l] // 因此d[l+1]找到一个更小的末尾元素nums[i]：d[l+1]\u0026gt;nums[i]\u0026gt;d[l] d[l+1] = nums[i]; } return len 参考\n673.最长递增子序列的个数\n使用贪心+树状数组实现O(nlogn)的复杂度，参考 354.俄罗斯套娃信封问题\n先排序，w正排，h倒排（保证相同w时，大h不能包含小h） 通过排序将二维LIS转换为一维的LIS 368.最大整除子集\n与LIS方法差不多 重复数组、公共序列、子数组/序列问题 718.最长重复子数组\n使用滚动数组进行优化：代码 内层逆序：之所以逆序，一是因为不将物品重复放入，二是因为可能依赖是斜向上的，逆序可以直接访问未更新之前的数值 也可以使用顺序，不过要将原来未更新之间的数值记录下来 其实是这个题目对遍历顺序没有要求，因为if中dp依赖左上旧值，else中dp直接是0 其他题目中，else中可能需要用到刚才更新过的值，因此只能从前向后遍历 1143.最长公共子序列 和 1035.不相交的线\n使用滚动数组进行优化：使用两个数组来回调替，或者直接记录依赖的旧值 53.最大子数组和\n遇到数组和第一直觉总是前缀和，但是这个题目使用动规很简单 392.判断子序列\n可以使用双指针 使用动规：状态转移方程很类似 dp可以表示相同序列的长度 dp也可以是bool数组，表示s[0, i]是否为t[0, j]的子序列 使用滚动数组优化二维数组时，注意将初始化方式从原来的二维情况下转换到一维情况下，比如当i=0时容易记起初始化，但是i=1,2,3\u0026hellip;之后，dp[0]或者dp数组开头几个数字就容易忘记初始化，代码 115.不同的子序列\n代码模板是392.判断子序列，只是递推公式需要多考虑一下 字符串操作 583.两个字符串的删除操作 动规方式1：先求出最长公共子序列，再相减 动规方式2：dp直接表示删除的最小步数，逻辑相同 注意原来使用二维数组时，有一定初始化方式；使用一维数组进行优化时，dp[0]很容易忘记初始化，代码 712.两个字符串的最小ASCII删除和 72.编辑距离 当word1[i]与word2[j]不相同时，如果进行插入和删除，只需要考虑将word1[i]当前字符插入或删除 牛客NC35 编辑距离二 有O(nlogn)的算法吗？？？ 回文相关 647.回文子串：【好题】，分析 有时dp数组的含义并不是直接求什么，定义什么 如果$dp[i][j]$表示$s[i:j]$内的回文子串的数量，当s[i]==s[j]时，此时无法判断$s[i+1:j-1]$是否为回文串，由此无法确定递推公式中是否要+1，错误代码 $dp[i][j]$表示$s[i:j]$是否为回文串，在递推公式之后根据true or false进行累加，正确代码 5.最长回文子串 516.最长回文子序列 注意看是子序列（不必连续）还是子串（必须连续） 这个回文动规中，dp的含义，就是求什么定义什么 1312.让字符串成为回文串的最少插入次数 其他 152.乘积最大子数组：【好题】，也是分状态，但是其中另一个状态隐含在题目中，需要分析，很巧 第一次几乎完全不会 32.最长有效括号 动规+单调队列 1696.跳跃游戏： 模板题 14253带限制的子序列和：【好题】 比1696在动规上多了一点 图论 DFS与BFS 797.所有可能的路径：DFS+回溯\n200.岛屿数量：DFS，BFS模板题\n1020.飞地的数量：第一阶段原地修改原来的二维数组标记，第二阶段再次遍历\n130.被围绕的区域：原地修改二维数组标记\n827.最大人工岛：保存中间计算结果（岛屿面积），避免重复计算\n首先遍历，每个岛屿进行编号，同时使用map记录id到岛屿面积的映射 对于水块，上下左右累加岛屿面积 127.单词接龙：\n单词个数n，单词长度m\n方法一：BFS内部，对单词进行遍历，找到相邻的单词，最坏情况复杂度O(nnm) 方法二：BSF内部，对当前单词逐字母进行替换，判断替换后的单词是否在词表中，复杂度O(26*n) 并查集 并查集：一个用数组表示的森林\n当存在u-\u0026gt;v的有向边时，添加到并查集：father[v] = u; // v的father是u 1971.寻找图中是否存在路径：模板题\n数学 模拟 9.回文数： 空间复杂度O(1)的方法：原来数字取模除十的过程中，与反转后的数组比较大小 172.阶乘后的零：实际上就是找因子5的个数 位运算 常用技巧：对于int n\n获取n的最低位的1：n \u0026amp; (-n) 将n的最低位1变为0：n \u0026amp; (n-1) 191.位1的个数：\n循环检查二进制位：if(n \u0026amp; (1 \u0026lt;\u0026lt; i)) ++cnt lsb翻转：n \u0026amp; (n-1)结果为将n的二进制lsb变为0，因此：while(n) {n \u0026amp;= (n-1); ++cnt;} 136.只出现一次的数字：数组异或，原理是异或具有交换律\n137.只出现一次的数字Ⅱ：\n对于32位int，统计每一个bit中1的个数cnt，如果cnt无法整除3，则只出现一次的数字在当前bit为1，ans |= (1 \u0026lt;\u0026lt; i) 260.只出现一次的数字Ⅲ：分组异或\nxorsum一定不为0，否则所有数字都出现两次，假设两个出现一次的数字为a和b xorsum的最低有效位lsb，则一定是a的lsb=1，b的lsb=0（或反过来） 出现两次的数字，其lsb一定相同；因此根据这个lsb可以将所有数字分成两类，分别进行异或 其他 快速幂 470.用Rand7()实现Rand10()：拒绝采样 注意不能直接使用rand7() * rand7()，因为其中元素概率不完全相同，比如14的概率是2/49，1的概率是1/49，6的概率是4/49 视为行列索引：row=rand7(); col=rand7(); c = (row-1)*7 + col;，这样每个元素等概率 设计 705.设计哈希集合：基于vector\u0026lt;list\u0026lt;int\u0026gt;\u0026gt;的链地址法 706.设计哈希映射：基于vector\u0026lt;list\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt;的链地址法 380.O(1)时间插入、删除和获取随机元素： 一个vector用来获取随机元素 一个unordered_map\u0026lt;int, int\u0026gt;用来记录val到idx的映射 208.实现Trie（前缀树） 类似二叉树，Trie本身就是一个node，里面有vector\u0026lt;Trie*\u0026gt; children(26, nullptr)表示26叉树 Trie节点中包含一个属性isEnd，如果当前节点表示字符串的最后一个字符，则当前节点的下一个节点的isEnd=true 包含一个辅助函数Trie* searchPrefix(string prefix)，返回prefix字符串结尾的下一个节点 继续刷 142.环形链表Ⅱ\n124.二叉树中的最大路径和 437.路径总和Ⅲ\n4.寻找两个正序数组的中位数\n85.最大矩形\n28.找出字符串中第一个匹配项的下标：KMP模板\n","permalink":"https://qinganzhang.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","summary":"[toc] tags：【双指针】，【前缀和】，【原地哈希】 【好题】，【不会】，【重要】 方法 双指针 前后定长双指针 前后快慢双指针 左右双向双指针 611.有效","title":"Leetcode刷题记录"},{"content":"指令集架构 指令集 说明了操作种类、指令格式（操作码和地址码，地址码个数，操作码定长与拓展）、寻址方式、地址空间大小和寄存器个数等。简单可以理解为汇编指令用01表示。\nCPU位数=CPU中寄存器的位数=数据总线宽度\n硬件厂商开发某种指令集的CPU，需要该指令集专利持有者进行授权\n比如ARM公司自己的研发指令集叫ARM指令集，对外授权（同时ARM公司还进行微架构的授权）\n一些大型公司都获得ARM公司针对ARM指令集的授权，开发兼容ARM指令集的不同的微架构\n比如Intel授权AMD可以生产兼容x86指令集的CPU 编译：高级语言翻译成特定ISA的机器码\n参考\n关于CPU、指令集、架构、芯片的一些科普 复杂指令集CISC x86：在1978年的Intel 8086 CPU（16位）指令集基础上，发展而来的一些列指令集的泛称\n桌面级CPU一般都是x86的，兼容8086指令集 IA-32(x86,i386)：Intel将16位的x86拓展为32位的IA-32，但是由于IA-32的统治地位，x86也一般指IA-32的CPU\nIntel 80386是第一款i386 CPU（第一款IA-32架构的CPU） i386，i486：即Intel 80386， Intel 80486 Pentium（i586）：Intel 80586 Pentium Pro（Pentium Ⅱ，i686）：Intel 80686 此后，x86成为一些列架构的泛称，不限于16位，32位，64位 IA-64：1994年Intel推出的与x86完全无关的新架构（也不兼容之），基于显式并行指令运算（EPIC）的64位指令集架构\n2001年发布第一款基于IA-64的CPU，叫Itanium安腾，IA-64也称为Intel Itanium 但是由于软件环境的缺乏和AMD的竞争，导致市场不好 x86-64(x64)：1999年，AMD推出x86-64架构（简称x64），是对IA-32(x86)的兼容和拓展\n2003年AMD发布的一款基于x86-64的CPU，x86-64也称为AMD64\n后来Intel也用AMD64架构，称为IA-32e(IA-32 extension)，后来又叫Intel64\nx86-64, x64, AMD64, Intel64, IA-32e(IA-32 extension)基本是一个东西\n苹果公司和 RPM 包管理员以 x86-64 或 x86_64 称呼此 64 位架构。甲骨文公司及 Microsoft 称之为x64。BSD 家族及其他 Linux 发行版则使用 amd64，32 位版本则称为i386（或 i486/586/686），Arch Linux 用x86_64 称呼此 64 位架构。\nx86,x64,x86-64,amd64,arm指令集架构之间的关系中x86 架构发展\n参考\ni386、i486、i586、 i686、 x86、x86_64、x64、amd_64详解【写的很好】 精简指令集RISC ARM ARMv3~ARMv7都是32位 ARMv8：向前兼容32位指令，同时 AArch64：64位执行状态，使用全新的ARM 64位指令集 AArch32：32位执行状态 RISC-V：伯克利发明的一种基于RISC的开源指令集架构 一文看懂RISC-V MIPS PowerPC 微架构 微架构：硬件电路（或CPU单个核心core）的结构和实现 CPU研发能力一般指的是独立的微架构研发能力，是否使用自行研发的指令集关系不大 研发兼容的指令集可以没有获得授权，指令集的研发不是很难，但是之后获得授权后才能合法销售 微架构的设计细节是保密且复杂的 SoC（System on Chip）封装相对简单 商业模式 之前在PC时代，CPU研发厂商自己的微架构只有自己用 后来在智能设备时代，ARM公司将自己的微架构出售，其他厂商可以拿来组装，比如Cortex系列核心 由于ARM公司的成功，ARM公司针对PC领域发布了ARM v8 64位指令集 以前ARM适合低功耗的场景，随着技术进步，指令集对微架构的影响越来越小 指令集的选择：倾向于选择软件生态良好的指令集 以前获得指令集的授权很困难，主要通过技术交换的形式（指令集多授权一家，就多一个对手） 后来ARM对指令集授权略微放松 参考： 指令集、微架构、手机芯片(Soc)及ARM的介绍(偏硬件科普) 计算机架构 冯.诺伊曼架构：程序和指令存储在一起 哈佛架构：程序和指令分开存储 比如单片机（51单片机，STM32单片机），Cortex-M系列 现代处理器架构一般指令和数据共享存储，但是CPU内部缓存分开 特别介绍：ARM ARM商业发展 由于商业需要，1985年，Acorn公司基于RISC，自研CPU（包括指令集和微架构），称为ARM（Acorn RISC Machine），型号命名为ARM1（对标80286）\n后来，Acorn公司和苹果公司联合成立了一家叫ARM（Advanced RISC Machines）的公司，开启新的产品策略：授权\n传统商业模式：\nIDM(Integrated Design and Manufacture)：从设计，到制造、封装测试以及投向消费市场一条龙全包，比如Intel 无工厂模式Fabless：自己设计，制造交给代工厂，比如AMD，NVIDIA Foundry：只做代工 使用层级授权（处理器授权）：只能买来已经封装好的CPU，不能更改原来设计，可以配置的地方不多 内核层级授权（POP授权）：以一个内核（或IP核）为基础然后在加上自己的外设 架构层级授权：授权使用ARM指令集，可以修改指令集，但是比较贵 比如华为基于ARMv8，自研达芬奇架构 后来ARM公司越来越成功，苹果公司逐渐卖掉其股份，开发ipod（基于ARM指令集）。\n2007年，苹果公司发布iphone，基于ARM指令集 2008年，谷歌发布Android系统，也是基于ARM指令集 2016年，ARM公司被软银集团收购\n参考\n如何看待观点「华为没有核心技术，因为芯片用的是ARM（安谋）架构，一旦被停止授权，就会做不出芯片」？ 【推荐】到底什么是Cortex、ARMv8、arm架构、ARM指令集、soc？一文帮你梳理基础概念【科普】 ARM处理器 一般处理器就是指CPU\n但是ARM处理器指的是单个核（或IP核，或内核），因为厂商可以在IP核上进一步封装，最终CPU不尽相同\nIP核，全称知识产权核（英语：intellectual property core），是在集成电路的可重用设计方法学中，指某一方提供的、形式为逻辑单元、芯片设计的可重用模组。IP核通常已经通过了设计验证，设计人员以IP核为基础进行设计，可以缩短设计所需的周期。\n参考：\narmv7-A系列0 - arm 处理器架构发展史中的处理器到底指的是什么 到底什么是Cortex、ARMv8、arm架构、ARM指令集、soc？一文帮你梳理基础概念【科普】中的ARM内核与架构 指令集、微架构、手机芯片(Soc)及ARM的介绍(偏硬件科普) 指令集架构：\nARMv1~ARMv9（可以有一定的变种比如ARMv8-A） ARMv8是首款64位的ARM指令集 处理器架构\nARMv3~ARMv6： ARM6, ARM7, ARM9, ARM11系列 ARMv7及以后 Cortex-A：大型嵌入式系统（手机） Cortex-R：实时处理器 Cortex-M：单片机 参考：\nARM基础教程 | ARM命名规则\nARM 命名规则——指令架构、CPU的历史回顾\n参考：\nARM体系架构概述\nAndroid 简介 Android是一个开源的，基于Linux的移动设备操作系统，主要使用于移动设备\n谷歌在2007年发布了第一个测试版本的 Android 软件开发工具包（SDK），第一个商业版本的 Android 1.0，则发布于2008年9月。\nAndroid 应用程序一般使用 Android 软件开发工具包，采用 Java 语言来开发。\n版本 Android版本（版本代号）\n每个Android 版本对应一个Android SDK，可以类比JDK Android API版本：有利于设置和解决兼容性问题\nAndroid API级别官方说明\nAndroid版本和 Android API level的对应关系\nAndroid NKD\n工具链 背景：\n使用GCC编译，很多时候需要手动链接（只有标准库才默认链接） 当需要链接的文件很多时，一来每次在命令行中写一遍繁琐容易出错，二来无法使用增量编译 Makefile 背景：make命令根据编译规则进行编译，而且可以进行增量编译，makefile用于写编译规则\n简要语法：\n阮一峰make教程 简明make教程 GNU make/Makefile 简明实用教程 语法笔记\nmake：即制作出某个指定的文件（默认makefile中第一个文件）\n越是接近目标文件的命令，就越是要写在前面。因为程序是按照递归的方式进行依赖文件查找的，看到第一行有一个没见过的依赖文件，就往下一行进行查找，以此类推。 核心概念：目标target，前置条件prerequisite，命令command\n伪目标的使用\n伪目标是一个命令，且没有前置条件：比如clean，显式使用内置目标名指定为伪目标，主要用于执行命令\n伪目标是一个文件，但是前置条件有多个，且没有命令：比如生成多个文件\nCMake 背景： 当工程很大的时候，手写Makefile也不简单 Makefile与平台相关，无法实现跨平台 cmake：跨平台的项目管理工具，自动生成makefile文件，然后make构建 手写CMakeLists.txt文件，cmake生成Makefile，然后再make构建 cmake简要语法 指令大小写无关，变量大小写相关\n可以使用双引号将文件名或目录名包含其中\nadd_executable：将源文件编译成可执行文件\nadd_library：将源文件编译为库文件\n在构建时，静态库和动态库重名会导致后面的构建失败，参考 SET_TARGET_PROPERTIES：同时构建同名的静态库和动态库 aux_source_directory(\u0026lt;dir\u0026gt; \u0026lt;variable\u0026gt;)：将dir目录下所有源文件的文件名存放到variable变量中\nadd_subdirectory：包含一个子目录，该子目录中也有一个CMakeLists.txt文件和代码文件，它们也会被处理，同时可以指定编译输出（包含编译中间结果）的路径\nlink_directories：添加共享库搜索目录\nCMAKE_LIBRARY_PATH：设置库文件搜索目录，这不是cmake变量（需要在bash中设置），通过FIND_LIBRARY找到相应库文件 target_link_libraries(\u0026lt;target\u0026gt; \u0026lt;items\u0026gt;)：为库或可执行文件加入库链接\ninclude_directories：添加头文件搜索目录\nCMAKE_INCLUDE_PATH：设置头文件搜索目录，这不是cmake变量（需要在bash中设置），通过find_path找到相应头文件 target_include_directories：在编译目标文件时指定头文件\nfind_系列\nfind_package：加载外部库到项目中 configure_file：默认定义了一些编译选项的值\noption：添加编译选项（更准确是代码中的宏定义）\n变量\n创建变量：set()，获取变量的值：${variable}，调用环境变量：$ENV{} 追加变量的值：set(SRC_LIST ${SRC_LIST} test.cpp) PROJECT_NAME PROJECT_BINARY_DIR、CMAKE_BINARY_DIR：编译路径，当前工程的二进制路径（即编译产物会存放到该路径，一般为build所在路径） PROJECT_SOURCE_DIR、CMAKE_SOURCE_DIR：工程根目录，即顶层CMakeLists.txt文件的路径 EXECUTABLE_OUTPUT_PATH：编译生成的可执行文件的路径 LIBRARY_OUTPUT_PATH：编译生成的共享库文件的路径 最佳实践 项目配置 在源文件同级目录下建立目录build，在build中 cmake ..：将cmake得到的中间文件保存在build文件夹中，需要重新构建直接删除文件夹 make：构建，可以使用make clean清除中间文件，重新构建 ","permalink":"https://qinganzhang.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%A7%91%E6%99%AE%E5%92%8C%E6%A2%B3%E7%90%86/","summary":"指令集架构 指令集 说明了操作种类、指令格式（操作码和地址码，地址码个数，操作码定长与拓展）、寻址方式、地址空间大小和寄存器个数等。简单可以理解","title":"计算机架构科普和梳理"},{"content":"本地搭建博客 本地环境：windows10\n使用主题：PaperModX\n安装过程 安装Go并配置环境\n下载prebuilt版本的hugo\n注意hugo有普通版本和extended版本，最好使用extended版本，因为在使用PaperModX主题时，需要使用到extended版本（但是PaperMod主题使用普通版本就可以） 新建站点：hugo new site myblog\n下载主题：在myblog/themes/下git clone git@github.com:reorx/hugo-PaperModX.git\n也可以使用git submodule的方式添加主题，此时方便进行版本控制和管理 本地配置 myblog/下的配置文件参考sulvblog\u0026rsquo;s config.yaml和PaperModX example\u0026rsquo;s config.yaml进行配置，自己慢慢调吧（papermodx在papermod的基础上添加了一些特性，比如侧边目录）\n个人主要进行的修改有：\n在archetypes/posts.md中设定默认的meta内容 修改为posts、archive、search、tags、categories、about六个menu，其中posts、categories、tags在content下为目录，archive、search、about在content下为md文件 在文件夹下创建_index.md文件可以在里面添加Front Matter，用来设置当前文件夹下的meta信息 在配置时留意是posts还是post，是archive还是archives 加入数学公式的支持 但是当使用带有/begin{} /end{}的多行公式，或者多行公式中含有若干下划线时，此时可能无法正确渲染，我的解决办法是将没有正确渲染的多行数学公式放在\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;标签对中，这样在网页博客和本地typora中都可以正常显示。考虑到平时不怎么写复杂的多行数学公式，因此手动修改也不多。 在Hugo中优雅地使用数学公式中，博主的方法三自己编译一份加入了goldmark数学插件的hugo版本，但是注意编译过程中gcc版本不宜过高（我的gcc原来是8.1.0，编译不过，后来改到5.1.0，编译通过）。但是最终使用好像针对原生latex的多行公式支持不足（？不确定，可能是自己后面配置不正确？），最后没有使用这个方案 调整了主页中Welcome部分的高度，在themes/hugo-PaperModX/assets/css/common/main.css的.first-entry中min-height修改为80px 调整了页面中内容的宽度（原来侧边留空感觉有点多，可以适当减小），themes/hugo-PaperModX/assets/css/common/main.css的.main.post中添加right: 60px; 在themes/hugo-PaperModX/assets/css/common/post-single.css中调整h1~h6标题的高度 内容管理 写文章：hugo new posts/文章名称.md，注意写对md文件的路径\n本地预览：hugo server -D在localhost:1313上进行预览\n-D表示draft: true的内容在预览时展示 有时将draft改为false，使用hugo server进行预览时，对应文章没有出现，此时关掉PowerShell重开一个，重新运行一下命令 构建：hugo会将构建的网站内容保存到public文件夹中，默认只会向public中添加内容，而不会删除外部不存在但是public中还存在的文件\nhugo -F --cleanDestinationDir表示每次生成的public都是全新的，会覆盖原来的 --theme指定主题，--baseURL=\u0026quot;xxx\u0026quot;指定url 将内容发布到GitHub Pages上 将public文件夹转换为git库：\n进入到public文件夹，git init -b main 生成的默认主分支名字为main 将git库关联到远程库：\ngit remote add origin git@github.com:QinganZhang/QinganZhang.github.io.git 检查是否关联成功：cat .git/config 如果[remote \u0026quot;origin\u0026quot;]信息正常显示，说明本地git库已经成功关联到远程库 将修改commit到本地库\n1 2 3 git status # 查看当前修改状态 git add . # 添加所有修改过的文件，也可以只添加某个文件 git commit -m \u0026#34;add a new post\u0026#34; # 将修改push到远程库\ngit push -u origin main --force 报错： error: src refspec main does not match any 本地的branch为master，但是远程库默认branch是main，先将本地branch的名字修改为main git branch -m master main 报错： ! [rejected] main -\u0026gt; main (fetch first) 提交冲突，远程库和本地库不一致。通常出现在初始化仓库有readme而本地没有等情况。参考 git pull --rebase origin main 查看是否部署成功\n网页样式（css）丢失，但是内容还在，浏览器F12控制台报错：Failed to find a vlid digest in the 'integrity' attribute for source 'xxx.css' with computed SHA-256 integrity '***'. The resource has been blocked. （关键词：”integrity“）\n尝试方法一：解决 hugo 中关于 integrity 的错误，仍然出现原来的错误\n尝试方法二：解决Hugo无法加载css文件，仍然出现原来的错误，而且第一遍文章会覆盖在h1标题Posts上，\n最终方法：在themes/hugo-PaperModX/layouts/partial/head.html中，将\n1 2 3 4 5 6 {{- if not site.Params.assets.disableFingerprinting }} {{- $stylesheet := $stylesheet | fingerprint }} \u0026lt;link crossorigin=\u0026#34;anonymous\u0026#34; href=\u0026#34;{{ $stylesheet.RelPermalink }}\u0026#34; integrity=\u0026#34;{{ $stylesheet.Data.Integrity }}\u0026#34; rel=\u0026#34;preload stylesheet\u0026#34; as=\u0026#34;style\u0026#34;\u0026gt; {{- else }} \u0026lt;link crossorigin=\u0026#34;anonymous\u0026#34; href=\u0026#34;{{ $stylesheet.RelPermalink }}\u0026#34; rel=\u0026#34;preload stylesheet\u0026#34; as=\u0026#34;style\u0026#34;\u0026gt; {{- end }} 注释掉，只保留\u0026lt;link crossorigin=\u0026quot;anonymous\u0026quot; href=\u0026quot;{{ $stylesheet.RelPermalink }}\u0026quot; rel=\u0026quot;preload stylesheet\u0026quot; as=\u0026quot;style\u0026quot;\u0026gt;这一行。猜想可能是与使用的主题相关，但是暂时没有找到使用相同主题类似错误的信息。\n更多参考：Hugo - Failed to find a valid digest in the \u0026lsquo;integrity\u0026rsquo; attribute for resource - The resource has been blocked - Host on Github\n使用GitHub Actions自动构建博客 使用上面的方式（手动构建），在本地写好博客之后，然后使用hugo在本地构建好静态博客，生成public目录，最终是将public目录push到GitHub仓库，构建静态博客。\n还有一种方式，看起来更加高级，那就是基于GitHub Action自动构建博客。大致流程为：在本地写好博客之后，直接push到远程GitHub仓库，在远端而非本地构建博客。这个方式只是节省了自己使用hugo手动进行构建的这一步，但是如果当自己手工进行操作的步骤比较繁琐且固定时，使用GitHub Action自动化就很方便了。\n在实际配置过程中，这里使用了两个仓库。一个是private的myblog仓库，本地写好博客后就push到这个myblog仓库；另一个仓库是public的、作为GitHub Pages的仓库，myblog仓库使用GitHub Action自动进行构建，将最终得到的public文件就放到这个仓库中。下面简要介绍基于Github Action自动构建博客的过程，着重介绍与上面手动构架不同的地方。\n具体过程：\n在Github远程新建一个仓库，比如命名为myblog\n在本地使用hugo新建站点时（比如hugo new site myblog），在本地myblog目录下git init -b main，并且使用git remote add将本地的myblog目录关联到远程myblog仓库\n注意之前手动构建的方式中，是在public目录下git init，并关联到远程仓库的，而且该远程仓库即为Github Pages 在下载主题时，可以直接git clone源码，也可以使用git submodule的方式将主题作为子项目添加进来\n注意git submodule的子模块和原来的主模块是两个单独的项目，所以进入到子模块和主模块中进行git操作，是针对不同仓库的。Git Submodules介绍 但是这里想将主题添加进来，自己进行一些修改，因此使用了另一种方法将主题添加进来：git subtree，这样可以直接将子项目作为主仓库的一个目录添加进来 git subtree的使用 在myblog根目录下，创建.github/workflows/deploy.yaml，个人的deploy.yaml配置文件为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 name: deploy on: # 表示GitHub Action的触发条件（即push） push: branches: - main # 设定触发的分支为main workflow_dispatch: # 可以在Github项目仓库的Action工具栏手动调用 # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write jobs: # 表示GitHub Action的任务，这里定义了一个build的任务 build: runs-on: ubuntu-latest # 指定GitHub Action的运行环境 env: HUGO_VERSION: 0.122.0 steps: # 其中run表示执行的命令，uses时GitHub Action中的一个插件 - name: Checkout # 使用actions/checkout插件检出GitHub仓库 uses: actions/checkout@v2 # with: # submodules: false # 同时检出子模块 # fetch-depth: 0 # 完整检出所有历史记录 - name: Setup Hugo # 使用peaceiris/actions-hugo插件来安装Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.122.0\u0026#34; # 0.122.0 extended: true - name: Build Web # 运行hugo命令生成博客的静态文件 env: HUGO_ENVIRONMENT: production HUGO_ENV: production run: hugo --gc --minify # --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v2 with: path: ./public - name: Deploy Web # 使用peaceiris/actions-gh-pages插件将静态网页部署到GitHub Pages上 uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_BLOG_TOKEN }} # 个人访问令牌 EXTERNAL_REPOSITORY: QinganZhang/QinganZhang.github.io # 部署到的GitHub Pages仓库 PUBLISH_BRANCH: main # Github Pages分支 PUBLISH_DIR: ./public # hugo静态文件的目录 commit_message: ${{ github.event.head_commit.message }} # 提交更改时使用的提交消息 # cname: ${{ secrets.DOMAIN }} # 自定义域名，默认使用github pages域名 # reference1: https://blog.csdn.net/m0_51993913/article/details/132657065 # reference2: https://blog.csdn.net/freeking101/article/details/135515958使用Github Actions自动化部署部分 # reference3: https://github.com/reorx/hugo-PaperModX/blob/master/.github/workflows/gh-pages.yml 然后生成Token，参考\n因为需要从myblog仓库推送public目录到Github Pages仓库，所以需要向myblog仓库添加身份验证凭据 最后将本地博客push到myblog远程仓库，然后myblog远程仓库下使用GitHub Actions将public目录推送到Github Pages仓库中\n其他问题：\n如何将obsidian双链转换为HTML的\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;标签对？ 目前发现的一个方案是jekyll-wililinks，但是这个方案需要使用jeklly搭建静态博客 ","permalink":"https://qinganzhang.github.io/posts/hugo+github_pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","summary":"本地搭建博客 本地环境：windows10 使用主题：PaperModX 安装过程 安装Go并配置环境 下载prebuilt版本的hugo 注意hugo","title":"Hugo+Github Pages搭建个人博客"},{"content":"41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递 一般C++传参方式有三种： 对左值引用和右值引用分别重载，需要实现两个版本 使用万能引用，使用时可能会实例化出多个版本，传参报错可读性差 传值： 可以考虑参数使用按值传递的情况： 构造（拷贝构造或移动构造）：对于可拷贝的，移动开销低的，并且总是会被拷贝的形参而言，按值传递和按引用传递的效率很接近，而且按值传递更容易实现，还可能会生成更少的目标代码，只是略微引入了一点性能开销 按值传递的前提是移动操作的成本足够低廉，因为按值传递比按引用传递多一次移动操作 只有当形参一定会被拷贝时，才考虑按值传递；比如有时函数开始先进行if检查，即使没有满足if条件而跳出函数，也会产生形参传值构造和析构的开销 赋值（拷贝赋值或移动赋值） 有时移动操作可能比直接拷贝开销更大：因为移动操作会涉及到原来对象的析构、新对象的构造，如果新对象比原来对象小，拷贝可以直接在原对象的位置上进行（具体见参考中的密码例子，如果新密码的长度比旧密码短，则新密码直接拷贝到旧密码的位置） 参考 https://blog.csdn.net/Dong_HFUT/article/details/127054642 42：考虑置入而非插入 push_back可能会创建中间临时对象，但是emplace_back使用完美转发（直接将参数匹配到构造函数），不会创建临时对象\n多数场景下使用emplace_back比push_back高效\n要插入的值是通过构造函数插入容器，而非赋值 赋值：比如emplace到容器begin，此时需要构造临时对象，然后将其移动到begin，此时emplace没有优势 传入参数的类型和容器元素的类型不同 如果传参类型和容器元素类型相同，也就不需要产生临时对象，emplace与push相同 如果某个元素值添加重复，会使用新创建的元素值替换为原来旧的元素值 使用注意：\n资源管理 1 2 3 std::list\u0026lt;std::shared_ptr\u0026lt;Widget\u0026gt;\u0026gt; ptrs; ptrs.push_back(std::shared_ptr\u0026lt;Widget\u0026gt;(new Widget, myDeleter)); // ok，不会发生内存泄露 ptrs.emplace_back(new Widget, myDeleter); // 如果emplace_back内部、调用构造函数之前发生异常，则会发生内存泄露 原因是延迟了资源管理对象的创建 因此要么使用make_shared创建智能指针，要么先创建一个临时对象然后move到emplace中 与显式构造函数的交互 参考\nhttps://blog.csdn.net/Dong_HFUT/article/details/127073175 ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch08-%E5%BE%AE%E8%B0%83/","summary":"41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递 一般C++传参方式有三种： 对左值引用和右值引用分别重载，需要实","title":"[Effective Modern Cpp Notes] Ch08 微调"},{"content":"","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch07-%E5%B9%B6%E5%8F%91api/","summary":"","title":"[Effective Modern Cpp Notes] Ch07 并发API"},{"content":"","permalink":"https://qinganzhang.github.io/posts/effective-cpp/effective-cpp-reading-notes/","summary":"","title":"Effective Cpp Reading Notes"},{"content":"","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/effective-modern-cpp-reading-notes/","summary":"","title":"Effective Modern Cpp Reading Notes"},{"content":"31：避免默认捕获模式 闭包：lambda所创建的运行期对象 默认捕获可能导致引用悬挂 默认传引用可能导致引用悬挂 显式传引用也可能导致引用悬挂，但是可以更容易发现此处可能有引用悬挂 默认传值捕获也可能导致引用悬挂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 std::vector\u0026lt;std::function\u0026lt;bool(int)\u0026gt;\u0026gt; filters; class Widget{ public: // void addFilter() const{ // filters.emplace_back( // [=](int value) {return value % divisor == 0;} // ); // 看似是传值捕获，不会有引用悬挂；但是lambda只能捕获作用域中的非静态局部变量，此处的divisor其实是this-\u0026gt;divisor，容易产生引用悬挂 // } // 解决方法：使用一个局部变量复制成员变量，然后使用显式的值捕获 void addFilter() const{ int divisorCopy = divisor; filters.emplace_back( [divisorCopy] (int value) {return value % divisorCopy == 0;} ); } private: int divisor; }; lambda只能捕获作用域中的非静态局部变量，无法捕获静态或全局变量 捕获表示将值拷贝到闭包类中，而lambda中使用静态或全局变量，相当于是对外部的引用，因此此时lambda不是独立的 参考 https://blog.csdn.net/Dong_HFUT/article/details/125037605 32：使用初始化捕获将对象移入闭包 C++14使用初始化捕获模式（也称广义lambda捕获）来实现移动捕获 1 2 3 4 5 struct Widget{ bool isValid() const; }; auto func = [pw = std::make_unique\u0026lt;Widget\u0026gt;()] // 左边是lambda闭包内成员名称，右边是初始化 {return pw-\u0026gt;isValid();} C++11使用std::bind间接实现移动捕获 1 2 3 4 5 6 7 struct Widget{ bool isValid() const; }; auto func = std::bind( [] (const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; pw) {return pw-\u0026gt;isValid();}, std::make_unique\u0026lt;Widget\u0026gt;() ); 参考 https://blog.csdn.net/Dong_HFUT/article/details/125111586 33：泛型lambda的完美转发版本 对auto\u0026amp;\u0026amp;类型的形参使用decltype，以std::forward之\n泛型lambda（C++14）：可以使用auto声明形参（即闭包类中的operator()可以使用模板实现） 1 2 3 4 5 6 7 auto f = [] (auto x) {return func(x);} // 闭包类中的operator()的大致实现：auto形参实际上是模板类型推导 class SomeCompilerGeneratedClassName{ public: template \u0026lt;typename T\u0026gt; auto operator() (T x) const {return func(x);} } 泛型lambda的完美转发版本： 1 2 3 4 5 6 7 8 9 auto f = [] (auto\u0026amp;\u0026amp; param) {return func( std::forward\u0026lt;decltype(param)\u0026gt;(param) );} // 闭包类中的operator()的大致实现 class SomeCompilerGeneratedClassName{ public: template \u0026lt;typename T\u0026gt; auto operator() (T\u0026amp;\u0026amp; param) const { return func( std::forward\u0026lt;decltype(param)\u0026gt;(param) ); } }; auto fs = [] (auto\u0026amp;\u0026amp;... params) {return func( std::forward\u0026lt;decltype(params)\u0026gt;(params)... );} // 变长参数版本 参考 https://blog.csdn.net/Dong_HFUT/article/details/125116613 34：优先选用lambda表达式，而非std::bind 对于C++11，除了个别边缘case，lambda比std::bind更有优势；C++14，lambda完全可以替代std::bind\nlambda可读性更强，更容易理解 使用std::bind需要保持参数位置，同时需要了解其实现机制 std::bind需要保持参数位置，因此使用时需要查看原来函数的声明，才能知道占位符对应的参数类型和参数含义；但是lambda形参列表很明确 std::bind默认将参数拷贝到绑定对象内部（可以使用std::ref指定传引用），但是lambda可以明确指出值捕获还是引用捕获 std::bind绑定对象的函数调用使用了完美转发机制，但是lambda可以从形参列表中清晰看出传值还是传引用 1 2 3 4 5 6 7 Widget w; Logger logger; auto f = [w, \u0026amp;logger] (CompressLevel level) { return compress(w, level, logger); } // 捕获对象：w值捕获，logger引用捕获；形参：level传值 auto g = std::bind(compress, w, std::placeholders::_1, std::ref(logger)); // 需要对应参数顺序 // 绑定对象：w值绑定（复制），logger引用绑定；形参：level使用完美转发机制 std::bind参数绑定和对象调用不是一个时间，因此可能出现逻辑错误（见参考） lambda灵活性更强 如果std::bind绑定的函数存在重载版本，则编译器无法确定使用哪个版本的重载函数 1 2 3 4 5 6 7 void func(int a); void func(int a, int b); auto f = [] (int b) { return func(0, b); } using funcType = void(int, int); auto bnd = std::bind(static_cast\u0026lt;funcType\u0026gt;(func), 0, std::placeholders::_1) lambda可以内联 因为std::bind中绑定的是函数指针，需要在运行时才能确定；但是lambda中包含函数体，可以进行内联 使用std::bind的两个场景：在C++11中 使用std::bind间接实现移动捕获（[[ch06-lambda表达式#32：使用初始化捕获将对象移入闭包|C++14支持移动捕获]]） 使用std::bind绑定参数的完美转发机制，间接多态函数对象（[[ch06-lambda表达式#33：泛型lambda的完美转发版本|C++14支持泛型lambda]]） 1 2 3 4 5 6 7 8 auto f = [callableObject] (const auto\u0026amp; param) { callableObject(param); }; class CallableObject{ public: template \u0026lt;typename T\u0026gt; void operator() (const T\u0026amp; param); }; auto g = std::bind(CallableObject(), std::placeholders::_1); // 将占位符参数完美转发到可调用对象的调用运算符中 参考 https://blog.csdn.net/Dong_HFUT/article/details/125130410 ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch06-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"31：避免默认捕获模式 闭包：lambda所创建的运行期对象 默认捕获可能导致引用悬挂 默认传引用可能导致引用悬挂 显式传引用也可能导致引用悬挂，但","title":"[Effective Modern Cpp Notes] Ch06 Lambda表达式"},{"content":"23：理解std::move和std::forward std::move：返回变量的右值引用 对const对象的移动操作会被转换为拷贝操作 因为const对象经过std::move会返回一个const右值引用，而一般函数重载的移动版本形参都是非const的右值引用，无法匹配 std::move不移动对象，而且也不保证对象一定被移动，仅仅返回对象的右值引用 1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; // C++14 decltype(auto) move(T\u0026amp;\u0026amp; param) { using ReturnType = remove_reference_t\u0026lt;T\u0026gt;\u0026amp;\u0026amp;; return static_cast\u0026lt;ReturnType\u0026gt;(param); } std::forward：实现完美转发（保持对象的左值性或右值性） 通常情况下，形参总是左值，即使其类型是右值引用 std::move和std::forward只是进行类型转换，在运行时不做任何事 参考 https://blog.csdn.net/Dong_HFUT/article/details/123765869 24：区分万能引用和右值引用 万能引用和右值引用只是形式上类似，但这是两个概念\n万能引用：形式为T\u0026amp;\u0026amp;或auto\u0026amp;\u0026amp;，并且存在类型推导 函数模板参数：template \u0026lt;typename T\u0026gt; void func(T\u0026amp;\u0026amp; param); auto类型推导：auto\u0026amp;\u0026amp; val = myVal; 1 auto myFunc = [] (auto\u0026amp;\u0026amp; func, auto\u0026amp;\u0026amp;... params) {/* do something */} 右值引用 带const（不是纯粹的T\u0026amp;\u0026amp;形式）：template \u0026lt;typename T\u0026gt; void func(const T\u0026amp;\u0026amp; param); 形式是T\u0026amp;\u0026amp;，但是不存在类型推导：比如vector的push_back，但是emplace_back中参数是万能引用 1 2 3 4 5 6 7 8 template \u0026lt;typename T, typename Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; class vector{ public: void push_back(T\u0026amp;\u0026amp; x); // 调用push_back时，类型T已知 template \u0026lt;typename... Args\u0026gt; void emplace_back(Args\u0026amp;\u0026amp;... args); // 参数包args的类型Args独立于T，存在类型推导，这里是万能引用 } 参考 https://blog.csdn.net/Dong_HFUT/article/details/123773321 25：针对右值引用实施std::move，针对万能引用实施std::forward 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Widget{ // 以例子来说明 public: Widget(Widget\u0026amp;\u0026amp; rhs): name(std::move(rhs.name)), sp(std::move(rhs.sp)) {} // 形参为右值引用，将形参（左值）进行移动 template \u0026lt;typename T\u0026gt; void setName(T\u0026amp;\u0026amp; newName){ // 形参为万能引用，保持形参的左值性或右值性 cout\u0026lt;\u0026lt;\u0026#34;set new name:\u0026#34;\u0026lt;\u0026lt;newName\u0026lt;\u0026lt;endl; name = std::forward\u0026lt;T\u0026gt;(newName); // 在函数中使用move或forward时，使用的位置应该是该参数最后一次使用的时候 } Widget operator+(Widget\u0026amp;\u0026amp; lhs, Widget\u0026amp;\u0026amp; rhs){ lhs.name += rhs.name; return std::move(lhs); } template \u0026lt;typename T\u0026gt; T doNothing(T\u0026amp;\u0026amp; t) { return std::forward\u0026lt;T\u0026gt;(t); } private: string name; shared_ptr\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; sp; }; 重载setName不是一个好的设计 可能效率低：如果传入字面量，即使匹配到右值版本的函数，形参仍然会作为临时对象 如果有多个参数，需要重载$2^N$种，如果使用参数包，则无法实现 在函数中使用move或forward时，使用的位置应该是该参数最后一次使用的时候 如果函数中将形参进行处理，然后返回 传值返回：如果形参是右值引用（比如Widget operator+成员函数），使用move返回；如果形参是万能引用（比如doNothing成员函数），使用forward返回 如果返回值是函数中的局部变量，则编译器有特定的优化：RVO 返回值优化RVO（Return Value Optimization）：减少函数返回时产生临时对象，进而消除部分拷贝或移动操作 1 2 3 4 5 6 7 8 9 10 11 12 // 原来 Widget func() { return Widget(); } // 有一次默认构造，一次拷贝构造 Widget w = func(); // 再加上一次拷贝构造 // 使用RVO优化，上面过程相当于： void func(Widget\u0026amp; w) { w.Widget::Widget(); } // Widget w在外面分配空间，直接传入func中进行构造，因此只需要一次（默认）构造 // NRVO(Named Return Value Optimization)原理类似 Widget func() { Widget w; return w; // 返回对象已经具名 } 使用前提：局部对象的类型和返回值类型相同，而且局部对象就是返回值 限制场景： 返回std::move()：默认构造+移动构造 进行赋值而非初始化Widget w; w = func();：默认构造+func中的默认构造和拷贝构造 不同的分支条件下，返回不同的局部对象 参考 https://blog.csdn.net/Dong_HFUT/article/details/123946594 26：避免依万能引用类型进行重载 原因：函数匹配规则 如果模板实例化出的函数和普通重载函数都精确匹配，则优先选择普通重载函数，其次选择模板函数实例化出来的精确版本 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Person{ public: explicit Person(int idx): _name(nameFromIdx(idx)) {} template \u0026lt;typename T\u0026gt; // 对Person(int)的重载 explicit Person(T\u0026amp;\u0026amp; name): _name(std::forward\u0026lt;T\u0026gt;(name)) {} private: std::string _name; }; short id = 1; Person p1(id); // 会调用模板实例化的版本，而非进行类型转换调用普通版本 const Person p2(id); // 这个情况极其容易混淆， Person q2(p2); // 会调用生成的拷贝构造函数（因为其实参为const Person\u0026amp;） Person q1(p1); // 会调用模板实例化的版本，而非调用生成的拷贝构造函数 // 尤其当Person作为基类，派生类在构造函数中初始化基类部分时 class SpecialPerson: public Person{ public: SpecialPerson(const SpecialPerson\u0026amp; rhs): Person(rhs) {} SpecialPerson(SpecialPerson\u0026amp;\u0026amp; rhs): Person(std::move(rhs)) {} // 这两个构造函数均使用基类Person构造函数的完美转发版本， } // 对万能引用参数的函数进行重载，不是一个好的设计 27：熟悉依万能引用类型进行重载的替代方案 放弃重载，使用不同的函数名\n但是对于构造函数就无能为力 普通函数形参为const type\u0026amp;类型\n因此传入const实参，会优先使用原来的普通版本，而非重载的万能引用版本 将形参从引用类型换成值类型：当知道肯定要复制形参时，考虑按值传递\n1 2 3 4 5 6 7 class Person{ public: explicit Person(std::string name): _name(std::move(name)) {} explicit Person(int idx): name(nameFromIdx(idx)) {} private: std::string _name; } 使用Tag分发：使用Tag对参数进行区分，进而分发到不同的函数实现\n背景：如果想使用完美转发，就必须要使用万能引用 例子： 1 2 3 4 5 6 7 8 9 10 // 两个函数实现的版本 template \u0026lt;typename T\u0026gt; void logAndAddImpl(T\u0026amp;\u0026amp; name, std::false_type) {} template \u0026lt;typename T\u0026gt; void logAndAddImpl(int idx, std::true_type) {} // 使用Tag对参数进行区分 template \u0026lt;typename T\u0026gt; void logAndAdd(T\u0026amp;\u0026amp; name) { logAndAddImpl( std::forward\u0026lt;T\u0026gt;(name), std::is_integral\u0026lt;typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026gt;() ); // 或者C++14：std::is_integral\u0026lt;typename std::remove_reference_t\u0026lt;T\u0026gt; } 如果传入true or false，到运行时才能决定 在编译阶段进行模板匹配，std::is_integral在编译阶段就可以判断类型是否为整型 约束接受万能引用的模板：std::enable_if判断\n背景：构造函数无法使用Tag分发 例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;type_traits\u0026gt; class Person{ public: explicit Person(int idx): _name(nameFromIdx(idx)) {} template\u0026lt;typename T, typename = std::enable_if_t\u0026lt; !std::is_base_of_v\u0026lt;Person, std::decay_t\u0026lt;T\u0026gt;\u0026gt; \u0026amp;\u0026amp; !std::is_integral_v\u0026lt;std::remove_reference_t\u0026lt;T\u0026gt;\u0026gt; \u0026gt; \u0026gt; // 当类型T不为Person或者其派生类，抑或T不为int型时，才会选择这个的重载版本，使用万能引用进行重载并实现完美转发 explicit Person(T\u0026amp;\u0026amp; name): _name(std::forward\u0026lt;T\u0026gt;(name)) { static_assert( std::is_constructible(std::string, T)::value, \u0026#34;Parameter name can\u0026#39;t be used to construct a std::string\u0026#34; ); // 验证类型为std::string的对象能否被类型为T的对象构造 } private: std::string _name; }; std::enable_if\u0026lt;condition\u0026gt;::type：只有满足条件的模板才会使用（C++14std::enable_if_t） std::is_same\u0026lt;T1, T2\u0026gt;::value（C++17std::is_same_v） std::is_base_of\u0026lt;T1, T2\u0026gt;::value：如果T2继承于T1，则为true；且std::is_base_of\u0026lt;T, T\u0026gt;::value==true（C++17std::is_base_of_v） std::decay\u0026lt;T\u0026gt;::type的类型与T的类型相同，忽略了引用、const、volatile（C++14std::decay_t） 权衡\n前三种方案都需要对需要调用的函数形参逐一指定其类型，后两种方案使用万能引用实现了完美转发 虽然完美转发效率更高（避免创建临时对象），但是某些对象无法实现完美转发，并且使用完美转发并编译报错时，报错信息的可读性很差 std::is_constructible可以在编译期测试一个类型的对象能否被另一个不同类型的对象（或者多个不同类型的多个对象）构造，因此可以用来验证转发函数的万能引用参数是否合法 参考\nSFINAE技术 https://blog.csdn.net/Dong_HFUT/article/details/124227488 28：理解引用折叠 几种引用折叠的应用场景： 万能引用的实例化：在模板类型推导时，可能出现“引用的引用”的情况，此时需要用到引用折叠 std::forward完美转发： 1 2 3 4 template \u0026lt;typename T\u0026gt; T\u0026amp;\u0026amp; forward(typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp; param){ return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(param); } auto类型推导，decltype类型推导 typedef类型别名 参考 https://blog.csdn.net/Dong_HFUT/article/details/124517043 29：假定移动操作不存在、成本高、未使用 几种移动语义不可用、不高效的情况： 没有移动操作：编译器只有在没有用户自定义拷贝操作和析构函数时，才自动生成移动操作 移动未能更快： std:array 一般STL中容器的对象都分配在堆上，对象中有指向堆上内存的指针，因此移动操作只需要进行指针的更新、源对象的指针置空即可 但是std::array中内容分配在栈上（栈上的数组），移动操作等于复制操作 std::string std::string针对小对象有一个优化SSO（Small String Optimization），小对象直接存储在栈上而非堆上，省去动态内存分配 移动不可用：移动操作没有标记为noexcept 如果移动操作没有标记为noexcept，即使是适合使用移动操作的场景，编译器也会使用复制操作替代 源对象是左值：只有右值可以作为移动操作的源（左值可以用，但是很容易造成空悬问题） 参考 https://blog.csdn.net/Dong_HFUT/article/details/124577258 30：熟悉完美转发的失败情形 完美转发的含义：不仅转发对象，而且转发其特征（左值、右值、const、volatile） 完美转发的失败情形 列表初始化 1 2 3 4 5 6 7 8 void f(const std::vector\u0026lt;int\u0026gt;\u0026amp; v) {} template \u0026lt;typename T\u0026gt; void fwd(T\u0026amp;\u0026amp; param) {} f({1,2,3}); // ok fwd({1,2,3}); // 编译报错：无法推断出T的类型 auto il = {1,2,3}; fwd(il); // T=initializer_list\u0026lt;int\u0026gt; 0或NULL作为空指针 0或NULL会被推导为int型而非空指针类型，因此完美转发后得到的类型是int，但是形参是指针类型 仅仅声明整型的静态常量数据成员 1 2 3 4 5 class Widget{ public: static cosnt int cnst = 12; // 声明而非定义，不会分配实际的存储空间，而是常量传播（直接将用到cnst的地方替换为12） }; fwd(Widget::cnst); // 编译报错：找不到cnst的定义 只声明不会分配空间，因此无法取地址，也无法使用引用，不能使用完美转发 解决方法：在类外或是对应.cpp文件中添加定义：const int cnst = 12; 函数重载和函数模板 1 2 3 4 5 6 7 8 9 10 void f(int (*pf)(int)); int func(int a); int func(int a, int b); f(func); // ok fwd(func); // 模板类型推导失败：无法确定是哪个重载版本 // 解决方法： using FuncType = int (*)(int); fwd(static_cast\u0026lt;FuncType\u0026gt;(func)); // 但是万能引用和完美转发一般是针对任意类型的，这里限定了类型，语义与实现矛盾 位域：位域只是int类型的一部分，没有一个确切地址，也就无法引用 参考 https://blog.csdn.net/Dong_HFUT/article/details/124787082 ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch05-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/","summary":"23：理解std::move和std::forward std::move：返回变量的右值引用 对const对象的移动操作会被转换为拷贝操作 因为","title":"[Effective Modern Cpp Notes] Ch05 右值引用、移动语句和完美转发"},{"content":"18：使用std::unique_ptr管理具备专属所有权的资源 std::unique_ptr表示独占所有权，因此无法拷贝（拷贝构造、拷贝赋值是delete的），只能进行移动操作从而转移资源控制权 例外：可以从函数返回一个std::unique_ptr 1 2 3 4 5 std::unique_ptr\u0026lt;int\u0026gt; func(int x){ auto delInt = [\u0026amp;](int* p) { cout\u0026lt;\u0026lt;\u0026#34;My deleter\u0026#34;\u0026lt;\u0026lt;endl; delete p;} std::unique_ptr\u0026lt;int, decltype(delInt)\u0026gt; pInt(new int(x), delInt); return pInt; } 删除器是std::unique_ptr类型的一部分 在不定义删除器的情况下，std::unique_ptr内存占用和原始指针相同 如果自定义删除器，则std::unique_ptr内存占用会变大 std::unique_ptr可以指向数组，默认删除器为delete[]：std::unique_ptr\u0026lt;int[]\u0026gt; p(new int[5]{1,2,3,4,5}); 但是数组形式用到的场合很少，尽量使用STL std::unique_ptr可以直接隐式转换为std::shared_ptr 典型应用：针对继承体系，作为工厂函数的返回值类型 1 2 3 4 5 6 7 8 9 10 11 class Animal {}; class Dog: public Animal {}; class Cat: public Animal {}; template \u0026lt;typename... Ts\u0026gt; auto makeAnimal(AnimalType type, Ts\u0026amp;\u0026amp;... AnimalInfo){ // C++14中函数返回值可以写为auto，因此unique_ptr的删除器可以放在函数内部，否则显式写出返回类型时需要知道删除器类型，因此删除器只能写在函数外部 auto delAnimal = [](AnimalType* ptr) { makeMyLog(ptr); delete ptr; } std::unique_ptr\u0026lt;Animal, decltype(delAnimal)\u0026gt; up(nullptr, delAnimal); if(type == Dog) up.reset(new Dog(std::forward\u0026lt;Ts\u0026gt;(AnimalInfo)...)); // 参数是万能引用，这里进行完美转发 if(type == Cat) up.reset(new Cat(std::forward\u0026lt;Ts\u0026gt;(AnimalInfo)...)); // 使用reset使得指针独占资源的所有权，不能直接将原始指针赋值给智能指针 return up; // 返回unique_ptr } 参考 https://blog.csdn.net/Dong_HFUT/article/details/123465058 19：使用std::shared_ptr管理具备共享所有权的资源 std::shared_ptr可以拷贝，通过引用计数来管理资源的生命周期 std::shared_ptr内存模型 一个std::shared_ptr大小通常为普通指针的两倍：一个指针指向资源，另一个指针指向控制块 控制块中通过原子操作维护引用计数，保存deleter（因此deleter不属于std::shared_ptr类型的一部分），保存弱计数等 std::shared_ptr的使用： 使用std::make_shared、std::unique_ptr、原始指针创建std::shared_ptr，会为资源创建一个控制块 如果资源有多个控制块，就会被多次析构，因此尽量避免使用原始指针构造std::shared_ptr 使用std::shared_ptr或std::weak_ptr创建一个std::shared_ptr，不会创建一个新的控制块 this的陷阱： 1 2 3 4 5 6 7 8 9 10 11 vector\u0026lt;shared_ptr\u0026lt;Animal\u0026gt;\u0026gt; eatList; // 追踪哪些Animal调用了eat方法 struct Animal{ virtual void eat(){ eatList.emplace_back(this); // eatList.push_back(shared_ptr\u0026lt;Animal\u0026gt;(this)); } }; struct Cat: public Animal{}; struct Dog: public Animai{}; shared_ptr\u0026lt;Animal\u0026gt; myCat(new Cat); myCat-\u0026gt;eat(); // 针对同一个对象创建了两个控制块 解决方法一：使类继承自std::enable_shared_from_this，类内部使用shared_from_this方法，搜索当前对象的控制块，如果有就不用创建控制块了，如果没有则抛出异常，因此适合于当前对象已经创建过控制块的情况 1 2 3 4 5 6 7 8 9 10 11 vector\u0026lt;shared_ptr\u0026lt;Animal\u0026gt;\u0026gt; eatList; // 追踪哪些Animal调用了eat方法 struct Animal: public std::enable_shared_from_this\u0026lt;Animal\u0026gt;{ virtual void eat(){ eatList.emplace_back(shared_from_this()); // eatList.push_back(shared_ptr\u0026lt;Animal\u0026gt;(shared_from_this())); } }; struct Cat: public Animal{}; struct Dog: public Animai{}; shared_ptr\u0026lt;Animal\u0026gt; myCat(new Cat); myCat-\u0026gt;eat(); 解决方法二：见127页，代码是自己实现的，有误 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;shared_ptr\u0026lt;Animal\u0026gt;\u0026gt; eatList; // 追踪哪些Animal调用了eat方法 struct Animal: public std::enable_shared_from_this\u0026lt;Animal\u0026gt;{ public: template \u0026lt;typename... Ts\u0026gt; static shared_ptr\u0026lt;Animal\u0026gt; create(Ts\u0026amp;\u0026amp;... params) { return shared_ptr\u0026lt;Animal\u0026gt;(Animal(std::foward\u0026lt;Ts\u0026gt;(params)...)); } virtual void eat(){ eatList.emplace_back(shared_from_this()); // eatList.push_back(shared_ptr\u0026lt;Animal\u0026gt;(shared_from_this())); } private: Animal() {} // 构造函数 }; struct Cat: public Animal{}; struct Dog: public Animai{}; 参考 https://blog.csdn.net/Dong_HFUT/article/details/123599599 20：对于类似std::shared_ptr但是可能空悬的指针使用std::weak_ptr std::weak_ptr通常视为std::shared_ptr的辅助工具，通过std::shared_ptr构造std::weak_ptr std::weak_ptr不会影响对象的引用计数 但是std::weak_ptr没有解引用操作，必须调用lock转换为std::shared_ptr来访问对象 例子：if(shared_ptr\u0026lt;int\u0026gt; p = wp.lock()\u0026gt; cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;endl; 典型应用： 避免shared_ptr循环引用：将其中一个shared_ptr改为weak_ptr 1 2 3 4 5 6 7 8 9 10 struct A{ std::shared_ptr\u0026lt;B\u0026gt; pb; // std::weak_ptr\u0026lt;B\u0026gt; pb; }; struct B{ std::shared_ptr\u0026lt;A\u0026gt; pa; }; std::shared_ptr\u0026lt;A\u0026gt; pa = std::make_shared\u0026lt;A\u0026gt;(); std::shared_ptr\u0026lt;B\u0026gt; pb = std::make_shared\u0026lt;B\u0026gt;(); pa-\u0026gt;pb = pb; // pb和pa-\u0026gt;pb同时指向同一个对象B，引用计数为2 pb-\u0026gt;pa = pa; 带缓存的工厂方法 1 2 3 4 5 6 7 8 9 std::shared_ptr\u0026lt;const Widget\u0026gt; fastLoadWidget(WidgetID id){ static std::unordered_map\u0026lt;WidgetID, weak_ptr\u0026lt;const Widget\u0026gt;\u0026gt; cache; std::shared_ptr\u0026lt;const Widget\u0026gt; widgetPtr = cache[id].lock(); if(!widgetPtr){ // 缓存中没有 widgetPtr = loadWidget(id); // 调用原始工厂方法创建，并加入到缓存中 cache[id] = widgetPtr; } return widgetPtr; } 观察者设计模式：多个观察者（observer）对象同时监听一个主题（subject）对象，主题对象会在其发生状态改变时发出通知。主题对象不会控制其观察者的生存期，但需要确认当一个观察者对象被析构后，主题对象不会再访问它。一种合理的设计就是让每个主题对象持有指向其观察者对象的std::weak_ptr，以便在使用之前确认它是否空悬。 参考： https://blog.csdn.net/Dong_HFUT/article/details/123612236 21：优先选用std::make_unqiue和std::make_shared，而非直接使用new make函数可以传入任意集合的参数，然后完美转发给构造函数，并动态创建一个对象，返回智能指针 支持auto 避免异常：将[[ch03-资源管理#17：以独立语句将new的对象置入智能指针| effective C++ item17：以独立语句将new的对象置入智能指针]]改进为使用make函数 1 2 3 4 5 6 7 void func(shared_ptr\u0026lt;Widget\u0026gt; sp, int priority); void func(shared_ptr\u0026lt;Widget\u0026gt;(new Widget), priority); // 可能由于异常导致内存泄露 void func(make_shared\u0026lt;Widget\u0026gt;(), priority); // 不会由于异常导致内存泄露 // 如果需要自定义删除器，并且又可以避免异常 shared_ptr\u0026lt;Widget\u0026gt; sp(new Widget, myDeleter); func(std::move(sp), priority); // 直接传递一个右值，避免了修改引用计数 效率更高：make函数只需要申请一次内存（同时存储对象和控制块），但是使用shared_ptr\u0026lt;Widget\u0026gt;(new Widget)需要申请两次内存（一次对象，一次控制块） make函数的缺点： 无法自定义deleter 语义歧义：比如使用()和{}初始化vector代表不同的方式，make函数可以完美转发()，不支持完美转发{} 1 2 3 4 auto sp1 = make_shared\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(2,3); // {3,3}; shared_ptr\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; sp2(new vector{1,2,3,4,5}); auto initList = {1,2,3,4,5}; auto sp3 = make_shared\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(initList); // 不支持：make_shared\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;({1,2,3,4,5}); 不建议对自定义内存管理方式的类使用 make 函数：通常情况下，类自定义的operator new和operator delete被设计成用来分配和释放能精确容纳该类大小的内存块，但std::allocate_shared所要求的内存大小并不等于动态分配对象的大小，而是在其基础上加上控制块的大小。 若存在非常大的对象和比相应的std::shared_ptr生存期更久的std::weak_ptr，不建议使用 make 函数，会导致对象的析构和内存的释放之间产生延迟 如果只申请一块内存（make函数），如果后来shared_ptr的引用计数为0，但是weak_ptr的引用计数不为0时，对象销毁会被延长，只有当weak_ptr的引用计数为0时，控制块才被释放 如果使用new的话，可以立即销毁对象 参考 https://blog.csdn.net/Dong_HFUT/article/details/123622543 22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中 PImpl技术（Pointer to Implementation，编译防火墙）：将类的实现放在另一个单独的类中，并通过不透明的指针进行访问。因此可以有效减少编译依赖。 原理：一个只声明但是不定义的类型是不完整类型，声明指向它的指针是可以通过编译的 常见错误： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // in \u0026#34;widget.h\u0026#34; #include \u0026lt;memory\u0026gt; class Widget { public: Widget(); private: struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; pImpl; }; //==================================================================================// // in \u0026#34;widget.cpp\u0026#34; #include \u0026#34;widget.h\u0026#34; #include \u0026lt;string\u0026gt; struct Widget::Impl { std::string name; }; Widget::Widget(): pImpl(std::make_unique\u0026lt;Impl\u0026gt;()){} //==================================================================================// // in \u0026#34;main.cpp\u0026#34; #include \u0026#34;widget.h\u0026#34; int main(){ Widget w; // 报错：/usr/include/c++/9/bits/unique_ptr.h:79:16: error: invalid application of ‘sizeof’ to incomplete type ‘Widget::Impl’ return 0; } 报错原因：在析构Widget w时，此时看到的Impl是不完整类型 在编译widget.cpp时没有问题：g++ -c widget.cpp -o widget.o 在编译main.cpp时出问题：g++ -c main.cpp -o main.o 没有定义Widget的析构函数，因此使用自动生成的析构函数（默认是inline的） 本来如果声明了Widget的析构函数，编译时无法进行处理，后面链接时链接到定义，运行时才能析构pImpl（因为经过链接，此时也知道Impl是完整类型） 但是正因为自动生成的析构函数是inline的，编译时就可以展开，此时析构pImpl当然看到的Impl是不完整类型（还没有链接到widget.o） 使用说明 考虑到如上报错和[[ch03-转向现代C++#17：理解特殊成员函数的生成机制|item17：理解特殊成员函数的生成机制]]，因此最好将拷贝控制成员和析构函数自定义，且声明与实现分离（防止进行内联） 为了实现PImpl技术，使用unique_ptr是最合适的，因为pImpl指针独享Impl的所有权，如果使用shared_ptr则上述报错不会出现（因为删除器不属于类型的一部分，属于控制块，不会包含删除器的代码） 参考 https://blog.csdn.net/Dong_HFUT/article/details/123704824 https://github.com/liuzengh/CppIdioms/blob/main/code/pimpl/person.cpp 实例 widget.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;memory\u0026gt; class Widget{ public: Widget(std::string s); Widget(const Widget\u0026amp; rhs); Widget\u0026amp; operator=(const Widget\u0026amp; rhs); Widget(Widget\u0026amp;\u0026amp; rhs); Widget\u0026amp; operator=(Widget\u0026amp;\u0026amp;); ~Widget(); std::string getName() const; private: // std::string _name; struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; pImpl; }; widget.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026#34;widget.h\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; struct Widget::Impl{ Impl(std::string name): _name(name) {}; std::string _name; std::string getName() const {return _name;} }; Widget::Widget(std::string s): pImpl(std::make_unique\u0026lt;Impl\u0026gt;(s)) {} Widget::~Widget() {} Widget::Widget(const Widget\u0026amp; rhs): pImpl(std::make_unique\u0026lt;Impl\u0026gt;(*rhs.pImpl)) {} Widget\u0026amp; Widget::operator=(const Widget\u0026amp; rhs){ *pImpl = *rhs.pImpl; return *this; } Widget::Widget(Widget\u0026amp;\u0026amp; rhs) =default; Widget\u0026amp; Widget::operator=(Widget\u0026amp;\u0026amp; rhs) =default; std::string Widget::getName() const { return pImpl-\u0026gt;getName();} main.cpp 1 2 3 4 5 6 7 8 #include \u0026#34;widget.h\u0026#34; #include \u0026#34;iostream\u0026#34; int main(){ Widget w(\u0026#34;zhang\u0026#34;); std::cout\u0026lt;\u0026lt;w.getName()\u0026lt;\u0026lt;std::endl; return 0; } ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch04-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","summary":"18：使用std::unique_ptr管理具备专属所有权的资源 std::unique_ptr表示独占所有权，因此无法拷贝（拷贝构造、拷贝赋","title":"[Effective Modern Cpp Notes] Ch04 智能指针"},{"content":"07：在创建对象时注意区分()和{} 初始化方式 1 2 3 4 int x1(1); int x2 = 2; int x3{3}; // 统一初始化（列表初始化） int x4 = {4}; // 和第三种方式相同 ()和=初始化的限制 ()不能用于non-static成员的初始化 不能拷贝的对象不能使用()初始化 {}初始化的优点 禁止基本类型之间的隐式窄化类型转换：比如不能使用double初始化int型变量 避免了C++复杂的语法分析：C++\u0026rsquo;s most vexing parse 1 2 3 Widget w1(10); // 传入一个实参，构造出一个对象 Widget w2(); // 本来想调用无形参的构造函数构造一个对象，但是实际上声明了一个函数 Widget w3{}; // 调用无形参的构造函数，构造出一个对象 {}的缺陷 auto类型推导中使用{}进行初始化，则auto被推断为initializer_list\u0026lt;T\u0026gt; 会优先使用形参为initializer_list\u0026lt;T\u0026gt;的构造函数，即使其他的构造函数更加匹配 只有当{}中参数无法转换为initializer_list中类型时，编译器才匹配普通函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Widget{ public: Widget() {cout\u0026lt;\u0026lt;\u0026#34;0\u0026#34;\u0026lt;\u0026lt;endl;} Widget(int i, int d) {cout\u0026lt;\u0026lt;\u0026#34;1\u0026#34;\u0026lt;\u0026lt;endl;} Widget(int i, bool d) {cout\u0026lt;\u0026lt;\u0026#34;2\u0026#34;\u0026lt;\u0026lt;endl;} Widget(initializer_list\u0026lt;int\u0026gt; il) {cout\u0026lt;\u0026lt;\u0026#34;2\u0026#34;\u0026lt;\u0026lt;endl;} Widget(const Widget\u0026amp; w) {cout\u0026lt;\u0026lt;\u0026#34;copy ctor\u0026#34;\u0026lt;\u0026lt;endl;} Widget(Widget\u0026amp;\u0026amp; w) {cout\u0026lt;\u0026lt;\u0026#34;move copy ctor\u0026#34;\u0026lt;\u0026lt;endl;} operator int() const { cout\u0026lt;\u0026lt;\u0026#34;convert to int\u0026#34;\u0026lt;\u0026lt;endl; return 1; } }; Widget w1{1, true}; // 调用Widget(initializer_list\u0026lt;int\u0026gt; il)，即使Widget(int i, bool d)更加匹配 Widget w2{1, 1.0}; // 编译报错，本来调用Widget(initializer_list\u0026lt;int\u0026gt; il)，但是使用{}初始化禁止窄化类型转换（存在从double到int的转换） Widget w3{w1}; // 调用Widget(initializer_list\u0026lt;int\u0026gt; il)（中间先将w1转为int），即使Widget(const Widget\u0026amp; w)更加匹配（如果w1无法转换为int，则调用该构造函数） Widget w4{std::move(w1)}; // 调用Widget(initializer_list\u0026lt;int\u0026gt; il)，即使Widget(Widget\u0026amp;\u0026amp; w)更加匹配 // 特殊情况： Widget w4{}; // 调用Widget()，而非调用Widget(initializer_list\u0026lt;int\u0026gt; il) Widget w5{{}}; // 调用Widget(initializer_list\u0026lt;int\u0026gt; il)，而非调用Widget() Widget w6({}); // 调用Widget(initializer_list\u0026lt;int\u0026gt; il)，而非调用Widget() 使用模板创建对象时，仔细考虑使用()还是{}进行初始化 标准库函数std::make_unique和std::make_shared也面临着这个问题，它们的解决方案是在内部使用小括号，并将这个决定写进文档中，作为其接口的组成部分。 1 2 3 4 5 6 7 8 9 template \u0026lt;typename T, typename... Ts\u0026gt; void f(Ts\u0026amp;\u0026amp;... params){ // 使用可变参数模板 T localVector1(std::forward\u0026lt;Ts\u0026gt;(params)...); T localVector2{std::forward\u0026lt;Ts\u0026gt;(params)...}; } f\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(3,4); // 推断出T=vector\u0026lt;int\u0026gt;, Ts=int // localVector1: 4,4,4 // localVector2: 3,4 参考 https://blog.csdn.net/Dong_HFUT/article/details/122811753 08：优先选用nullptr，而非0或NULL 字面量0是一个int，NULL的实现为0L，可以转换为int，bool，void* nullptr可以理解为任意类型的空指针 使得重载函数的调用明确 提高代码的清晰度 使用类型推导时，nullptr可以隐式转换为任意类型指针 参考 https://blog.csdn.net/Dong_HFUT/article/details/122891898 09：优先选用别名声明，而非typedef using别名的优点： 清晰，比typedef更容易理解 可以直接对模板起别名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename T\u0026gt; using MyAllocList = std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt;; // 如果非要使用typedef，需要包装一层 template \u0026lt;typename T\u0026gt; struct MyAllocList{ typedef std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt; type; }; template \u0026lt;typename T\u0026gt; class Widget{ MyAllocList\u0026lt;T\u0026gt; list1; // list1=std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt;,此时MyAllocList一定是一个别名 typename MyAllocList\u0026lt;T\u0026gt;::type list2; // list2=MyAllocList\u0026lt;T\u0026gt;中的std::list\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt; // 需要使用typename显式说明MyAllocList\u0026lt;T\u0026gt;::type是一个类型，而非数据成员 } 应用：标准库的\u0026lt;type_traits\u0026gt;中提供了一整套用于类型转换的类模板 虽然C++11中仍然是使用typedef实现的，但是C++14中是使用using声明实现的 1 2 std::remove_const\u0026lt;T\u0026gt;::type // C++11中, 是一个内部包裹typedef的类模板，将T中的const属性移除 std::remove_const_t\u0026lt;T\u0026gt; // C++14中, 是一个类模板中typedef别名的别名，将T中的const属性移除 参考 https://blog.csdn.net/Dong_HFUT/article/details/122847510 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型 无作用域限制的枚举（unscoped enums，C++98） 有时使用可能简便一点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 using UserInfo = std::tuple\u0026lt;std::string, std::string, std::size_t\u0026gt; //name, email,age enum UserInfoFields {uiName, uiEmail, uiAge}; UserInfo uInfo; auto email = std::get\u0026lt;1\u0026gt;(uInfo); // 位置1为email auto email = std::get\u0026lt;uiEmail\u0026gt;(uInfo); // 发生隐式类型转换 auto email = std::get\u0026lt;static_cast\u0026lt;std::size_t\u0026gt;(UserInfoFields::uiEmail)\u0026gt;(uInfo); // 冗余 // C++14下的辅助类:既想使用有作用限制的枚举，又不想过于啰嗦 template \u0026lt;typename E\u0026gt; constexpr auto toUType(E enumerator) noexcept { return static_cast\u0026lt;std::underlying_type_t\u0026lt;E\u0026gt;\u0026gt;(enumerator); } auto email = std::get\u0026lt;toUType(UserInfoFields::uiEmail)\u0026gt;(uInfo); 有作用域限制的枚举（scoped enums，C++11） 减少名称污染 1 2 3 4 5 enum unscopedColor{black, white}; auto black = false; // 无作用域限制的枚举，因此枚举类型暴露在{}之外 enum class scopedColor {red, blue}; auto red = false; // 有作用域限制的枚举，枚举类型限制在{}之内，因此减少名称污染 有强类型 1 2 3 4 5 enum unscopedColor{black, white}; double d1 = black; // 无作用域限制的枚举，可以发生隐式类型转换 enum class scopedColor {red, blue}; double d2 = static_cast\u0026lt;double\u0026gt;(scopedColor::red); // 有作用域限制的枚举，不会发生隐式类型转换，类型转换需要显式说明 可以前向声明：只有在指定底层类型后，才能进行前向声明 1 2 enum unscopedColor: std::uint8_t; // 没有提供默认底层类型 enum class; //默认底层类型为int 参考 https://blog.csdn.net/Dong_HFUT/article/details/122914289 11：优先选用删除函数，而非private未定义函数 背景：编译期会自动生成某些函数，但是有时不需要这些函数； C++98的做法：声明为private的，且只声明不定义（effective C++中item6） 在private中声明但是不定义，使之在链接阶段因为没有定义而报错 在基类中声明为private的，会因为无法拷贝控制派生类中的基类部分，将报错从链接期提前到编译期 C++11的做法：在声明中标记为=delete 将删除的函数声明为public的，原因是编译器先检查访问权限，再检查delete状态。如果将删除的函数声明为private的，调用删除的函数时，可能报错原因提示是private的；但是更期望的更明确的含义是这些函数是删除的 =delete可以在任意函数中进行标记，不仅仅局限于成员函数 应用： 比如可以阻止某些形参的隐式类型转换 1 2 void func(int a); void func(double) =delete; // 因此禁止double和float两种参数的调用（C++总是倾向于将 float 转换为 double） 阻止某些模板类型的实例化 1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; void func(T* ptr); template \u0026lt;\u0026gt; void func\u0026lt;void\u0026gt;(void* ptr) =delete; struct Widget{ template\u0026lt;typename T\u0026gt; void g(T* ptr); }; template\u0026lt;\u0026gt; void Widget::g\u0026lt;void\u0026gt;(void* ptr) = delete; // 成员模板函数在类外阻止某些类型的实例化 参考 https://blog.csdn.net/Dong_HFUT/article/details/123005509 12：给意在改写的函数添加override声明 重写override需要满足的条件 基类的重写函数必须是虚函数 基类和派生类的重写函数 函数名（析构函数除外）、形参类型、函数常量性完全相同 函数引用限定符完全相同（C++11，函数引用限定符：该成员函数可以被左值对象还是右值对象调用） 返回值类型、异常规格说明兼容 将重写的函数标记为override，如果不满足重写条件则报错 参考 https://blog.csdn.net/Dong_HFUT/article/details/123008755 13：优先选用const_iterator，而非iterator C++98在容器的成员函数中对const_iterator支持有限 C++11在容器的成员函数中支持const_iterator，但是只提供了非成员的begin和end 1 2 3 4 template \u0026lt;typename Container\u0026gt; // C++11实现cbegin的方法 auto cbegin(const Container\u0026amp; container) -\u0026gt; decltype(std::begin(container)){ // auto=const Container::iterator\u0026amp; return std::begin(container); } C++14提供了非成员的cbegin和cend 尽量使用非成员的cbegin和cend，因为某些数据结构（比如数组）没有成员函数cbegin和cend，非成员的cbegin和cend更加通用 1 2 3 4 5 6 7 template\u0026lt;typename C, typename V\u0026gt; void findAndInsert(C\u0026amp; container, const V\u0026amp; targetVal, const V\u0026amp; insertVal) { using std::cbegin; using std::cend; auto it = std::find(cbegin(container), cend(container), targetVal); container.insert(it, insertVal); } 参考 https://blog.csdn.net/Dong_HFUT/article/details/123030976 14：只要函数不会抛出异常，就为其加上noexcept声明 noexcept 是函数接口的一部分，并且调用者可能会依赖这个接口。 相较于 non-noexcept 函数，noexcept 函数有被更好优化的机会。 noexcept 对于 move 操作、swap、内存释放函数和析构函数是非常有价值的。 大部分函数是异常中立的而不是 noexcept。 背景： C++98中异常规范的局限性：接口的实现一旦被修改，其异常规范可能也变化 因此C++11只需要指明接口是否可能抛出异常 优点：一个noexcept函数有更多编译优化的机会 不需要保持运行栈为解开的状态 不需要保证对象以构造顺序的逆序完成析构 应用：如果知道一个函数不会抛出异常，一定要加上noexcept noexcept属性对于移动操作、swap、内存释放函数和析构函数最有价值。C++11 STL 中的大部分函数遵循 “能移动则移动，必须复制才复制” 策略 默认noexcept函数：C++11内存释放函数和所有的析构函数都默认隐式地具备noexcept属性 析构函数未隐式地具备noexcept属性的唯一情况，就是所有类中有数据成员（包含递归的成员）的类型显式地将其析构函数声明为noexcept(false) 如果标准库使用了某个对象，其析构函数抛出了异常，则该行为是未定义的。 条件noexcept：一个函数是否为noexcept，取决于noexcept中的表达式是否为noexcept 只有被调用的低层次的函数是noexcept，高层次的调用方才是noexcept的 1 2 3 4 template \u0026lt;typename T1, typename T2\u0026gt; struct myPair{ void swap(myPair\u0026amp; p) noexcept( noexcept(swap(first, p.first)) \u0026amp;\u0026amp; noexcept(swap(second, p.second)) ); } 异常中立函数：本身不抛出异常，但是调用的函数可能抛出异常，因此不适合标记为noexcept 但是允许noexcept函数中调用没有noexcept保证的函数 通常只为宽松规约提供noexcept声明 宽松规约（wide contract，宽接口）：不带前提条件，被调用时不需要关注程序的状态，传入的参数方面没有限制，宽接口的函数永远不会出现未定义的行为 狭隘规约（narrow contract，窄接口）：带前提条件，如果违反前提条件，则结果是未定义的 调用者来保证调用时满足前提条件 如果调用时违反前提条件，则抛出异常；如果定义为noexcept的，违反前提条件结果是未定义的；相较而言，找出抛出异常的原因相对简单一些 参考 https://blog.csdn.net/Dong_HFUT/article/details/123163671 15：只要有可能使用constexpr，就使用它 constexpr对象：具备const属性，并且在编译期（和链接期）可以确定其值 const对象不能保证在编译期确定其值 constexpr函数 含义： 如果所有传入 constexpr 函数的参数都能在编译时知道，则结果将在编译时计算出来。 如果传入 constexpr 函数的参数有任何一个不能在编译期知道，则结果在运行时计算出来 使用 C++11中，constexpr函数有且只能有一条return语句；C++14无此限制 constexpr 函数被限制只能接受和返回 literal 类型（字面量，非指针和引用，自定义类型也可能是字面量类型的） C++11中，如果成员函数修改了操作的对象，或者成员函数的返回值是void的，则该成员函数无法成为constexpr的；C++14无此限制 1 2 3 4 5 6 7 8 9 10 11 class Point{ public: constexpr Point(double xVal=0, double yVal=0) noexcept: x(xVal), y(yVal) {} constexpr double getX() const noexcept {return x;} constexpr double getY() const noexcept {return y;} constexpr void setX(double newX) noexcept { x = newX;} // C++14中，移除了两条限制，因此可以设置为constexpr的 constexpr void setY(double newY) noexcept { y = newY;} private: double x, y; }; constexprt Point p1(1.0, 2.0); 参考 https://blog.csdn.net/Dong_HFUT/article/details/123172189 16：保证const成员函数的线程安全性 const成员的好处：不会修改成员变量，而且可以区分重载（const对象和非const对象调用） 保证const成员函数的线程安全性 使用std::mutex，进入临界区锁对象获取互斥量，出临界区析构锁（释放互斥量） 使用std::atomic，但是只能同步单一变量或者内存单元 std::mutex和std::atomic都是move-only的 参考 https://blog.csdn.net/Dong_HFUT/article/details/123316263 17：理解特殊成员函数的生成机制 特殊成员函数（special member function）： 一般是public、inline和novirtual的 例外：如果基类中的析构函数是virtual的，派生类中的析构函数也是virtual的 拷贝构造和拷贝赋值是两个独立的操作 移动构造和移动赋值不是独立的操作，如果声明了其中一个，编译器会阻止生成另外一个 如果显式申明一个拷贝操作，则两个移动操作不会自动生成 三法则（The Rule of Three）：如果声明了{拷贝构造函数、拷贝赋值操作、析构函数}中任意一个，则应该声明所有这三个函数，因为往往意味着类要管理某些资源 因此，如果只声明了一个析构函数，编译器应该不会自动生成拷贝操作 但实际上编译器还是可能自动生成拷贝操作（历史遗留原因，以及C++11为了兼容历史代码） 因此，只有当类中没有声明析构函数、拷贝操作、移动操作，而且需要时，编译器才会生成移动操作 如果想让编译器自动生成相关函数（即使违背了这些限制），添加=default进行标记 C++11中对特殊成员函数的生成规则： 默认构造函数：同C++98 析构函数：本质同C++98，只是默认声明为noexcept 拷贝构造函数：运行期行为同C++98（memberwise 拷贝构造 non-static 成员变量） 如果类中声明了一个移动操作，则拷贝构造函数和拷贝赋值运算符被标记为=delete的 如果类中自定义拷贝赋值运算符或析构函数，可以生成拷贝构造函数，但是已经成为被废弃的方法 拷贝赋值运算符：规则同拷贝构造函数 移动构造函数和移动赋值运算符：仅当类中不包含用户声明的拷贝操作、移动操作和析构函数时才生成 特殊情况：成员模板函数不会抑制特殊成员函数的自动生成 1 2 3 4 5 class Widget{ public: template \u0026lt;typename T\u0026gt; Widget(const T \u0026amp;rhs); template \u0026lt;typename T\u0026gt; Widget\u0026amp; operator=(const T\u0026amp; rhs); }; // 编译器仍然会生成copy和move操作，即使可以实例化得到 参考 https://blog.csdn.net/Dong_HFUT/article/details/123433559 ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch03-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c++/","summary":"07：在创建对象时注意区分()和{} 初始化方式 1 2 3 4 int x1(1); int x2 = 2; int x3{3}; // 统一初始化（列表初始化） int x4 = {4}; // 和第三种方式相同 ()和=初始化的限","title":"[Effective Modern Cpp Notes] Ch03 转向现代C++"},{"content":"05：优先选用auto，而非显式类型推断 优点一：避免变量未初始化 使用auto声明的变量未初始化，直接导致编译报错 优点二：简化变量声明（避免写一长串类型名） 优点三：声明闭包类型（lambda表达式） C++11中lambda式返回值可以使用auto，C++14中lambda式形参也可以使用auto std::function通常比起auto更大更慢，还可能导致内存消耗异常，因此实际使用时更推荐auto。 使用auto声明的、存储着一个闭包的变量和该闭包是同一类型，从而它要求的内存量也和该闭包相同 使用std::function声明的、存储着一个闭包的变量是std::function的一个实例，不管给定的签名如何，它都占有固定大小的内存，而这个大小对于其存储的闭包而言并不一定够用，如果是这样，那么std::function的构造函数就会分配堆上的内存来存储该闭包。 优点四：避免类型截断 优点五：避免类型不匹配 1 2 3 4 5 std::unordered_map\u0026lt;std::string, int\u0026gt; mp; for(auto\u0026amp; item: mp) { // auto=std::pair\u0026lt;const std::string,int\u0026gt; // 但是如果显式定义类型，很容易定义为std::pair\u0026lt;std::string, int\u0026gt;\u0026amp; } 06：当auto推导的类型不符合要求时，使用带显式类型的初始化习惯用法 隐式的代理类型可能导致auto类型推导结果不符合预期，因此应该显式声明类型 代理类：模拟和拓展某些其他类型的行为，比如智能指针，比如std::vector\u0026lt;bool\u0026gt;::reference std::vector\u0026lt;bool\u0026gt;进行了特化，与一般std::vector不同： 一般对于vector\u0026lt;T\u0026gt;的operator []操作，返回类型为T\u0026amp;；但是对于vector\u0026lt;bool\u0026gt;的operator []操作，返回类型为vector\u0026lt;bool\u0026gt;::reference（因此可能发生到bool的隐式类型转换），这是因为标准库无法返回对bit的引用 vector\u0026lt;bool\u0026gt;::reference的实现中，可能有一个指向word的指针和一个对应的offset，很可能出现难以预料的错误 1 2 3 vector\u0026lt;bool\u0026gt; func(); auto flg = func()[0]; // func()返回一个临时的右值对象，flg是vector\u0026lt;bool\u0026gt;::reference类型，然后临时的右值对象被析构 // 因为vector\u0026lt;bool\u0026gt;::reference类型中可能有一个指针，再使用flg可能出现未定义的行为 表达式模板中，计算结果可能被解析为一棵语法解析树，而非直接返回计算结果，因此实际得到的结果类型（语法解析树）可能并非期望的类型 # C++元编程之表达式模板优化数组计算 总之，对(隐形)代理类的auto类型推导往往得到的不是预期的类型，因此要么显式声明类型，要么使用static_cast强转然后进行auto类型推导 ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch02-auto/","summary":"05：优先选用auto，而非显式类型推断 优点一：避免变量未初始化 使用auto声明的变量未初始化，直接导致编译报错 优点二：简化变量声明（避免写","title":"[Effective Modern Cpp Notes] Ch02 Auto"},{"content":"01：理解模板类型推导 在模板类型推导中，引用类型参数将被视为非引用类型处理，也就是说其引用性被忽略。 - 在万能引用参数类型推导时，左值参数被特殊处理。 - 值传递形参的类型推导时，其 const 和 volatile 被忽略。 - 在模板类型推导时，数组或者函数类型被转换为指针类型，除非它们用来初始化引用。 背景：有时模板类型推导无法一下看出来T是什么类型 1 2 3 4 template \u0026lt;typename T\u0026gt; void f(ParamType param); f(expr); // 比如实参可能是int, const int, const int\u0026amp; 类型T的推导不仅取决于expr的类型，也取决于ParamType的形式 情况一：ParamType是指针或引用，但不是万能引用 1 2 3 template \u0026lt;typename T\u0026gt; void f(T\u0026amp; param); template \u0026lt;typename T\u0026gt; void f(const T\u0026amp; param); template \u0026lt;typename T\u0026gt; void f(T* param); 情况二：ParamType是万能引用，因此可能发生引用折叠 1 template \u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); 情况三：ParamType不是指针，也不是引用，因此视为值传递（实参的const/volatile性质被忽略，因为值进行了复制，形参副本不影响原来的实参） 1 template \u0026lt;typename T\u0026gt; void f(T param); 特殊情况一：传入的实参为数组类型 如果模板是情况一：推导出T为数组类型（包含类型和元素数量） 1 2 3 template \u0026lt;typename T\u0026gt; void f(T\u0026amp; param); const char name[] = \u0026#34;zhang\u0026#34;; f(name); // 推导出T=const char[6], f(const char(\u0026amp;param)[6]) 应用：比如可以在编译阶段计算数组元素个数： 1 2 template \u0026lt;typename T, std::size_t N\u0026gt; constexpr std::size_t arraySize(T (\u0026amp;)[N]) noexcept {return N;} 如果模板是情况三：将数组名视为指针，因此T是指针类型 特殊情况二：传入的实参为函数类型 如果模板是情况一：推导出T为函数引用类型 如果模板是情况三：推导出T为函数指针类型 参考： https://blog.csdn.net/Dong_HFUT/article/details/122727237 02：理解auto类型推导 一般情况下，auto类型推导和模板类型推导完全相同；但是auto类型推导会假定使用{}的列表初始化表达式是一个std::initializer_list，但是模板类型推导不会 在函数返回值或lambda式形参中使用auto，意思是使用模板类型推导而非使用auto类型推导 背景：将一个变量赋值给auto类型变量，auto是什么类型 同[[ch01-类型推导#01：理解模板类型推导|01：理解模板类型推导]]中的总体原则：将实参赋值给形参 除了一个例外：使用{}进行列表初始化 auto类型推导： 1 2 auto x = {1, 2, 3}; // auto=std::initializer_list\u0026lt;int\u0026gt;,首先推导为std::initializer_list\u0026lt;T\u0026gt;，然后再推断类型T=int auto y{2}; // auto=int 模板类型推导：不能直接将{}的列表初始化表达式推导为T=std::initializer_list\u0026lt;type\u0026gt;， 1 2 3 4 template \u0026lt;typename T\u0026gt; void f(T param); f({1, 2, 3}); // 报错：直接传入{}列表初始化的实参，模板类型推导失败 template \u0026lt;typename T\u0026gt; void g(std::initializer_list\u0026lt;T\u0026gt; initList); g({1, 2, 3}); // T=int 为什么两种行为不同的一个可能解释 1 2 3 template \u0026lt;typename T\u0026gt; void func(T\u0026amp; a, T\u0026amp; b); func(vector\u0026lt;int\u0026gt;{1,2,3}, {1,2,3}); // 左边推导出T=vector\u0026lt;int\u0026gt;, 右边如果推导出T=initializer_list\u0026lt;int\u0026gt;,则左右冲突 auto可以作为函数返回值类型、lambda式形参类型（C++14） 但是原理是模板类型推导，而非auto类型推导 参考 https://blog.csdn.net/Dong_HFUT/article/details/122740091 03：理解decltype 绝大多数情况下，decltype会得到变量或表达式的类型，而不进行修改 对于类型为T的左值表达式，除非该表达式只有一个名字，否则decltype总是返回T\u0026amp; C++14支持decltype(auto)：auto 表示类型需要推导，decltype 表示使用decltype规则进行推导 背景：给定一个名字或表达式，decltype返回其类型：原来是值/左值/右值，返回值/左值/右值 体会auto类型推导和decltype类型推导的区别 auto类型推导：将变量rhs赋值给lhs，推导出lhs的类型 decltype类型推导：返回变量rhs的类型 使用场景： 声明一个函数模板，其返回值类型取决于参数类型 1 2 template \u0026lt;typename Container, typename Index\u0026gt; auto getItem(Container\u0026amp; c, Index i) -\u0026gt; decltpye(c[i]) { return c[i]; } // 返回类型是引用T\u0026amp; 如果返回值为auto，使用auto类型推导，返回类型将不是引用 1 2 template \u0026lt;typename Container, typename Index\u0026gt; auto getItem(Container\u0026amp; c, Index i) { return c[i]; } // 返回类型是T 可以同时使用auto和deltype：auto 表示类型需要推导，decltype 表示使用decltype规则进行推导 1 2 template \u0026lt;typename Container, typename Index\u0026gt; decltype(auto) getItem(Container\u0026amp; c, Index i) { return c[i]; } // 返回类型是引用T\u0026amp; 优化与完善：为了传入右值的Container，使用万能引用，同时使用完美转发 1 2 template \u0026lt;typename Container, typename Index\u0026gt; decltype(auto) getItem(Container\u0026amp;\u0026amp; c, Index i) { return std::forward\u0026lt;Container\u0026gt;(c)[i]; } // C++14，或者C++11使用尾置返回类型 一般而言decltype返回的类型都比较直观，除了一种情况： 1 2 3 int x = 0; // decltype(x)=int // decltype((x))=int\u0026amp; 参考 https://blog.csdn.net/Dong_HFUT/article/details/122745518 https://zyfforlinux.blog.csdn.net/article/details/52658452 04：掌握查看类型推导结果的方法 在代码编辑阶段查看类型推导结果：IDE 在代码编译阶段查看类型推导结果：查看编译报错 在代码运行阶段查看类型推导结果： typeid：不同编译期实现不同，无法保证完全可靠，而且类型的引用、const、volatile等性质被忽略 Boost库的模板函数boost::typeindex::type_id_with_cvr 如果类型不包含引用、const、volatile等性质，则type_id_with_cvr与typeid返回相同 1 2 3 4 5 6 7 8 #include \u0026lt;boost/type_index.hpp\u0026gt; template \u0026lt;typename T\u0026gt; void f(const T\u0026amp; param){ using std::cout; using boost::typeindex::type_id_with_cvr; // c:const, v:volatile, r:reference cout\u0026lt;\u0026lt;type_id_with_cvr\u0026lt;T\u0026gt;().pretty_name()\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; cout\u0026lt;\u0026lt;type_id_with_cvr\u0026lt;decltype(param)\u0026gt;().pretty_name()\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } ","permalink":"https://qinganzhang.github.io/posts/effective-modern-cpp/ch01-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/","summary":"01：理解模板类型推导 在模板类型推导中，引用类型参数将被视为非引用类型处理，也就是说其引用性被忽略。 - 在万能引用参数类型推导时，左值参数被特","title":"[Effective Modern Cpp Notes] Ch01 类型推导"},{"content":"49：了解new-handler的行为 new申请内存失败会抛出bad alloc的异常，此前会调用一个错误处理函数，此函数由std::set_new_handler()指定 set::set_new_handler() 接受一个错误处理函数，返回旧的错误处理函数 throw表示可能抛出的异常类型，参数为空表示不抛出任何异常 1 2 typedef void (*new_handler)(); // 无形参，返回值为void的函数指针 new_handler set_new_handler(new_handler f) throw(); 当new申请不到足够的内存时，会不断调用错误处理函数f，因此错误处理函数应该进行下面的处理之一： 提供更多可用的内存 向set_new_handler中传入一个新的错误处理函数 set_new_handler函数中传入一个空指针，因此内存分配失败时不进行处理，直接抛出异常 抛出bad_alloc的异常 不返回：调用std::abort或std::exit abort会设置程序非正常退出 exit会设置程序正常退出，当存在未处理异常时，会调用terminate，内部回调set::set_terminate设置的回调函数，默认会调用abort 类型相关错误处理 为不同的类分配对象时，使用不同的错误处理函数 重载set_new_handler和operator new，重载为static成员 可以写成模板 此处的模板参数T并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，使得模板机制为每个派生类具现化出一份对应的currentHandler 这个做法用到了所谓的 CRTP（curious recurring template pattern，奇异递归模板模式），也常被用于静态多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template \u0026lt;typename T\u0026gt; class NewHandlerSupport { public: static std::new_handler set_new_handler(std::new_handler p) noexcept; static void* operator new(std::size_t size); ~NewHandlerSupport() {std::set_new_handler(currentHandler);} private: NewHandlerSupport(const NewHandlerSupport\u0026amp;); // 阻止拷贝构造 NewHandlerSupport\u0026amp; operator=(const NewHandlerSupport\u0026amp;); // 阻止拷贝复制 static std::new_handler currentHandler; }; template \u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::currentHandler = nullptr; template \u0026lt;typename T\u0026gt; std::new_handler NewHandlerSupport\u0026lt;T\u0026gt;::set_new_handler(std::new_handler p) noexcept { std::new_handler oldHandler = currentHandler; currentHandler = p; return oldHandler; } template \u0026lt;typename T\u0026gt; void* NewHandlerSupport\u0026lt;T\u0026gt;::operator new(std::size_t size) { NewHandlerSupport h(std::set_new_handler(currentHandler)); // 返回的函数指针初始化了一个对象h，在退出函数时，执行h的析构过程，即将原来的handle恢复 return ::operator new(size); } // 使用 class Widget: public NewHandlerSupport\u0026lt;Widget\u0026gt;{ ... }; new分配失败后，可能不会抛出异常，而是返回null，这种称为nothrow new 例子：new (std::nothrow) int[10]; nothrow new只能保证内存分配错误时不抛出异常，无法保证对象的构造函数不抛出异常 50： 了解new和delete的合理替换时机 为什么需要自定义operator new 检测使用错误：检测多次delete，检测越界 提高效率：手动维护更适合应用场景的存储策略 比如针对特定类型，增加分配和归还的速度 比如将相关对象集成到簇中（即尽量分配到一个内存页上） 收集使用的统计信息 其他原因：比如安全性（将申请到的内存初始化为0），字节对齐等 51： 编写new和delete时需固守常规 operator new需要无限循环地获取资源，如果没能获取则调用\u0026quot;new handler\u0026quot;，不存在\u0026quot;new handler\u0026quot;时应该抛出异常；\noperator new应该处理size == 0的情况；\noperator delete应该兼容空指针；\noperator new/delete作为成员函数应该处理size \u0026gt; sizeof(Base)的情况（因为继承的存在）。\n外部（非成员函数的）operator new：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void* operator new(std::size_t size) throw(std::bad_alloc){ if(size == 0) size = 1; // size=0时，返回合法的指针就说明成功分配了内存 while(true){ void *p = malloc(size); if(p) return p; // 申请失败，获得new handler，多线程需要加锁 new_handler h = set_new_handler(0); set_new_handler(h); // auto h = get_new_handler(); // C++11方式 if(h) (*h)(); // new-handler应该实现item49中描述的五种行为之一，否则，此处陷入死循环 else throw bad_alloc(); } } 成员operator new\n如果operator new是针对基类的，也就是说operator new是针对大小为sizeof(Base)的内存进行优化的 一般来说派生类不应该使用基类的operator new，因为派生类对象大小与基类对象大小一般不同 1 2 3 4 5 6 7 8 9 10 11 12 class Base{ public: static void* operator new(std::size_t size); }; void* Base::operator new(std::size_t size) { if(size != sizeof(Base)) // sizeof(Base)永远不会为0（至少为1），因为空对象至少会插入一个char return ::operator new(size); // 使用全局的operator new ... } class Derived: public Base { ... }; operator new[]与operator new有相同的参数和返回值，只需要分配一块原始内存 delete\ndelete 惯例：delete一个空指针是安全的 外部operator delete\n1 2 3 4 void operator delete(void* rawMemory) noexcept { if (rawMemory == 0) return; // 释放 rawMemory 所指的内存 } 成员operator delete 如果基类的析构函数不是虚函数，则size大小为静态类型的大小； 比如Base* p = new Derived; delete p;中，很可能派生类大小大于基类大小，因此存在内存泄露 否则size为动态类型的大小 1 2 3 4 5 6 7 8 void Base::operator delete(void* rawMemory, std::size_t size) noexcept { if (rawMemory == 0) return; if (size != sizeof(Base)) { ::operator delete(rawMemory); // 转交给标准的 operator delete 进行处理 return; } // 释放 rawMemory 所指的内存 } 52： 写了placement new也要写`palcement delete placement new：广义上指拥有额外参数的operator new 背景： 在使用new创建对象时，往往进行了两个函数的调用：一个是operator new，进行内存分配；一个是对象的构造函数 如果构造失败，此时对象没有被创建，对象无法被析构，且此时还没有拿到分配内存的地址 因此需要运行时系统进行delete，运行时系统需要知道使用的是哪一种operator new，因此调用对应的operator delete 如果没有对应的operator delete函数，则运行时系统什么都不做，导致内存泄露 当定义了placement new时，同时也要定义对应的placement delete 用户直接调用delete时，运行时系统不会将其解释为placement delete，因此还需要定义一个正常的delete 1 2 3 4 5 6 class Widget{ public: static void* operator new(std::size_t size, std::ostream\u0026amp; log) throw(std::bad_alloc); static void operator delete(void *mem, std::ostream\u0026amp; log); static void operator delete(void *mem) throw(); }; 名称隐藏：类中的名称会隐藏类外的名称，子类的名称会隐藏父类的名称 三种全局new 1 2 3 void* operator(std::size_t) throw(std::bad_alloc); // normal new void* operator(std::size_t, void*) noexcept; // placement new void* operator(std::size_t, const std::nothrow_t\u0026amp;) noexcept; // nothrow new 最佳实践： 将全局版本new在一个基类中进行重载，内部调用全局new进行实现 然后在自定义类Widget中，public继承，并使用using声明使得三种new和三种delete对Widget可见，因此同时Widget可以定义自己版本的placement new 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class StandardNewDeleteForms { public: // normal new/delete static void* operator new(std::size_t size) throw(std::bad_alloc) { return ::operator new(size); } static void operator delete(void *pMemory) throw() { ::operator delete(pMemory); } // placement new/delete static void* operator new(std::size_t size, void *ptr) throw() { return ::operator new(size, ptr); } static void operator delete(void *pMemory, void *ptr) throw() { return ::operator delete(pMemory, ptr); } // nothrow new/delete static void* operator new(std::size_t size, const std::nothrow_t\u0026amp; nt) throw() { return ::operator new(size, nt); } static void operator delete(void *pMemory, const std::nothrow_t\u0026amp;) throw() { ::operator delete(pMemory); } }; class Widget: public StandardNewDeleteForms { public: using StandardNewDeleteForms::operator new; using StandardNewDeleteForms::operator delete; static void* operator new(std::size_t size, std::ostream\u0026amp; log) throw(std::bad_alloc); // 自定义 placement new static void operator delete(void *pMemory, std::ostream\u0026amp; logStream) throw(); // 对应的 placement delete }; ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch08-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/","summary":"49：了解new-handler的行为 new申请内存失败会抛出bad alloc的异常，此前会调用一个错误处理函数，此函数由std::set_","title":"[Effective Cpp Notes] Ch08 定制new和delete"},{"content":"41： 了解隐式接口与编译期多态 面向对象中的类设计时需要考虑显式接口和运行时多态，而模板编程中需要考虑隐式接口和编译器多态\n如果函数的形参是普通类： 普通类的显式接口由函数签名（函数名、形参类型、返回值类型）表征，运行时多态由虚函数实现 在函数进行编译时，就可以知道该普通类有哪些接口 如果函数的形参是模板类型： 模板类型的隐式接口由表达式的合法性表征（即该模板类型应该支持函数中形参调用的方法），编译器多态由模板初始化和重载函数的解析实现 在函数进行编译时，无法知道模板类型有哪些接口，因此视为鸭子类型（即传入对象支持函数中调用的方法即可） 在编译函数时当然无法确定模板类型，但是当传入实参后，内部如果调用了实参未定义的函数，同样会在编译期报错而非运行期 参考： https://www.zhihu.com/question/423699453 42： 了解typename的双重意义 在模板声明中，使用class与typename完全相同 在模板内部，typename还可以用来显式指明【嵌套从属类型名称】 背景：比如编译器无法在模板内部判断T::mem是一个static成员（默认），还是一个类型 嵌套从属类型名称：T::mem是一个依赖于模板参数T的类型 例子：模板内部typename T::age myAge = 25; typename还可以用来显式指明【嵌套从属类型名称】，可以出现在模板内部、函数形参列表，但是不可以出现在【类派生列表】和【构造函数中成员初始化列表】中 当类型名称过于复杂时，可以使用类型别名 参考 https://harttle.land/2015/09/09/effective-cpp-42.html 43： 使用模板化基类中的成员函数 背景：如果基类是一个模板类，派生类进行继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Buff {}; class RedBuff: public Buff {}; class BlueBuff: public Buff {}; template \u0026lt;typename T\u0026gt; // 基类 class Container { /* 假设有成员函数func() */}; //template \u0026lt;\u0026gt; // 全特化基类 //class Container\u0026lt;Buff*\u0026gt; { /* 假设没有成员函数func() */ }; // template \u0026lt;typename T=Buff*\u0026gt; // 使用默认模板实参，同全特化基类 // class Container\u0026lt;T\u0026gt; { /* 假设没有成员函数func() */ } template \u0026lt;typename T\u0026gt; class PlayerContainer: public Container\u0026lt;T\u0026gt; { // 派生类继承模板化基类 public: void test() { func(); } // 这里编译报错 }; 对于模板化基类，可能有特化版本，且其中可能有不同的接口 对于派生类而言，也无法确定类型T，因此C++规定派生类不在模板化基类中查找继承而来的接口 解决方法：向编译器承诺所有的特化版本都遵循模板化基类的接口（或者说使用非特化版本的模板化基类中的接口） 使用this显式指出访问基类的成员函数 1 2 3 4 5 template \u0026lt;typename T\u0026gt; class PlayerContainer: public Container\u0026lt;T\u0026gt; { // 派生类继承模板化基类 public: void test() { this-\u0026gt;func(); } // this指针可以访问所有成员函数 }; 使用using声明 1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; class PlayerContainer: public Container\u0026lt;T\u0026gt; { // 派生类继承模板化基类 public: using Container\u0026lt;T\u0026gt;::func; // 告诉编译器，func在模板化基类中 void test() { func(); } }; 使用作用域运算符::明确指出，不推荐使用，因为如果func是虚函数，使用这种方法不会产生多态 1 2 3 4 5 template \u0026lt;typename T\u0026gt; class PlayerContainer: public Container\u0026lt;T\u0026gt; { // 派生类继承模板化基类 public: void test() { Container\u0026lt;T\u0026gt;::func(); } // 明确指出 }; 44： 将与参数无关的代码抽离模板 背景：代码膨胀 模板提供的是编译期多态，不同的类型参数会生成不同的模板 比如一个模板类接受一个类型参数T与一个非类型参数N，大部分成员都使用类型参数T，只有极少部分成员使用非类型参数N 如果使用相同的类型type、但是不同的非类型参数n进行实例化，生成的代码中大部分都相同，只有极少部分不同 抽取公共代码： 模板中生成的冗余代码是隐式的，因为模板只有一份，生成不同实例后才可能产生冗余 比如可以将与参数无关的代码（成员函数，数据成员）放入基类中，然后private继承 参考 https://harttle.land/2015/09/12/effective-cpp-44.html 45： 运用成员函数模板接受所有兼容类型 背景：假如类型参数T存在继承关系，但是模板实例化后是完全不同的两个类 比如有一个继承体系，基类Base，派生类Derived 指向派生类的指针可以转换为指向基类的指针：Base* p = new Derived(); 但是指向派生类的智能指针无法转换为指向基类的智能指针： shared_ptr\u0026lt;Base*\u0026gt; sp = make_shared\u0026lt;Derived*\u0026gt;(new Derived()); 重载构造函数 接受同一模板的其他实例的构造函数称为通用构造函数 兼容类型检查：将MySmartPtr\u0026lt;U\u0026gt;转换为MySmartPtr\u0026lt;T\u0026gt;，前提是类型U可以转换为类型T 如果没有声明拷贝构造函数，编译器会自己生成一个，而非使用通用构造函数去进行成员模板实例化 1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T\u0026gt; class MySmartPtr{ public: MyShartPtr(T* p): ptr(p) {} template \u0026lt;typename U\u0026gt; MySmartPtr(const MySmartPtr\u0026lt;U\u0026gt;\u0026amp; other): ptr(other.get()) {}; // 带类型兼容检查的通用构造函数，可以实现隐式类型转换（因为不带explicit） T* get() const {return ptr;} private: T *ptr; }; MySmartPtr\u0026lt;Derived*\u0026gt; dp(new Derived()); // 隐式类型转换 MySmartPtr\u0026lt;Base*\u0026gt; bp = MySmartPtr\u0026lt;Derived*\u0026gt;(new Derived()); // T=Base*, U=Derived* 参考 https://harttle.land/2015/09/13/effective-cpp-45.html 46：需要类型转换时请将模板定义为非成员函数 背景： 1 2 3 4 5 6 7 8 template \u0026lt;typename T\u0026gt; class Rational {}; template \u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) {} Rational\u0026lt;int\u0026gt; oneHalf(1,2); Rational\u0026lt;int\u0026gt; result = oneHalf * 2; // Error 模板函数的调用过程： 首先推导出类型T，将函数进行实例化：此时无法从2推导得出类型T 在调用时，有的参数可能需要隐式类型转换 解决方法：将模板函数定义为类的友元，因此类模板实例化后类型T已知 如果仅仅是声明，编译器不会对友元函数进行实例化，因此需要进行定义 定义在类内部的函数是inline的，可以在类外部定义一个辅助函数（也是模板函数，但是不需要隐式类型转换） 1 2 3 4 5 6 7 8 9 10 template \u0026lt;typename T\u0026gt; class Rational; template \u0026lt;typename T\u0026gt; const Rational\u0026lt;T\u0026gt; func(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs) {} template \u0026lt;typename T\u0026gt; class Rational{ public: friend Rational\u0026lt;T\u0026gt; operator*(const Rational\u0026lt;T\u0026gt;\u0026amp; lhs, const Rational\u0026lt;T\u0026gt;\u0026amp; rhs){ func(lhs, rhs); // 可以推导出类型T，而且不需要进行隐式类型转换 } } 47： 请使用traits classes表现类型信息 使用Traits的特点： 可以同时支持自定义类型和基础类型 在编译期就获取信息 C++中的Traits类可以在编译期提供类型信息，是通过Traits模板及其特化来实现的 C++标准库中提供了不同的Traits：iterator_traits,char_traits,numeric_limits等（以iterator_traits为例）\n背景：容器与算法通过迭代器联系在一起，算法中可能需要知道迭代器的类型、迭代器中元素的类型，由此有不同的处理方法 比如算法advance可以让一个迭代器移动n步（负数则反向移动） 迭代器有五种：其中随机访问迭代器可以直接使用+=操作 C++提供了五个类标识迭代器类型：input_iterator_tag，output_iterator_tag，forward_iterator_tag，bidirectional_iterator_tag，random_access_iterator_tag 传入的参数也可能是基本类型的指针 1 2 3 4 5 6 7 8 template \u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d){ // 判断迭代器类型 if(iter is random access iterator) iter += d; else ... // 判断迭代器中元素类型 if(iter.value_type is MyVector) cout\u0026lt;\u0026lt;\u0026#34;MyVector\u0026#34;\u0026lt;\u0026lt;endl; } 分析： 如果IterT是类类型，因此可以在类中携带数据成员，表示迭代器类型和元素类型 但是IterT也可能是基本类型的指针类型，无法在其中携带信息 Traits技法：使用Traits可以通过一个模板类间接获取IterT的相关信息 1 2 template \u0026lt;typename IterT\u0026gt; struct my_iterator_traits; Traits是C++中一种编程惯例，允许在编译期得到类型的信息 traits是一个用来携带信息的很小的类，需要实现两个部分： traits中的类型可能是用户自定义的类型， 自定义类型中需要实现相应的迭代器，对具体的类型信息起一个通用的别名 traits中包装相应的信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; class MyVector{ // 自定义类 public: class iterator{ // 自定义类中的迭代器 public: using value_type = T; using iterator_category = my_random_access_iterator_tag; }; }; // iterator_traits可以获取迭代器（或指针类型）的元素类型和迭代器类型（指针类型视为随机访问迭代器） template \u0026lt;typename IterT\u0026gt; struct iterator_traits{ // IterT是类类型 using iterator_category = typename IterT::iterator_category; using value_type = typename IterT::value_type; }; traits中的类型可能是基本数据类型，遵循相同的名称，包装一下相应的信息 1 2 3 4 5 template \u0026lt;typename IterT\u0026gt; struct iterator_traits\u0026lt;IterT*\u0026gt;{ // 特化版本：IterT是基本类型，IterT是基本类型的指针 using iterator_category = my_random_access_iterator_tag; // 指针可以使用+=操作，因此视为随机访问迭代器 using value_type = IterT; }; 使用 不好的写法：使用typeid在运行时判断类型 但是IterT类型在编译期就可以确定，对象iter的类型需要在运行时确定 更严重的问题：静态类型检查（编译期必须确保所有源码都有效，即使是不会执行的源码） ^826df6 比如即使迭代器不是my_random_access_iterator_tag类型，编译期也会进入if语句测试该迭代器是否支持+=运算，不支持的话编译报错 1 2 3 4 5 template \u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d){ if( typeid(typename std::iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(my_random_access_iterator_tag) ) iter += d; } 推荐实现方法：根据不同的类型创建不同的重载方法（worker），然后在一个master函数中调用，依据traits类型进行重载调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 template \u0026lt;typename IterT, typename DistT\u0026gt; void advance(IterT\u0026amp; iter, DistT d){ // 将IterT中迭代器类型和元素类型萃取出来 std::cout\u0026lt;\u0026lt;typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category).name()\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::value_type).name()\u0026lt;\u0026lt;std::endl; // 错误使用：如果iter是指针类型，则IterT为基本类型，无iterator_category属性 // std::cout\u0026lt;\u0026lt;typeid(IterT::iterator_category).name()\u0026lt;\u0026lt;std::endl; doAdvance(iter, d, typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category()); // 最后默认初始化一个iterator_category的对象，进行重载匹配，调用对应的函数 } // 随机访问迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, my_random_access_iterator_tag){ iter += d; } // 前向迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, my_forward_iterator_tag){ assert(d \u0026gt;= 0 \u0026amp;\u0026amp; \u0026#34;d must be not less then 0\u0026#34;); while(d--) ++iter; } 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;cassert\u0026gt; // using namespace std; struct my_random_access_iterator_tag { // my_random_access_iterator_tag() { std::cout\u0026lt;\u0026lt;\u0026#34;my_random_access_iterator_tag ctor\u0026#34;\u0026lt;\u0026lt;std::endl; } }; struct my_forward_iterator_tag{ // my_forward_iterator_tag() {std::cout\u0026lt;\u0026lt;\u0026#34;my_forward_iterator_tag\u0026#34;\u0026lt;\u0026lt;std::endl;} }; template \u0026lt;typename T\u0026gt; class MyVector{ // 自定义类 public: class iterator{ // 自定义类中的迭代器 public: using value_type = T; using iterator_category = my_random_access_iterator_tag; }; }; // iterator_traits可以获取迭代器（或指针类型）的元素类型和迭代器类型（指针类型视为随机访问迭代器） // 输入：使用类类型的迭代器或指针类型进行实例化 // 输出：萃取出元素类型和迭代器类型 template \u0026lt;typename IterT\u0026gt; struct my_iterator_traits{ // IterT是类类型 using iterator_category = typename IterT::iterator_category; using value_type = typename IterT::value_type; }; template \u0026lt;typename IterT\u0026gt; struct my_iterator_traits\u0026lt;IterT*\u0026gt;{ // 特化版本：IterT是基本类型，IterT是基本类型的指针 using iterator_category = my_random_access_iterator_tag; // 指针可以使用+=操作，因此视为随机访问迭代器 using value_type = IterT; }; // std双向迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::bidirectional_iterator_tag){ if(d \u0026gt; 0) while(d--) ++iter; else while(++d) --iter; } // std随机访问迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, std::random_access_iterator_tag){ iter += d; } // 自定义随机访问迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, my_random_access_iterator_tag){ iter += d; } // 自定义前向迭代器版本 template \u0026lt;typename IterT, typename DistT\u0026gt; void doAdvance(IterT\u0026amp; iter, DistT d, my_forward_iterator_tag){ assert(d \u0026gt;= 0 \u0026amp;\u0026amp; \u0026#34;d must be not less then 0\u0026#34;); while(d--) ++iter; } template \u0026lt;typename IterT, typename DistT\u0026gt; void myAdvance(IterT\u0026amp; iter, DistT d){ // 将IterT中迭代器类型和元素类型萃取出来 std::cout\u0026lt;\u0026lt;typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category).name()\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::value_type).name()\u0026lt;\u0026lt;std::endl; // 错误使用：如果iter是指针类型，则IterT为基本类型，无iterator_category属性 // std::cout\u0026lt;\u0026lt;typeid(IterT::iterator_category).name()\u0026lt;\u0026lt;std::endl; // std::cout\u0026lt;\u0026lt; (typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(std::bidirectional_iterator_tag)) \u0026lt;\u0026lt;std::endl; // 不好的写法： // 静态类型检查，即使iter不是随机访问迭代器，也会进入if语句块内进行检查 // if( typeid(typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category) == typeid(std::random_access_iterator_tag) ) // iter += d; doAdvance(iter, d, typename my_iterator_traits\u0026lt;IterT\u0026gt;::iterator_category()); // 最后默认初始化一个iterator_category的对象，进行重载匹配，调用对应的函数 } int main(){ int a[10]; for(int i = 0; i \u0026lt; 10; ++i) a[i] = i+1; int* p = \u0026amp;a[0]; myAdvance(p, 2); std::cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;std::endl; std::list\u0026lt;int\u0026gt; lst{1,2,3,4,5,6,7,8,9,10}; std::list\u0026lt;int\u0026gt;::iterator it = lst.begin(); myAdvance(it, 2); std::cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;std::endl; return 0; } 48： 认识模板元编程 模板元编程（template metaprogramming，TMP）：编写模板，执行于编译期，生成具象化的代码 优点：可以将很多工作从运行期转移到编译期 一些错误可以提前发现 运行时更高效：可执行文件体积小，运行期短，内存需求少 避免了[[ch07-模板与泛型编程#^826df6|静态类型检查]]的问题 缺点：编译时间变长 模板元编程 图灵完备 循环由递归实现 ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch07-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/","summary":"41： 了解隐式接口与编译期多态 面向对象中的类设计时需要考虑显式接口和运行时多态，而模板编程中需要考虑隐式接口和编译器多态 如果函数的形参是普通","title":"[Effective Cpp Notes] Ch07 模板与泛型编程"},{"content":"32：确定你的public继承构造出is-a关系 public继承的意思是，子类是一种特殊的父类（is-a关系） 子类必须涵盖父类每一个特点，必须无条件继承父类所有特性和接口 否则没有is-a关系，不应该使用public继承 因为很多时候凭生活经验判断，可能会错误判断为具有is-a关系，但是子类可能没有父类的某个特性 程序设计没有银弹 33：避免覆盖继承而来的名称 背景：父类中有多个重载的虚函数（同名），子类只重写了其中一个，会导致子类中父类的其他重载函数不可见 根本原因：如果子类重写了父类的重载函数的一部分，在进行名字查找中，可以在相应的静态类型（子类）中查找到名字，但是类型无法匹配 避免方法： 对于父类的重载方法，子类要么全部重写，要么一个都不重写 使用using声明 使用转交函数（forwarding function）？ 34：区分接口继承与实现继承 public继承可以分为函数接口继承和函数实现继承 基类中声明纯虚函数，派生类只继承其接口，且派生类需要提供实现 从代码层面提醒派生类主动实现其接口，即使纯虚函数在基类中也可以有实现（派生类也需要显式指明需要使用基类中的实现） 基类中声明虚函数，派生类继承其接口和缺省实现 基类中声明普通函数，派生类继承其接口和实现（好的编程习惯是不对子类方法进行重写） 35：考虑virtual函数以外的其他选择 通常面向多态的做法： 将接口设置为virtual的 通过Non-Virtual Interface(NVI)来实现template method模式 将接口Func的真正实现函数onFunc设置为private virtual的 基类中的private virtual方法，通过public继承到派生类，派生类可以进行重写 将接口Func设置为public non-virtual的，在Func中调用onFunc non-virtual的接口Func就称为virtual onFunc的wrapper 优点：在接口Func中调用onFunc前后，可以前置和后置的工作 缺点：在某些场景的继承体系中，virtual函数必须调用基类的版本，因此virtual函数必须是protected甚至public的，此时无法使用NVI strategy模式 基于Function Pointers的strategy模式 直接在构造函数中传入一个函数指针，用于实现多态 进一步的，可以基于C++11的std::function来实现strategy模式，在构造函数中传入一个可调用对象 古典的strategy模式：将函数指针替换为类指针，使用该类中的成员函数 优点：同一种类型可以使用不同的方法进行计算，而且可以在运行期变更使用的函数 缺点：函数指针只能访问public成员，否则只能弱化封装性，将外部函数声明为友元 36：绝不重写继承而来的non-virtual函数 从语法上看 虚函数执行的是动态绑定，非虚函数执行的是静态绑定 如果有多态调用的需求，设置为虚函数 从设计上看 public继承意味着一种is-a关系，子类是一种特殊的父类，不变性（父类的共性）凌驾于特异性（子类的个性）之上 重写public继承而来的non-virtual表示子类修改了父类的特性，违背了is-a关系，造成了设计上的矛盾 37：绝不重写继承而来的(虚函数的)缺省参数值 虚函数执行的是动态绑定，但是缺省参数值是静态绑定 因此可能执行的是动态类型版本的虚函数，但是缺省参数值是静态类型版本虚函数的，没有使用动态类型版本的缺省参数值，极易引起误会 缺省参数值采用静态绑定是为了提高运行时效率，这样可以在编译期将参数确定，而非得到运行时 解决方法： 如果使用虚函数，则采用相同的缺省参数值 使用Non-Virtual Interface(NVI)代替虚函数 将接口Func设置为public non-virtual的（因此不期望被重写），并带有缺省参数，因此不管怎么继承，缺省参数值都是相同的 将接口Func的实现逻辑onFunc设置为private virtual的，Func中将缺省参数传递给onFunc，调用动态版本的虚函数 38：通过复合构造出has-a关系或“根据某物实现出” 复合：一个类作为另一个类的数据成员 当复合发生在应用域内的对象之间时，表现出has-a的关系 比如Person类中有一个Address类 当复合发生在实现域内的对象之间时，表现出“根据某物实现出”的关系 比如使用List类模拟实现出一个Set类 39： 明智而审慎地使用private继承 private继承的特点： 如果派生类private继承自基类，则从派生类无法转换到基类 但是如果派生类public继承自基类，则派生类可以slice（切掉）转换为基类 private继承的意义：“根据某物实现出” 仅仅是为了让派生类使用基类中的某些方法，派生类与基类没有直接意义上的联系 private继承的使用：当需要进行“根据某物实现出”的时候 能用复合，就不要用private：绝大多数private继承的场合都可以使用“public继承+复合”进行代替 使用private继承： 比如想在Widget的派生类中，不定义OnTick方法，即使使用private继承，在Widget的派生类中仍然可以重新定义OnTick方法（类似NVI中方法） 同时Widget编译时必须依赖Timer 1 2 3 4 5 6 7 8 9 10 // 使用private继承 class Timer{ public: virtual void OnTick() const; }; class Widget: private Timer{ private: virtual void OnTick() const; // override } // Widget的派生类中仍有OnTick方法 使用复合： 在Widget的派生类中，可以没有OnTick方法（同C++11对成员函数使用final） 可以将WidgetTimer定义移出Widget，从而Widget编译时不需要Timer 1 2 3 4 5 6 7 8 9 10 11 12 class Timer{ public: virtual void OnTick() const; }; class Widget{ private: class WidgetTimer: public Timer{ public: virtual void OnTick() const; }; WidgetTimer timer; }; 使用private继承的情况：空白基类最优化（Empty Base Optimization，EBO） 40： 明智而审慎地使用多重继承 多重继承中可能遇到歧义调用，需要指明调用哪个基类中的接口 即使同名接口一个在基类中是public的，一个是private的（不会被调用），也会发生歧义 因为C++首先会找到最佳匹配函数，之后才会验证其可用性，如果两个同名的函数匹配程度相同，则发生二义性 遇到菱形继承时，使用虚继承，且尽量少的在虚基类中携带数据 多重继承的使用场景：public继承自某个抽象基类，private继承自某个协助实现的基类 ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch06-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/","summary":"32：确定你的public继承构造出is-a关系 public继承的意思是，子类是一种特殊的父类（is-a关系） 子类必须涵盖父类每一个特点，必","title":"[Effective Cpp Notes] Ch06 继承与面向对象设计"},{"content":"26：尽可能延后变量定义式的出现时间 原因一：程序前面部分可能有if判断、异常处理等，可能不会运行到后面部分 原因二：直接构造的效率高于默认构造+赋值 原因三：变量可能在循环中使用，变量定义在循环内部而非循环前面，可以避免将变量的作用域扩大；除非对循环部分的性能有要求。 27：尽量少做转型动作 三种风格的转型： C语言风格：(T)expression 函数风格：T(expression) C++风格： const_cast\u0026lt;T\u0026gt;(expression)：去除const属性 dynamic_cast\u0026lt;T\u0026gt;(exprssion)：将指向为基类的指针转型为指向派生类的指针，可能耗费重大运行成本 尽量少使用 reinterpret_cast\u0026lt;T\u0026gt;(expression) static_cast\u0026lt;T\u0026gt;(expression)：最常用 28：避免返回handles指向对象内部成分 handles：引用、指针、迭代器 避免返回指向内部对象的handles，返回一个成员变量的副本 增加可封装性 帮助const成员函数的行为像一个const 将发生”dangling handles“的可能性降到最低（当临时对象析构后，也就无法通过handle获取对象内部的成员） 29：为“异常安全”而努力是值得的 异常安全的含义：当异常被抛出时 不泄露资源：使用RAII 不发生数据败坏 异常安全的函数提供三种不同级别的保证： 基本承诺：不发生数据败坏，但是不保证程序状态 强烈保证：程序状态不变（即程序回复到”调用函数之前“的状态） 通过RAII和调换代码顺序实现 或者通过copy and swap实现：创建副本资源并进行操作，所有操作完成后，使用一个不会抛出异常的swap将副本与当前资源进行交换 不抛掷承诺：总能完成功能，作用域内置类型上的所有操作都提供nothrow承诺 强烈保证有时无法实现 异常安全保证具有木桶效应 30：透彻了解内联的里里外外 inline最初只是针对编译器的优化建议，而非强制；是否内联由优化等级所控制，与是否内联无关\n声明： 隐式声明：将函数定义与类内部（但不是一种好的编程风格） 显示声明：inline 内联函数通常被置于头文件中，因为内联大部分情况下时编译期行为 inline必须放在函数定义前 从实现上看，inline放在函数声明前不起作用 从编程风格看，应该严格区分声明与定义，而且用户不需要、也没有必要知道该函数是否内联 inline只是对编译器的一个申请，不是强制命令 31：将文件间的编译依存关系降到最低 pimpl idiom（pimpl：pointer to implementation）设计思想： 原来main class包含类的具体实现逻辑 现在将main class中具体实现逻辑，放到一个实现类Impl中，在private中添加一个指向Impl的指针 因此main class只是提供接口，实现类Impl负责实现接口，”类的接口与实现分离“ 背景：即使只是改动类的实现，而不改变类的接口，这样所有包含该类的源码都要重新编译 根本原因在于，编译器在编译期必须知道对象的大小，如果不知道类的定义，就无法为对象分配内存 方法一：提供句柄类，用”声明的依存性“替换”定义的依存性“ 原来：假设1000个文件依赖于Person.h，这1000个文件都要重新编译链接 1 2 3 4 5 6 7 8 // Person.h class Person{ public: std::string name() const; private: std::string mName; } // 假设在Person.cpp中，略微修改了std::string Person::name()的实现，1000个文件需要全部重新编译 现在：只需要修改PersonImpl的具体实现，重新编译这一个文件即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Person.h class PersonImpl; // PersonImpl声明 class Person{ public: std::string name() const; private: PersonImpl *pImpl; } // Person.cpp #include \u0026#34;Person.h\u0026#34; #include \u0026#34;PersonImpl.h\u0026#34; std::string Person::name(){ return pImpl-\u0026gt;name(); // 调用实现类中同名函数 } // PersonImpl.h class PersonImpl{ // PersonImpl与Person有相同的public函数，且Person的private数据成员移动到了PersonImpl的private部分 public: std::string name() const; private: std::string mName; } // PersonImpl.cpp #include \u0026#34;PersonImpl.h\u0026#34; std::string PersonImpl::name() {return mName;} 方法二：将句柄类定义为抽象类 基类中定义一个工厂方法，返回动态类型为派生类，静态类型为基类的指针 因此修改派生类中的方法的实现逻辑，不会影响到基类，”类的接口与实现分离“ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Person.h class Person{ public: Person(); virtual std::string name() const; static std::shared\u0026lt;Person\u0026gt; create(const std::string\u0026amp; name); virtual ~Person(); }; // Person.cpp #include \u0026#34;Person.h\u0026#34; #include \u0026#34;RealPerson.h\u0026#34; std::shared\u0026lt;Person\u0026gt; Person::create(const std::string\u0026amp; name){ return std::shared\u0026lt;Person\u0026gt;(new RealPerson(name)) } // RealPerson.h class RealPerson: public Person{ public: RealPerson(std::string\u0026amp; name): mName(name) {}; virtual std::string name() const; virtual ~RealPerson(); private: std::string mName; } 参考 https://www.zhihu.com/question/52832178/answer/192499529 ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch05-%E5%AE%9E%E7%8E%B0/","summary":"26：尽可能延后变量定义式的出现时间 原因一：程序前面部分可能有if判断、异常处理等，可能不会运行到后面部分 原因二：直接构造的效率高于默认构造","title":"[Effective Cpp Notes] Ch05 实现"},{"content":"18：让接口容易被正确使用，不易被误用 函数接口传参，使用者可能理解错误或不小心传错 将函数参数封装为新的类型，比如封装新的年月日类，而非直接传入数字 限制类型内可以进行的操作 比如添加const限制，比如item3 尽量使自定义类型和内置类型的行为保持一致 消除使用者的资源管理责任 比如直接返回一个智能指针，而非返回一个raw指针 19：设计class犹如设计type 设计类时，考虑的问题：\n如何创建以销毁：如何实现构造函数和析构函数 初始化与赋值的区别：如何实现构造函数和赋值操作符 类对象传值：如何实现拷贝构造函数 成员类型的合法值：在构造函数和赋值操作中进行检查 继承关系的约束：基类的相关虚函数、成员函数是否需要被声明为virtual 是否允许由别的类转换而来：如何写转换构造函数 哪些操作符和函数是合理的 哪些操作符和函数应该拒绝 成员给哪些用户使用：成员的访问控制权限 新类型的未声明接口是什么 是否有必要将类一般化为类模板 这个新类型是否真的需要 20：传参时，尽量传常量引用而非传值 优点： 减少一次对象的复制 避免对象切割（比如形参是基类，实参是派生类），同时实现多态 使用传值的情况：内置类型，STL迭代器，函数对象 21：函数返回值尽量不要为引用 禁止在函数中返回一个指向局部变量的指针或引用 不要在函数中返回一个动态分配的对象 不要在可能多次调用的函数中返回一个局部静态变量 错误返回引用的例子： 返回栈空间中局部变量的引用：函数返回后，栈上相应对象被销毁，因此未定义 返回堆空间中局部变量的引用：虽然函数返回后不会释放对象，但是函数返回赋值的变量占有了堆空间的资源，而且极易容易忘记释放（因为一般也基本不会考虑对返回值进行delete），造成内存泄露 返回静态变量的引用：当多次调用该函数返回静态变量的引用时，静态变量只有一个，例子 C++11中可以使用移动语义，减少拷贝带来的消耗 22：将成员变量声明为private 将成员变量声明为public的缺点： 缺乏语法一致性：访问public成员变量，可以直接访问或者调用成员函数 对成员变量处理缺少准确控制：将成员变量设置为private的，可以提供setter/getter函数来控制其读写权限 不利于封装：在成员变量发生变化时，可以在相关函数中通知其他变量，从而进行相应修改 23：宁以non-member、non-friend替换member函数 功能颗粒度较高的函数设置为类外的函数，而非封装为public成员函数\n背景：public成员函数可分为两类： 功能颗粒度较低的函数：public/protected成员函数，内部直接访问private成员 功能颗粒度较高的函数：public/protected成员函数，内部由若干个public成员函数集成而来 尽量将功能颗粒度较高的函数封装为类外的函数： 优化类的封装性：如果封装为public函数，本来希望该函数只是public函数的集成，但是这样没法在代码层面体现出来 允许我们从更多维度组织代码结构，提供更大的包裹弹性：比如将不同public成员函数封装为不同功能的外部函数 优化编译依赖关系：比如不同的public成员函数可以封装为不同功能的外部函数，这些外部函数分别放在不同文件中，但是属于同一个命名空间中；这样使用时，需要哪个功能，就只需要包含该文件即可 24：若所有参数皆需要类型转换，请为此采用non-member函数 如果希望运算符的任意操作数可以发生隐式类型转换，则应该将运算符重载为非成员函数（比如友元）\n背景：运算符可以重载，重载为成员函数呢，还是重载为非成员函数呢？ 规定：如果运算符是成员函数，则它的第一个运算对象不会发生隐式类型转换 因为编译器根据第一个运算对象的类型，确定调用的运算符是属于哪一类的 比如：z = x * y等价于z = x.operator*(y)，x不会发生隐式类型转换 25：考虑写出一个不抛出异常的swap函数 如果Widge是一个类，可以在std命名空间中实现std::swap\u0026lt;T\u0026gt;的Widge全特化版本，同时在Widge中实现类内的swap函数以修改private成员的值 1 2 3 4 5 6 7 8 9 10 11 class Widget{ public: void swap(Widget\u0026amp; other){ // member swap using std::swap; // default swap // 调用std::swap进行private成员的处理 } } namespace std{ template\u0026lt;\u0026gt; // std::swap特例化版本 void swap\u0026lt;Widge\u0026gt; (Widget\u0026amp; a, Widget\u0026amp; b) { a.swap(b);} } 如果Widge是一个类模板 不能偏特例化一个函数模板 1 2 3 4 namespace std{ template\u0026lt;typename T\u0026gt; // non-member swap void swap\u0026lt;Widget\u0026lt;T\u0026gt;\u0026gt; (Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) {a.swap(b);} // 编译报错 } 但是可以偏特例化一个类模板，添加一个重载版本 但是不要在std命名空间中添加新东西 1 2 3 4 namespace std{ template\u0026lt;typename T\u0026gt; void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) {a.swap(b);} } 解决方法：置于一个新的命名空间中 1 2 3 4 5 6 7 namespace WidgetStuff{ template\u0026lt;typename T\u0026gt; class Widget{ ... }; template\u0026lt;typename T\u0026gt; void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) {a.swap(b);} } 因此，如果想使得Widget专属版swap在尽可能多的语境下被调用，需要 在Widget中提供一个public swap函数（不可抛出异常），内部调用std::swap 同时可能需要同时实现两个版本： Widget所在命名空间WidgetStuff中，实现一个nom-member swap，内部调用Widget::swap 如果Widget是一个类而非类模板，在std中特化std::swap，内部调用Widget::swap C++11之后，std::swap改用std::move实现，所以几乎不存在性能缺陷 ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch04-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/","summary":"18：让接口容易被正确使用，不易被误用 函数接口传参，使用者可能理解错误或不小心传错 将函数参数封装为新的类型，比如封装新的年月日类，而非直接传","title":"[Effective Cpp Notes] Ch04 设计与声明"},{"content":"13：以对象管理资源 资源获取即初始化（RAII）：使用析构函数确保资源被释放 复制时使用移动语义，移交资源的所有权 背景：使用动态内存分配时，很容易忘记delete，尤其是程序在中间退出（比如if判断后return） RAII（Resource Acquisition Is Initialization）资源获取即初始化： 资源的有效期与持有资源的对象的生命周期严格绑定（即获取资源的时候要通过构造函数初始化） 对象独占资源 即让编译器在每个退出的分支上，对象都进行析构，从而释放资源 使用模板更加方便 移交所有权 背景：如果两个指针同时指向一个资源，会析构两遍；因此RAII类独占资源（类似unique_ptr） 在RAII类中，将拷贝相关的函数设置为=delete，RAII无法进行拷贝 因此只能通过移动构造函数使用std::move进行移交所有权 如何把RAII类作为函数的参数 值传递：各位caller，我不要ownership了，请拿走 非const引用传递：拿不拿走都行，提前商量好（不推荐） const引用传递：可以拿走用一下，但是ownership还是我的 右值引用：同第二条，无法确定caller是否拿走了ownership C++98与C++11 C++98中std::auto_ptr类似于C++11中std::unique_ptr，但是std::unique_ptr不允许所有权被转移 C++98中std::tr1::shared_ptr类似于C++11中std::shared_ptr，weak_ptr只是拥有资源的使用权而非所有权，因此不占用引用计数，可以解决环状引用的问题 梳理：RAII作为一种管理资源的方式（或思想），早期使用auto_ptr作为解决方案，C++11之后使用unique_ptr和move语义作为解决方案 参考： 现代C++学习—— 什么是RAII 14：在资源管理类中小心copying行为 复制RAII对象必须一并处理资源的copy行为\ncopy行为的不同情况： 大部分情况下，对RAII对象的复制操作本身就不合法 对底层资源使用引用计数法（shared_ptr） 复制底层资源（行为像值，进行深拷贝） 转移资源所有权（unique_ptr） 15：在资源管理类中提供对原始资源的访问 将RAII对象转换为对资源的直接访问 通过显示转换：提供一个get()函数返回智能指针内部的原始指针 通过隐式转换 像使用原始指针一样使用智能指针，比如智能指针一样可以使用-\u0026gt;访问成员 直接访问原始指针：在RAII类内实现返回原始指针的类型转换运算符 16：成对使用new和delete时要采取相同形式 new一个对象，使用delete释放；new一个数组，使用delete []进行释放 delete []表示知道释放的是数组，读取数组元素数量，从而多次调用析构函数 尽量避免对数组使用typedef，此时在delete时很容易出现混淆：用delete还是delete[]，可以的话可以使用std::vector等容器 17：以独立语句将new的对象置入智能指针 背景：编译器可能对单一语句中的执行顺序进行重新调整 1 2 3 4 5 6 7 8 9 10 int priority() {} void func(std::shared_ptr\u0026lt;MyResource\u0026gt; sp, int priority) {} func(std::shared_ptr\u0026lt;MyResource\u0026gt;(new MyResource), priority()); /* 该语句的执行顺序可能是： MyResource* tmp_ptr = new MyResource; int priority = priority(); std::shared_ptr\u0026lt;MyResource\u0026gt; sp = std::shared_ptr\u0026lt;MyResource\u0026gt;(tmp_ptr); */ 如果int priority = priority();执行失败，则tmp_ptr指向的临时资源无法被释放，发生内存泄漏 根本原因是：资源被创建和资源被转换成资源管理对象有时间差，中间可能有干扰 解决方法：以独立语句将new的对象置于智能指针中，因为编译器无法对跨语句的操作进行调整 1 2 std::shared_ptr\u0026lt;MyResource\u0026gt; sp(new MyResource); func(sp, priority()); ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch03-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","summary":"13：以对象管理资源 资源获取即初始化（RAII）：使用析构函数确保资源被释放 复制时使用移动语义，移交资源的所有权 背景：使用动态内存分配时，很","title":"[Effective Cpp Notes] Ch03 资源管理"},{"content":"05：了解C++默默编写并调用了哪些函数 如果没有自定义相应拷贝控制成员，而且需要使用该拷贝控制成员，则编译器进行合成 有时编译器不会进行合成，因为一些操作非法 1 2 3 4 class MyClass {}; MyClass m1; // 生成默认构造函数和析构函数 MyClass m2(m1); // 生成复制构造函数 m2 = m1; // 生成赋值构造运算符 默认构造函数和析构函数 作用：调用{基类和non-static成员变量}的构造函数和析构函数 当自定义构造函数后，编译器就不会自动生成构造函数 生成的析构函数是non-virtual的，除非基类的析构函数是virtual的 复制构造函数 赋值构造运算符 自动生成赋值构造运算符的条件是，相关操作必须合法 比如成员变量是const或引用，则不能进行赋值 比如基类中赋值构造运算符是private的，则派生类中无法调用父类相应的赋值构造运算符对父类成员进行赋值 06：若不想使用编译器自动生成的函数，就该明确拒绝 在声明中将拷贝控制成员标记为=delete，将不会自动生成该拷贝控制成员\n背景：有时不希望类具有拷贝等行为（语义要求） 三种方法：将不需要自动生成的拷贝控制成员 在private中进行定义 虽然类外部无法访问，但不是绝对安全，可以在成员函数和友元中使用 写为空函数体，使其在链接过程中报错 在基类中声明为private 这样即使在成员函数和友元中使用相应拷贝控制成员，也会因为无法拷贝控制相应基类成员，从而将报错从链接期提前到编译期 在声明中标记为=delete 07：为多态基类声明virtual析构函数 声明多态性质的基类的析构函数为virtual的\n背景：当delete一个指向派生类的基类指针时，只会调用non-virtual的基类析构函数，派生类中成员无法释放 只有当类中至少包含一个除析构函数外的virtual函数时（多态性质），才将析构函数声明为virtual的 为了保持可移植性 如果该类不包含virtual函数，则通常该类不会作为基类 将基类析构函数声明为pure virtual函数，从而将基类构造为抽象基类（避免了考虑将其他哪个函数声明为pure virtual函数） 所有的STL容器都不包含virtual析构函数，因此不要将STL容器作为基类 因为STL容器设计不是用来作为基类，不带有多态语义要求，只有多态性质的基类才需要声明一个virtual析构函数 不是所有基类都带有多态性质 08：别让异常逃离析构函数 析构函数不要抛出异常，但是析构函数中可以使用try catch进行异常处理 C++11中，默认将析构函数声明为noexcept，防止在析构函数中抛出异常 try语句块中抛出异常时，会将作用域中对象依次调用析构函数，然后进入catch语句块中 如果此时调用的析构函数中继续报错，则core dumped 可以在析构函数中使用try catch捕获异常，或者重新设计接口，使得防止抛出异常的函数在析构函数中被调用 09：绝不在构造和析构过程中调用virtual函数 不要再构造/析构函数（及其调用的函数中）中调用virtual函数，因为这样虚函数不会呈现多态\n当派生类中的基类部分被构造时，其调用的虚函数只会调用基类中的版本，不会调用派生类中的版本，即不会呈现多态 从安全性角度看，因为此时派生类部分还未构造，使用派生类的虚函数版本可能产生未定义的行为，所以C++规定使用基类的版本 从原理角度看，在构造基类部分时，对象的类型实际上是基类类型 当派生类中的基类部分被析构时，同样不会呈现多态 从安全性角度看，此时派生类部分已经析构，调用派生类的虚函数版本产生未定义的行为 从原理角度看，此时对象为基类类型 构造函数/析构函数内调用的函数，也要保证其中不调用虚函数 10：令operator=返回一个reference to *this 令赋值运算符返回一个*this的引用\n11：在operator=中处理自我赋值 进行重新排列赋值或者copy and swap\n背景：有时可能很隐蔽的进行了自赋值的操作，特别是类管理资源时，很可能被意外delete掉 进行重新排列赋值：先保存当前资源副本，然后new，最后delete原来的资源；可以保证异常安全性，而且identity test没有必要 1 2 3 4 5 6 MyClass\u0026amp; operator= (const MyClass\u0026amp; rhs){ Resource* tmp = MyResource; MyResource = new Resource(); // 如果new失败，则当前资源不会被释放 delete tmp; // new成功 return *this; } copy and swap 12：复制对象时勿忘记其每一个成分 派生类复制时，不要忘记将基类部分也复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Base{ public: Base(int id): base_id(id) {} Base(const Base\u0026amp; b): base_id(b.base_id) {} Base\u0026amp; operator= (const Base\u0026amp; b) { base_id = b.base_id; return *this;} private: int base_id; }; class Derived: public Base{ public: Derived(int id, string name): Base(id), myname(name) {} Derived(const Derived\u0026amp; d): Base(d), myname(d.myname) {} // 将派生类直接赋值给基类，派生类被切掉 Derived\u0026amp; operator= (const Derived\u0026amp; d){ Base::operator=(d); // 调用基类operator= myname = d.myname; return *this; } private: string myname; }; ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch02-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/","summary":"05：了解C++默默编写并调用了哪些函数 如果没有自定义相应拷贝控制成员，而且需要使用该拷贝控制成员，则编译器进行合成 有时编译器不会进行合成，","title":"[Effective Cpp Notes] Ch02 构造、析构、赋值运算"},{"content":"01 视C++为一个语言联邦 C++高效编程守则视状况而变化，取决于你使用C++的哪一部分\nC++支持面向过程、面向对象、面向函数、泛型编程、元编程，因此可以将C++视为一个由相关语言组成的联邦而非单一语言（各个方面的编程范式不太相同）： C：有指针、数组，没有模板、重载和异常 Object-Oriented C++：类、封装、继承、多态、虚函数 Template C++：模板元编程 STL： 编程范式（或者编程技巧）的区别： 对于C而言，传值比传引用更加高效 对于Object-Oriented C++而言，常量引用传递往往更好（可以传递左值、右值） 对于Template C++而言，模板往往不知道处理的对象是什么类型 对于STL而言，迭代器和函数对象是基于C的指针，所以此时应该选择值传递 02：尽量以const,enum,inline替换#define 尽量使用编译器操作代替预处理器操作： 对于常量，尽量使用const对象或enum来替换#define 对于形似函数的宏，最好改用inline替换#define 尽量使用编译器操作代替预处理器操作 #define是在预处理阶段进行替换，宏的名字不会出现在符号表中。 对于常量，尽量使用const对象或enum来替换#define 两个典型场景： 定义常量指针 定义class专属常量，比如const static成员 类内static成员可以进行【声明时初始化】，虽然不是定义（即没有分配空间），但是只要不取地址，此时也可以使用该变量 如果类内static成员进行【声明时初始化】，而且需要取地址，则需要在类外对变量进行定义 1 2 3 4 class Widget{ const static int val = 0; }; const int Widget::val; // 由于const，无法进行赋值 对于形似函数的宏，最好改用inline替换#define 虽然使用宏本身少了一次调用过程，但是有时即使加上括号，结果也不正确 1 2 3 4 5 #define CALL_WITH_MAX(a, b) f((a) \u0026gt; (b) ? (a) : (b)) int a = 5, b = 0; CALL_WITH_MAX(++a, b); // a 累加了一次 CALL_WITH_MAX(++a, b + 10); // a 累加了两次 使用inline可以保证正确性，并且可以使用模板 参考 https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/master/1.AccustomingYourselfToCpp/02.PreferConstsEnumsInlinesToDefine.md 03：尽可能使用const 声明为const可以帮助编译器检测错误 const成员函数默认遵循bitwise constness，但是编写程序时应该使用logical constness，必要时将成员声明为mutable来保证可以修改 const和non-const成员函数有实质等价的实现，令non-const版本调用const版本可以避免代码重复 const和指针：顶层const与底层const const和STL：const迭代器是顶层const，const_iterator是底层const const和函数： 函数返回值和函数形参尽量声明为const的，有助于编译器定位相关报错 比如将比较运算符==误写为赋值运算符= 成员函数声明为const的 使得成员函数更容易被理解（这个成员函数不能修改成员），而且此时形参往往也是const引用 一个const成员函数，一个non-const成员函数，可以进行重载 const对象调用const版本成员函数，普通对象调用non-const版本成员函数 常量性转移 背景：const成员函数与non-const成员函数中间逻辑相同，可能存在大量的重复代码，一个方法是将重复的代码写成函数放在private中 更好的办法是，让non-const成员函数调用const成员函数（如果反过来，const成员函数调用non-const成员函数，不能保证对象不被修改） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class TextBlock{ public: const char\u0026amp; operator[] (std::size_t pos) const{ // do something return text[pos]; } char\u0026amp; operator[] (std::size_t pos) { return const_cast\u0026lt;char\u0026amp;\u0026gt;( static_cast\u0026lt;const TextBlock\u0026amp;\u0026gt;(*this) // *this是TextBlock\u0026amp;, 强转加上const [pos] // const TextBlock\u0026amp;调用operator[]，否则TextBlock\u0026amp;调用operator[]一直重复调用自己 ); } private: std::string text; } mutable：使得成员变量即使在const成员函数中也可以被修改，主要是为了实现logical constness 背景：bitwise constness与logical constness bitwise constness：成员函数不应该修改任何non-static成员变量（const成员函数的默认方式） 编译器容易实现，只需要寻找成员变量的赋值操作 logical constness：允许成员函数修改成员变量，对于使用者而言，可以体现出constness即可 比如一个指针成员变量，按照bitwise constness，限定指针为顶层的，但是却无法保证不修改所指对象 参考 https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/master/1.AccustomingYourselfToCpp/03.UseConstWheneverPossible.md 04：确定对象被使用前已被初始化 内置类型对象一定要进行手动初始化 构造函数中最好使用初始化列表对成员变量进行初始化，而非在函数体中进行赋值 为了避免跨编译单元的初始化顺序问题，尽量以local static对象代替non-local static对象 内置类型变量的初始化 内置类型变量（即使是类中的内置类型成员变量）是否会初始化，取决于其在内存中的位置（堆空间？栈空间？） 自定义类对象的初始化 初始化与赋值的区别 赋值：比如在构造函数函数体中进行“赋值” 非内置类型的成员变量的初始化发生在进入构造函数之前，每个成员变量的default构造函数被自动调用，构造了两次（默认构造一次，复制构造一次） 但是内置类型的成员变量不会自动初始化，此时无区别 初始化：比如在构造函数初始化列表中 此时相当于只调用了一次成员变量的构造函数（赋值构造） 如果是const或者是引用，此时不能被赋值，只能进行初始化 变量初始化顺序 在初始化列表中，编译器按照父类-\u0026gt;子类的顺序进行成员变量初始化，但尽量还是与成员声明顺序保持一致 不同编译单元内定义的non-local static对象的初始化顺序 一些情况下，不同编译单元内的non-local static对象的初始化顺序有要求，但是C++没有明确定义（比如要求先FileSystem中tfs初始化，后Diectory中tdr初始化） 将每个 non-local static 对象移至自己的专属函数内（变成 local static 对象） ","permalink":"https://qinganzhang.github.io/posts/effective-cpp/ch01-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc++/","summary":"01 视C++为一个语言联邦 C++高效编程守则视状况而变化，取决于你使用C++的哪一部分 C++支持面向过程、面向对象、面向函数、泛型编程、元编程","title":"[Effective Cpp Notes] Ch01 让自己习惯C++"},{"content":"contact me at: zhangqingannn@gmail.com\n","permalink":"https://qinganzhang.github.io/about/","summary":"contact me at: zhangqingannn@gmail.com","title":"About"}]