<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>cpp on Paul&#39;s Blog</title>
    <link>https://qinganzhang.github.io/tags/cpp/</link>
    <description>Recent content in cpp on Paul&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 29 Feb 2024 14:54:23 +0800</lastBuildDate><atom:link href="https://qinganzhang.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode刷题记录</title>
      <link>https://qinganzhang.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 29 Feb 2024 14:54:23 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
      <description>[toc] tags：【双指针】，【前缀和】，【原地哈希】 【好题】，【不会】，【重要】，【继续看】 方法 双指针 前后定长双指针 前后快慢双指针 左右双向双指针</description>
      <content:encoded><![CDATA[<p>[toc]</p>
<p>tags：【双指针】，【前缀和】，【原地哈希】</p>
<p>【好题】，【不会】，【重要】，【继续看】</p>
<h2 id="方法">方法</h2>
<h3 id="双指针">双指针</h3>
<h4 id="前后定长双指针">前后定长双指针</h4>
<h4 id="前后快慢双指针">前后快慢双指针</h4>
<h4 id="左右双向双指针">左右双向双指针</h4>
<ul>
<li><a href="https://leetcode.cn/problems/valid-triangle-number/description/">611.有效三角形的个数</a>
<ul>
<li>方法一：二重循环a、b，对c进行二分查找（查找最后一个满足<code>a+b&lt;c</code>的c）</li>
<li>方法二：遍历c，左右双指针表示<code>a(nums[i])</code>和<code>b(nums[j])</code>，<a href="https://leetcode.cn/problems/valid-triangle-number/solutions/2432875/zhuan-huan-cheng-abcyong-xiang-xiang-shu-1ex3">参考</a>
<ul>
<li><code>if(nums[i] + nums[j] &gt; c)</code> ，此时有j-i个三角形，j向左走（i向右走无用）</li>
<li><code>if(nums[i] + nums[j] &lt;= c)</code> ，此时有0个三角形，i向右走（j向左走无用）</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/container-with-most-water/description/">11.盛最多水的容器</a>：盛水体积只取决于左右两隔板的高度（木桶理论）
<ul>
<li>区别于接雨水，雨水可能分布在不连续的凹陷处</li>
</ul>
</li>
</ul>
<h4 id="两分支双指针">两分支双指针</h4>
<ul>
<li><a href="https://leetcode.cn/problems/compare-version-numbers/description/">165.比较版本号</a></li>
</ul>
<h3 id="滑动窗口">滑动窗口</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></p>
<ul>
<li>基于双指针的滑动窗口</li>
<li>必须使用滑动窗口保证水果是连续的，如果只使用哈希表，则可能出现中间有中断的情况</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a>：<a href="https://leetcode.cn/problems/minimum-window-substring/submissions/498126388">代码</a></p>
<ul>
<li>对t统计词频，得到相同的两个ump：<code>tump</code>和<code>tmp_ump</code></li>
<li>只移动右指针，找到s中第一个包含t的区间
<ul>
<li>移动右指针的过程中，逐步递减并erase<code>tmp_ump</code>中的元素，直到<code>tmp_ump</code>为空，此时就找到了s中第一个包含t的区间，同时维护区间的词频<code>win_ump</code></li>
</ul>
</li>
<li>窗口进行移动：将<code>c=s[left++]</code>从<code>win_ump</code>中减一，同时左指针向右移动了一位，
<ul>
<li>如果此时<code>win_ump[c] &gt;= tump[c]</code>，说明c不在t中，或者c是t中是多余重复的，因此continue</li>
<li>如果此时<code>win_ump[c] &lt; tump[c]</code>，说明c是t中的，需要右指针向右移动，再次找到c字符，因此得到了新的窗口</li>
<li>技巧：可以<code>s+=' '</code>，避免最后跳出循环还要移动左指针，</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3.无重复字符的最长子串</a> 【重要】</p>
<ul>
<li>同<a href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=295&amp;tqId=1008889&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj">最长无重复子数组</a>，都是用左右双指针作为滑动窗口，同时数组做哈希用于判断是否用过该元素</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">1004.最大连续1的个数Ⅲ</a></p>
<ul>
<li>两种思路
<ul>
<li><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/submissions/496425055/">复杂的代码</a>：维护窗口内0的数量，但同时也分情况讨论左右断点的情况</li>
<li><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/submissions/496458757">简洁的代码</a>：找出一个最长的子数组，该子数组中最多有k个0，因此只需要维护窗口内0的数量即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数组二刷">数组【二刷】</h2>
<h3 id="模拟题">模拟题</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/diagonal-traverse/description/">498.对角线遍历</a>：<code>i+j==level</code></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/rotate-image/description/">48.旋转图像</a></p>
<ul>
<li>最重要的是找到原来<code>(i,j)</code>位置的元素，旋转之后在什么位置（<code>(j,n-i-1)</code>）</li>
<li>矩阵变换的方法也是从上面的对应关系来的
<ul>
<li>先转置<code>(j,i)</code>，再水平翻转<code>(j,n-i-1)</code></li>
<li>或者先垂直翻转<code>(n-i-1,j)</code>，再转置<code>(j,n-i-1)</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/spiral-matrix/description/">54.螺旋矩阵</a> 和 <a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></p>
<ul>
<li>按圈遍历，设定四个逐步减小的边界</li>
<li>每圈遍历中，判断新到达的位置是否超出边界，若是则改变方向</li>
</ul>
</li>
</ul>
<h3 id="二分查找">(二分)查找</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 假设v非递减
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">find_first_ge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 返回第一个&gt;=target的元素的索引（lower_bound）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// target is in left part
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// target is in right part
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// v[mid] == target, 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">left</span><span class="p">;</span> <span class="c1">// now left == right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find_first_gt</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 返回第一个&gt;target的元素的索引（upper_bound）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// difference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find_last_le</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 返回最后一个&lt;=target的元素的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">find_first_gt</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 即第一个&gt;target的元素的前一个位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find_last_lt</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 返回最后一个&lt;target的元素的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">find_first_ge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 即第一个&gt;=target的元素的前一个位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240.搜索二维矩阵Ⅱ</a>
<ul>
<li>方法一：从右上开始，按照搜索二叉树的逻辑查找</li>
<li>方法二：每行进行一次二分查找</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/find-peak-element/">162.寻找峰值</a>  【继续看】
<ul>
<li>方法一：分治，类似归并排序，递归找最大值</li>
<li>方法二：类似二分查找，判断nums[mid]与nums[mid+1]的大小关系（即判断中点是上坡还是下坡），从而修改左右索引
<ul>
<li>原理是因为开始时left和right都是最小值，此后mid部分永远是高点</li>
<li>细节：在函数体中，left与right不相等，因此mid永远不会等于right，同时left与right是左闭右闭，<a href="https://leetcode.cn/problems/find-peak-element/submissions/494663427">代码</a></li>
</ul>
</li>
</ul>
</li>
<li>搜索旋转排序数组系列：是否有重复数字，如果有重复数组，首先移动左右端点，保证left和right指向的元素不同。多使用原语表示（比如<code>find_first_gt</code>、<code>find_first_ge</code>）
<ul>
<li><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33.搜索旋转排序数组</a>：首先二分找到分界点，然后在左边或者右边再次进行二分（此时范围是有序的）</li>
<li><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/solutions/704686/sou-suo-xuan-zhuan-pai-xu-shu-zu-ii-by-l-0nmp/">81.搜索旋转排序数组Ⅱ</a>：尝试将问题转换到<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33.搜索旋转排序数组</a>，<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/solutions/2606169/luo-ji-qing-xi-de-81sou-suo-xuan-zhuan-p-34qr/">我的题解</a></li>
<li><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154.寻找旋转排序数组中的最小值Ⅱ</a>   <a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=295&amp;tqId=23269&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295">BM21旋转数组的最小数字</a></li>
</ul>
</li>
</ul>
<h3 id="排序">排序</h3>
<ul>
<li>
<p>快排：在partition时，如果选left作为pivot，则需要先移动右边的指针，<a href="https://www.cnblogs.com/MAKISE004/p/16909610.html">原理</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">qSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">){</span> <span class="c1">// [left, right]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">])</span> <span class="k">return</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="p">{</span><span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span> <span class="k">return</span> <span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 左中右，取中间大小的值，放在最左边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">right</span><span class="p">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]),</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">pivot</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">pivot</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意元素是覆盖的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="p">)</span> <span class="o">--</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">)</span> <span class="o">++</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="c1">// now: left == right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 缩小中轴范围，尤其针对重复元素多的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">begin</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">--</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">++</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">qSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">qSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>归并排序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 归并排序需要辅助数组，因为前后两个有序数组是连着的，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">in</span><span class="p">){</span> <span class="c1">// [begin, end)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">begin</span> <span class="o">&gt;=</span> <span class="n">end</span> <span class="o">||</span> <span class="n">begin</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">begin</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mergeSort</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span> <span class="c1">// [begin, mid)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mergeSort</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span> <span class="c1">// [mid, end)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// now left part and right part are all sorted, merge them into out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">begin</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span> <span class="c1">// stable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">)</span> <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// copy out back to in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="n">in</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=295&amp;tqId=23260&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295">BM20 数组中的逆序对</a>： 归并方式，前后两段数据都是有序数组，比如前面一段数组中<code>nums[a]</code>大于后面一段数组中<code>nums[b]</code>，则前面数组中<code>[a:mid)</code>这一段元素都大于<code>nums[b]</code>，这些都是逆序对，只需在归并时统计这样的长度即可。<a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=295&amp;tqId=23260&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295">代码</a></li>
</ul>
</li>
<li>
<p>堆排序</p>
<ul>
<li>
<p>第一种方法：数组原地构建最大堆，数组原地进行排序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">heapSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">buildMaxHeap</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 将最大堆的首元素（最大元素）放在数组后面位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">adjust</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">--</span><span class="n">len</span><span class="p">);</span> <span class="c1">// 首元素变了，因此需要调整，同时堆的长度减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">buildMaxHeap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">){</span> <span class="c1">// n/2-1是最后一个非叶节点，依次向上检测和调整每个非叶节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">adjust</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">adjust</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 当前节点的索引为idx，在[0, len)范围内是最大堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">leftSon</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rightSon</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">largeIdx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span> <span class="c1">// largeIdx指向{根节点，左孩子，右孩子}中较大的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">leftSon</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">leftSon</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="n">largeIdx</span> <span class="o">=</span> <span class="n">leftSon</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">rightSon</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">rightSon</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">largeIdx</span><span class="p">])</span> <span class="n">largeIdx</span> <span class="o">=</span> <span class="n">rightSon</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">largeIdx</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">largeIdx</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="n">idx</span> <span class="o">=</span> <span class="n">largeIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第二种方法：数组构建最小堆，依次弹出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 手写堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">minHeap</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">minHeap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span><span class="o">:</span> <span class="n">heap</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">len</span> <span class="o">=</span> <span class="n">heap</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// build minHeap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="n">adjust</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">adjust</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">leftSon</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">rightSon</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">largeIdx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span> <span class="c1">// largeIdx指向{根节点，左孩子，右孩子}中较大的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">leftSon</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">heap</span><span class="p">[</span><span class="n">leftSon</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="n">largeIdx</span> <span class="o">=</span> <span class="n">leftSon</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">rightSon</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">heap</span><span class="p">[</span><span class="n">rightSon</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">largeIdx</span><span class="p">])</span> <span class="n">largeIdx</span> <span class="o">=</span> <span class="n">rightSon</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">largeIdx</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">swap</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">heap</span><span class="p">[</span><span class="n">largeIdx</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">                <span class="n">idx</span> <span class="o">=</span> <span class="n">largeIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>        
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">top</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">];}</span> <span class="c1">// return min value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">swap</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">heap</span><span class="p">[</span><span class="o">--</span><span class="n">len</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">adjust</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 或者调用优先队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">heapSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">n</span><span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span><span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">());</span> <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/largest-number/description/">179.最大数</a></p>
<ul>
<li>巧妙的自定义排序规则：<code>a+b&lt;b+a</code></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">215.数组中的第k个最大元素</a> 【重要】</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">findKthLargest</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">){</span> <span class="c1">// [begin, end), 快排逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">begin</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">begin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">begin</span><span class="o">+</span><span class="mi">2</span> <span class="o">==</span> <span class="n">end</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">begin</span><span class="p">)</span> <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">begin</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">begin</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">begin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">begin</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">begin</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">begin</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// [left, right]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">)</span> <span class="o">--</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="p">)</span> <span class="o">++</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="c1">// now left == right        
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">mid</span><span class="p">)</span> <span class="k">return</span> <span class="n">pivot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">mid</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">--</span><span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">findKthLargest</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// 注意这里还是传入[begin, mid+1)而非[begin, mid)，因为经过while优化，此时mid可以退到和begin位置相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">{</span> <span class="c1">// k-1 &gt; mid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">mid</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">++</span><span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">findKthLargest</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c1">// 注意这里还是传入[mid, end)而非[mid+1, end)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><a href="https://leetcode.cn/problems/smallest-k-lcci/description/">剑指40.最小k个数</a>：快排逻辑</p>
</li>
</ul>
<h3 id="套路题">套路题</h3>
<ul>
<li><a href="https://leetcode.cn/problems/longest-common-prefix/description/">14.最长公共前缀</a>
<ul>
<li>按行比，按列比，都行</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a>
<ul>
<li>方法一：贪心+双指针</li>
<li>方法二：前缀和+二分
<ul>
<li>细节较多：前缀和是inclusive的还是exculsive的（<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/submissions/494871477">这里</a>用的是exculsive的），二分找的是第一个大于val的位置</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/description/">剑指21.调整数组顺序使奇数位于偶数前面</a>
<ul>
<li>如果不需要保持奇数/偶数内部的相对顺序，左右双指针向内走</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/majority-element/description/">169.多数元素</a>
<ul>
<li>投票法：维护一个元素值value和计数值cnt，数组元素等于value时累加cnt，不等于value时递减cnt，当cnt==0时更新value</li>
<li>可以保证最后众数的cnt至少为1</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">128.最长连续序列</a>
<ul>
<li>哈希表<code>unordered_map&lt;int, bool&gt;</code>（bool表示是否使用过该数字），元素往前往后分别试探</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/next-permutation/description/">31.下一个排列</a> ： <a href="https://leetcode.cn/problems/next-permutation/solutions/2547378/jiao-ni-yi-bu-yi-bu-xie-chu-zui-jian-dai-saaz">题解</a>  与<a href="https://leetcode.cn/problems/next-greater-element-iii/description/">556.下一个更大元素Ⅲ</a>相同
<ul>
<li>从后往前遍历，找到一个最长的后缀，这个后缀是逆序的（即该后缀从前往后看递减，从后往前看递增）</li>
<li>该最长后缀前面一个元素<code>nums[idx]</code>，是小于最长后缀的第一个元素的</li>
<li>在该最长后缀中，找到最后一个<code>&gt;nums[idx]</code>的元素<code>nums[pos]</code>，然后交换（因此最长后缀又变长了一位）</li>
<li>最后<code>reverse[idx+1, end)</code>，因此数组前面部分不动，后面部分得到了下一个排列</li>
</ul>
</li>
</ul>
<h3 id="综合">综合</h3>
<ul>
<li><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">560.和为K的子数组</a>：【前缀和】+【哈希表】
<ul>
<li>通过前缀和可以将区间和转换为两个点的查询</li>
<li>通过哈希表记录遍历过的位置的前缀和（value是特定前缀和的计数）</li>
<li>现在已知一个点和中间差值，通过哈希找到另一个点</li>
<li>区别<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a></li>
</ul>
</li>
</ul>
<h3 id="字符串">字符串</h3>
<h4 id="模拟">模拟</h4>
<ul>
<li><a href="https://leetcode.cn/problems/add-strings/">415.字符串相加</a>  <a href="https://leetcode.cn/problems/multiply-strings/description/">43.字符串相乘</a></li>
<li><a href="https://leetcode.cn/problems/string-compression/description/">443.压缩字符串</a></li>
<li><a href="https://leetcode.cn/problems/zigzag-conversion/description/">6.Z字形变换</a></li>
<li><a href="https://leetcode.cn/problems/validate-ip-address/description/">468.验证IP地址</a>：先判断有<code>.</code>还是<code>:</code>，然后根据<code>.</code>或者<code>:</code>分割之后，逐段判断</li>
<li><a href="https://leetcode.cn/problems/reverse-integer/description/">7.整数反转</a>：用字符串表示数字</li>
<li><a href="https://leetcode.cn/problems/fraction-to-recurring-decimal/description/">166.分数到小数</a>：首先注意符号问题，然后注意能否整除，最后逐次<code>*10</code>模拟竖式除法</li>
</ul>
<h4 id="套路">套路</h4>
<ul>
<li>
<p>翻转字符串的妙用：局部翻转后再整体反转（或反过来），达到子串位置颠倒的效果</p>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">LCR 182. 动态口令</a></p>
</li>
</ul>
</li>
<li>
<p>KMP系列</p>
<ul>
<li><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">实现strStr</a></li>
</ul>
</li>
</ul>
<h2 id="链表二刷">链表【二刷】</h2>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
<ul>
<li>
<p>注意递归写法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 递归，返回反转链表的头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="k">nullptr</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">==</span><span class="k">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span> <span class="c1">// 当前是空节点，或者是最后一个节点    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ListNode</span><span class="o">*</span> <span class="n">newHead</span> <span class="o">=</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> <span class="c1">// 已经将head-&gt;next部分的链表处理完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span>  <span class="o">=</span> <span class="n">head</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">newHead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>迭代写法1：遍历，修改相邻节点的指针指向</p>
</li>
<li>
<p>迭代写法2：创建<strong>虚拟头节点</strong>，进行<strong>头插法</strong>（遍历链表，插入到虚拟头节点之后）</p>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a> 【好题】</p>
<ul>
<li>快慢指针可以判断有环</li>
<li><a href="https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF">如何找到这个环的入口</a></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/sort-list/description/">148.排序链表</a></p>
<ul>
<li>递归方法：（自顶向下的）归并排序，时间复杂度O(n logn)，空间复杂度O(logn)</li>
<li>迭代方法：自底向上的归并排序，时间复杂度O(n logn)，空间复杂度O(1)</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/reorder-list/description/">143.重排链表</a> 【好题】</p>
<ul>
<li>先快慢指针寻找中点，然后后半段链表原地反转，最后两个链表合并</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">23.合并K个升序链表</a></p>
<ul>
<li>最小堆：<code>priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq;</code></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/add-two-numbers-ii/description/">445.两数相加Ⅱ</a></p>
<ul>
<li>一种方法是反转链表，另一种是使用栈进行计算</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/lru-cache-lcci/description/">LRU缓存</a> 【好题】<a href="https://www.nowcoder.com/practice/5dfded165916435d9defb053c63f1e84?tpId=295&amp;tqId=1024689&amp;ru=%2Fexam%2Foj&amp;qru=%2Fta%2Fformat-top101%2Fquestion-ranking&amp;sourceUrl=%2Fexam%2Foj">代码</a></p>
<ul>
<li>
<p>数据结构：双向链表维护最近更新的节点，<code>unordered_map&lt;int,Node*&gt;</code>实现从key到链表中节点的映射</p>
</li>
<li>
<p>设置dummyHead与dummyTail，可以避免专门判断head与tail是否为空（因为是双向链表，所以要设置头尾两个dummyNode）</p>
</li>
<li>
<p>在Node中需要同时包含key和value，因为当删除某个node时，需要知道其对应的key，从而删除哈希表中对应的表项</p>
</li>
<li>
<p>在向链表插入节点或是从链表中删除节点时，不要忘记更新map</p>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/lfu-cache/description/">LFU缓存</a> 【好题】</p>
<ul>
<li>方法一：map记录key到Node的映射，使用平衡二叉树保存Node的结构</li>
<li>方法二：双哈希表</li>
</ul>
</li>
</ul>
<h3 id="递归">递归</h3>
<p>递归写法代码量一般比较少，也比较优雅，尤其在没有头节点的情况下避免对头节点另外判断</p>
<ul>
<li><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/">138.随机链表的复制</a></li>
<li><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21.合并两个有序链表</a></li>
</ul>
<p><a href="https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=295&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=%2Fexam%2Fcompany">单链表的排序</a>：归并排序</p>
<h2 id="哈希表二刷">哈希表【二刷】</h2>
<ul>
<li>
<p>有时可以直接使用数组进行哈希，有时需要使用map（unordered_map）或set（unordered_set）进行哈希，注意如果键无法进行哈希，则无法使用unordered_map或unordered_set（比如vector容器就没有hash方法，不能作为unordered_map或unordered_set的键）</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/happy-number/description/">202.快乐数</a>：使用哈希表空间复杂度为O(n)，将其视为快慢指针此时空间复杂度为O(1)</p>
</li>
<li>
<p>n数之和系列：给定n数之和</p>
<ul>
<li>
<p>给定一个数组，要求返回其中一个元组下标：哈希</p>
<ul>
<li><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></li>
</ul>
</li>
<li>
<p>给定一个数组，要求返回所有元组下标：先排序，外层遍历，内层左右指针向中移动，根据当前三数之和确定左指针还是右指针移动，同时注意跳过相同的数字</p>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a>：注意四数之和可能超过int的范围</p>
</li>
</ul>
</li>
<li>
<p>给定多个数组，要求返回元组的个数：哈希</p>
<ul>
<li><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>【原地哈希】</p>
<ul>
<li>
<p>例题：<a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/description/">LCR 120.寻找文件副本</a>：可能有多个重复数字，返回任意其一</p>
<ul>
<li>调整数组为<code>nums[i]==i</code>，如果将i写入到nums[i]时发现原来已经<code>nums[i]==i</code>，说明i就是重复数字</li>
<li>方法：<a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/submissions/494982727/">通过交换实现调整</a></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/description/">442.数组中重复的数据</a>：数字出现1或2次，返回所有出现两次的数字</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/description/">287.寻找重复数</a>：只有一个重复数，返回之；但是不能修改原数组</p>
<ul>
<li>Floyd判圈</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/missing-number/description/">268.丢失的数字</a>：只有一个缺失的数字，返回之</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/first-missing-positive/submissions/495038497">41.缺失的第一个正数 </a>：首先要判断数字是否在<code>[0,n]</code>的范围内</p>
<ul>
<li>
<p>方法一：标记</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">minNumberDisappeared</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// write code here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="nl">n</span><span class="p">:</span> <span class="n">nums</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 将数组中的元素都转换为正数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span> <span class="c1">// 如果位置j在数组内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">abs</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span> <span class="c1">// 将位置j的数值标记为负
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 找一个没有标记过的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>方法二：交换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">minNumberDisappeared</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// write code here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl">            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>总结：虽然原地哈希的核心部分都是判断当前位置j的元素<code>j=nums[i]</code>为索引时，是否已经写入<code>j?=nums[j]</code>，但是中间很多细节略微不同</p>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/">974.和可被K整除的子数组</a>：前缀和+哈希表</p>
<ul>
<li>前缀和实际上是前缀和的取模，使用哈希表记录模和其计数</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/integer-to-roman/description/">12.整数转罗马数字</a></p>
<ul>
<li>哈希表记录数字到字符串的映射，注意使用<code>map&lt;int, string, greater&lt;int&gt;&gt;</code>将key从大到小排列</li>
</ul>
</li>
</ul>
<h2 id="栈与队列二刷">栈与队列【二刷】</h2>
<ul>
<li>用栈模拟队列：一个输入栈，一个输出栈</li>
<li>用队列模拟栈：只需要一个队列，将元素进行循环弹入弹出</li>
<li>优先队列
<ul>
<li>注意优先队列如何自定义比较顺序</li>
</ul>
</li>
</ul>
<h3 id="栈">栈</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/basic-calculator-ii/description/">基本计算器Ⅱ</a>：遇到加减法入栈（即栈内都进行加法运算），有两种不太相同的写法：比如<code>a+b*c</code></p>
<ul>
<li>
<p>方法一：<a href="https://leetcode.cn/problems/basic-calculator-ii/submissions/497469850">暂存数字</a>。比如解析<code>+</code>时，暂存的是数字a，此时可以入栈；比如解析<code>*</code>时，暂存的是数字b（运算符前面的数字），此时先不能入栈，需要继续向后解析完c之后，更新暂存的数字</p>
</li>
<li>
<p>方法二：<a href="https://leetcode.cn/problems/basic-calculator-ii/submissions/497709896">暂存数字前的运算符</a>，更简洁。比如解析b时，当前暂存的运算符是<code>+</code>（数字前面的运算符），因此遇到新的运算符<code>*</code>时，根据需要出栈入栈</p>
<ul>
<li>技巧：将<code>a+b*c</code>处理成<code>a+b*c+0</code>，且开始时暂存的运算符是<code>+</code></li>
</ul>
</li>
<li>
<p>但是当表达式中含有括号时，可以递归，但是此时不太好在递归函数传入的表达式参数后面<code>+0</code>，具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">solve</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// s += &#34;+0&#34;; // 本来想在表达式末尾加上0，但是因为使用的使用，所以无法使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numSt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 相当于在表达式前面加上 0+
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">char</span> <span class="n">preSymbol</span> <span class="o">=</span> <span class="sc">&#39;+&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">idx</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// cout &lt;&lt; idx &lt;&lt; &#34; &#34; &lt;&lt; num &lt;&lt; endl;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">num</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">idx</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="err">&#39;</span><span class="p">)</span><span class="err">&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 此时这几个变量的顺序: numSt.top() preSymbol num s[idx]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span><span class="p">(</span><span class="n">preSymbol</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="n">numSt</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">preSymbol</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="n">numSt</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">-</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">preSymbol</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">numSt</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">numSt</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                    <span class="n">numSt</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span> <span class="o">*</span> <span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">preSymbol</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">preSymbol</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="n">numSt</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">preSymbol</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="n">numSt</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">-</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">preSymbol</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">numSt</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">numSt</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">numSt</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span> <span class="o">*</span> <span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">numSt</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">+=</span> <span class="n">numSt</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">numSt</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">make_pair</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/decode-string/">394.字符串解码</a>：【重要】</p>
<ul>
<li>方法一：【双栈】<a href="https://leetcode.cn/problems/decode-string/submissions/497922753">写法</a>，数字栈与string栈
<ul>
<li>字符串出栈时，每个元素需要先reverse，连起来字符串之后要再次reverse（因为出栈是逆序的，每个元素内部有时顺序的）</li>
<li>数字栈使用<code>stack&lt;int&gt;</code>，string栈使用<code>deque&lt;string&gt;</code>进行模拟，方便最后进行出栈</li>
</ul>
</li>
<li>方法二：<a href="https://leetcode.cn/problems/decode-string/submissions/497938583">递归写法</a>
<ul>
<li>全局的索引<code>idx</code>，函数传参<code>string</code>和重复数量<code>cnt</code></li>
<li>如果遇到<code>[</code>，则进入递归；如果遇到<code>]</code>，则退出递归</li>
<li>递归就是顺着累加字符串，不需要reverse</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/valid-parenthesis-string/description/">678.有效的括号字符串</a>：</p>
<ul>
<li>方法一：【双栈】
<ul>
<li>括号一个栈<code>st</code>，星号一个栈<code>star_st</code>，栈内存放下标</li>
<li>括号按照传统方法出入栈，星号直接入星号栈</li>
<li>在遍历完成之后，括号栈依次出栈，
<ul>
<li>如果当前是<code>(</code>，需要保证<code>star_st.top()</code>大于<code>(</code>的下标</li>
<li>如果当前是<code>)</code>，需要保证<code>star_st.top()</code>小于<code>)</code>的下标（极其注意需要当前<code>star_st.top()</code>可能大于<code>)</code>的下标，需要while依次出栈，与上面逻辑不同）</li>
</ul>
</li>
</ul>
</li>
<li>方法二：贪心
<ul>
<li>维护未匹配的<code>(</code>的数量可能的最大值和最小值，遇到星号时，最小值减一，最大值加一
<ul>
<li>如果最大值<code>&lt;0</code>，则字符串无效</li>
</ul>
</li>
<li>遍历完成后，只有最小值=0时，字符串才可能有效</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/min-stack/description/">最小栈</a>  <a href="https://leetcode.cn/problems/min-stack/solutions/42521/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-38/">参考</a></p>
<ul>
<li>方法一：【双栈】
<ul>
<li>一个普通栈，一个最小栈（用来记录最小值）</li>
<li>如果当前元素<code>==minStack.top()</code>，也要push/pop最小栈</li>
</ul>
</li>
<li>方法二：使用一个栈，并维护当前最小值<code>minVal</code>
<ul>
<li>入栈：如果当前元素<code>&lt;=minVal</code>，则先将minVal入栈，然后再将当前元素入栈，同时更新minVal的值；否则直接入栈</li>
<li>技巧：minVal初始值设定为最大值</li>
</ul>
</li>
<li>方法三：使用一个栈
<ul>
<li>每次入栈元素为<code>当前元素-minVal -&gt; st.top()</code>，如果结果是负数，说明minVal需要更新<code>minVal=当前元素</code></li>
<li>每次出栈或top，如果栈顶元素是正数，则<code>原来的元素=minVal+st.top()</code>；如果栈顶元素是负数，则说明当前minVal经过更新变得更小，<code>原来的元素=minVal</code>，复原原来的<code>minVal=原来的元素(即旧的minVal)-st.top()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="单调队列">单调队列</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<ul>
<li>
<p>方法一：大根堆，维护一个大根堆，里面存放数组索引，但是比较方法是按照对应元素大小进行比较，出队列时肯定是当前最大元素，而且可以判断该元素是否在窗口范围内</p>
<ul>
<li>最坏情况如果是一个递增序列，每次push都是<code>log(i)</code>的复杂度，总的复杂度为<code>sum(log(i))=O(n log(n))</code></li>
</ul>
</li>
<li>
<p>方法二：单调队列，维护一个<strong>递减的<code>deque</code></strong>，里面存放数组索引，从后面<code>pop_back</code>可以比较当前元素与队尾元素，保持队列递增；从前面<code>pop_front</code>可以保持元素位于窗口范围内</p>
<ul>
<li>最坏情况是<code>O(n)</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">maxInWindows</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// write code here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">len</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dq</span><span class="p">;</span> <span class="c1">// 滑动窗口，里面存放数组下标，对应的数组元素递减（队首元素对应数组元素最大）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">){</span> <span class="c1">// 注意遍历到滑动窗口大小-1的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">dq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">dq</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="n">dq</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">dq</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 每次遍历idx，对应的都是滑动窗口的末尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">,</span> <span class="o">++</span><span class="n">left</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">dq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dq</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">left</span><span class="p">)</span> <span class="n">dq</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="c1">// dq前面元素不在滑窗内了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">dq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">dq</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="n">dq</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="c1">// dq后面新加的元素更大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">dq</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">dq</span><span class="p">.</span><span class="n">front</span><span class="p">()]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="单调栈">单调栈</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a>：从左往右，找到第一个比当前元素大的元素</p>
</li>
<li>
<p>单调递增栈（从栈顶到栈底递增，栈顶元素为已经遍历过部分的最小值），如果当前元素nums[i]大于栈顶元素nums[top]，则从左往右nums[top]第一个比它大的元素是nums[i]</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a>：单调栈+哈希表</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a>：朴素想法是将循环数组展开，但是可以相同的单调栈代码跑两遍（第二遍继续使用第一遍剩下的单调栈）</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a>  【重要】</p>
</li>
<li>
<p>方法一：单调栈，从栈顶到栈底递增（反映到柱子上就是往下的台阶）</p>
<ul>
<li>
<p>横着接水：如果当前元素<code>height[i]</code>高于栈顶的柱子<code>H=height[st.top()]</code>，则栈顶的柱子<code>H</code>为最低高度，pop之后的栈顶为左边比H更高的位置，当前位置i为右边比H更高的位置，横着按层累加</p>
</li>
<li>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">trap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">height</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()];</span> <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()],</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">mid</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>方法二：双指针</p>
<ul>
<li>
<p>竖着接水：维护左右边历史最高柱子，往中间移动的过程中：</p>
<ul>
<li>如果右边低，当前水位最高只能按照低的来，<code>ans += rightHeight - height[right--]</code></li>
<li>左边同理</li>
</ul>
</li>
<li>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">trap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">leftHeight</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">rightHeight</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">leftHeight</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">leftHeight</span><span class="p">,</span> <span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">rightHeight</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">rightHeight</span><span class="p">,</span> <span class="n">height</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">leftHeight</span> <span class="o">&lt;=</span> <span class="n">rightHeight</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 左边低
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ans</span> <span class="o">+=</span> <span class="n">leftHeight</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">+=</span> <span class="n">rightHeight</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">right</span><span class="o">--</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>方法三：两个数组，分别从左向右和从右向左记录当前最高水位，也是竖着接水</p>
</li>
<li>
<p>类似题目：<a href="https://www.nowcoder.com/practice/3d8d6a8e516e4633a2244d2934e5aa47?tpId=295&amp;tqId=2284579&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj">盛水最多的容器</a></p>
<ul>
<li>这个题目使用双指针的方式</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形 </a> 【重要】</p>
</li>
<li>
<p>单调栈，从栈顶到栈底递减（反应到柱子上就是往上的台阶）</p>
<ul>
<li>找每个柱子左右两边第一个低于该柱子的位置：如果当前元素<code>height[i]</code>低于栈顶的柱子<code>H=height[st.top()]</code>，有：
<ul>
<li><code>i-1</code>位置的柱子一定不低于H</li>
<li>pop之后的栈顶位置+1一定不低于H（注意与接雨水的细微区别）</li>
<li>因此可以算面积</li>
</ul>
</li>
</ul>
</li>
<li>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
</li>
<li>
<p>技巧：在原来height数组开头<code>height.insert(heights.begin(), 0)</code>，在结尾<code>height.push_back(0)</code>，可以保证最后栈中无元素</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/maximal-rectangle/description/">85.最大矩形</a></p>
<ul>
<li>每行统计高度，因此每行跑一个<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形 </a></li>
<li>时间/空间复杂度均为O(mn)</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/remove-k-digits/">402. 移掉 K 位数字</a></p>
<ul>
<li>单调栈：从栈底到栈顶递增，同时维护栈的顺序和<code>k&gt;0</code></li>
</ul>
</li>
</ul>
<h3 id="优先队列">优先队列</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">347.前K个高频元素</a>：小根堆，遍历过程中逐步弹出堆顶，剩下的就是高频元素</p>
<ul>
<li>
<p>注意优先队列的写法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">cmp</span> <span class="o">=</span> <span class="p">[](</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">p2</span><span class="p">){</span><span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">second</span><span class="p">;};</span>
</span></span><span class="line"><span class="cl"><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">cmp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">pq</span><span class="p">(</span><span class="n">cmp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>手写堆</p>
</li>
<li>
<p>最小的k个元素/最小的第k个元素：维护一个最大堆，堆顶是当前最大元素（k个最小的元素中最大的一个）；如果新来的数比堆顶元素小，则弹出堆顶，新元素入堆</p>
</li>
<li>
<p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=295&amp;tqId=23457&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj">数据流中的中位数</a>：两个优先队列，前一半数组用最大堆，后一半数组用最小堆</p>
<ul>
<li>但是注意，为了保证后一半数组都大于前一半数组，新来的数需要先push到前面的最大堆中，然后再取top，放到后面的最小堆中</li>
<li>同时需要保证前面最大堆的大小&gt;=后面最小堆的大小</li>
</ul>
</li>
</ul>
<h2 id="二叉树二刷">二叉树【二刷】</h2>
<h3 id="遍历">遍历</h3>
<h4 id="dfs">DFS</h4>
<ul>
<li>
<p>递归写法：</p>
<ul>
<li>确定递归函数的参数和返回值</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ul>
</li>
<li>
<p>迭代写法：</p>
<ul>
<li>
<p>道理：当前arrive（或access）的节点，未必就是要add进数组的节点</p>
<ul>
<li>前序：第一次arrive的节点，就是add进数组的节点</li>
<li>中序：第二次arrive的节点，就是add进数组的节点</li>
</ul>
</li>
<li>
<p>前序：空节点不入栈</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">preorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">st</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">now</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>中序：使用now指向当前arrive的节点，now指向可以为空，此时出栈一个元素，now指向其右节点</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">st</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">now</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">now</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 比如中间-&gt;可能now指向空指针，此时stack不能为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//         -&gt;可能stack为空，但是now指向右节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 最后now指向某个节点的右空树，且stack都出栈已经为空，此时就是结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">            <span class="n">now</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">// st.top()是第二次访问，可以add进数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span> <span class="c1">// now != nullptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>后序：可以按照【根右左】的顺序遍历，然后reverse（即左右根）</p>
</li>
</ul>
</li>
</ul>
<h4 id="bfs">BFS</h4>
<p>迭代写法：注意是否要分层；如果不用分层，则不用计算每层的size，更简单一些</p>
<p>递归写法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">levelOrder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">vv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">vv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">vv</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">depth</span><span class="p">)</span> <span class="n">vv</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vv</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">bfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">bfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">199.二叉树的右视图</a>：注意递归的写法，将深度和当前数组的size比较</li>
</ul>
<h3 id="二叉树">二叉树</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222.完全二叉树的节点个数 </a> 【好题】</p>
<ul>
<li>如何判断满二叉树？向左递归深度==向右递归深度</li>
<li>完全二叉树中，某个节点左子树和右子树中，至少有一个是满二叉树，<a href="https://leetcode.cn/problems/count-complete-tree-nodes/solutions/2076036/labuladong-ru-he-ji-suan-wan-quan-er-cha-f55d/">参考</a></li>
<li>复杂度分析：
<ul>
<li>每次递归需要计算当前节点的高度，O(log n)</li>
<li>最多需要调用“树的高度”次，O(log n)</li>
<li>相乘，O(log n) * O(log n)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://www.programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D">110.平衡二叉树</a></p>
<ul>
<li>注意二叉树节点【深度】和【高度】的差异
<ul>
<li>高度：该节点到叶子节点的最长，求高度适合用前序遍历</li>
<li>深度：根节点到该节点的路径，求深度适合用后序遍历</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://www.programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E6%80%9D%E8%B7%AF">112.路径总和</a></p>
<ul>
<li>注意分辨递归什么时候有返回值
<ul>
<li>不用完整搜索整棵二叉树，找到其中一条路径即可，需要返回值（比如本题），比如if判断当前节点后直接返回。或者说<strong>遍历</strong>的思维</li>
<li>需要完整搜索整棵二叉树，或者说二叉树与回溯的结合
<ul>
<li>需要返回值（比如递归求深度）</li>
<li>不需要返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">124.二叉树中的最大路径和 </a> 【好题】，【不会】</p>
<ul>
<li><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/submissions/493249101/">递归写法</a></li>
</ul>
</li>
<li>
<p><a href="https://www.programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236.二叉树的最近公共祖先</a> 【好题】</p>
<ul>
<li>递归方法：
<ul>
<li>后序遍历：分别在左右子树中找p和q的最近公共祖先，然后根据找到的情况进行处理
<ul>
<li>如果子树递归返回nullptr，说明子树不包含p或者q</li>
<li>如果子树递归返回非nullptr，说明子树包含p、或q、或pq</li>
</ul>
</li>
<li>理解返回值：返回值是以root为根的子树中，p或q的最近公共祖先，如果该子树不包含p或者q，则返回nullptr
<ul>
<li>如果<code>root==p || root==q</code>，则当前root至少为一个节点祖先，另一个节点可能在这个子树上，也可能不在这个子树上，但至少返回root</li>
<li>如果当前root为根的子树，没有p或者q（左右子树都是nullptr），只能返回nullptr</li>
<li>如果当前root为根的子树，左右子树分别有p和q，则root为最近公共祖先，返回root</li>
<li>如果当前root为根的左子树或右子树其中一个，同时有p和q，则只能将其最近公共祖先向上返回</li>
</ul>
</li>
</ul>
</li>
<li>迭代方法：使用map记录子节点到父节点的映射，再使用一个map记录p到root的路径，最后q向上回到root过程中找到最近同时访问的节点</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543.二叉树的直径</a></p>
<ul>
<li>维护一个计算每个节点最大深度的递归函数deepest</li>
<li>在计算节点左右子树的过程中，更新树的直径</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/description/">662.二叉树最大宽度</a>：中间nullptr也算</p>
<ul>
<li><code>pair&lt;TreeNode*, unsigned long long&gt;</code>保存节点和其id，×2得到其左节点id，×2+1得到其右节点id，最后id相减</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">116.填充每个节点的下一个右侧节点指针</a></p>
<ul>
<li>常规方法：使用队列进行迭代</li>
<li>递归方法：递归函数中传入两个节点指针</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/description/">671.二叉树中第二小的节点</a>：root是最小的，遍历一遍，比root大的其中最小的</p>
</li>
<li>
<p>区分<a href="https://leetcode.cn/problems/subtree-of-another-tree/">572.另一棵树的子树</a> 和 <a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/description/">LCR 143.子结构判断</a>(这个题目关于空节点本身没有说清楚)</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/description/">863.二叉树中所有距离为K的结点</a></p>
<ul>
<li>遍历一遍得到子节点到父节点的map，从而变树为图，然后dfs</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/description/">297.二叉树的序列化与反序列化</a> 【好题】</p>
<ul>
<li>第一种方法：使用括号表示编码（BNF编码）进行序列化，使用递归函数进行反序列化，<a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/submissions/494473198">代码</a>
<ul>
<li>BNF编码：比如postOrder BNF编码<code>(左)(右)(根)</code></li>
<li>反序列化时，递归函数中需要使用栈，从而确定左右子树在字符串中的范围</li>
</ul>
</li>
<li>第二种方法：使用逗号表示编码按照层序遍历进行序列化，使用迭代方法进行反序列化，<a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/submissions/494466348">代码</a>
<ul>
<li>序列化方式与leetcode样例给出方式相同，不需要特殊表示换层</li>
<li>反序列化同样使用队列，字符串遍历的过程中入栈出栈</li>
</ul>
</li>
<li>第三种方法：使用逗号表示编码进行序列化，使用递归函数进行反序列化，<a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/submissions/494514519">代码</a>
<ul>
<li>序列化表示形式与第二种方法相同，但是好像只能使用前序遍历
<ul>
<li>如果使用中序/后序，字符串中第一个元素解码后是nullptr，在反序列化的递归函数中第一个元素就直接返回，不会处理后面的字符串了</li>
<li>如果使用前序，字符串中第一个元素肯定不为nullptr，可以递归下去</li>
</ul>
</li>
<li>反序列化过程需要维护一个全局的索引，从而在不同的递归函数之间确定当前处理的元素的位置</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/find-duplicate-subtrees/description/">652.寻找重复的子树</a></p>
<ul>
<li>使用基于后序遍历的二叉树序列化，模板类似<a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/description/">297.二叉树的序列化与反序列化</a>中第一种方法，但是序列化格式可以简化</li>
<li>在后序遍历进行序列化的过程中，同时维护<code>unordered_map&lt;string, pair&lt;TreeNode*, int&gt;&gt;</code>的映射</li>
</ul>
</li>
</ul>
<h3 id="二叉搜索树">二叉搜索树</h3>
<ul>
<li>
<p><a href="https://www.programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95">98.验证二叉搜索树</a> <a href="https://www.programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">530.二叉搜索树中的最小绝对差 </a> <a href="https://www.programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html#%E9%80%92%E5%BD%92%E6%B3%95">501.二叉搜索树中的众数</a></p>
<ul>
<li>原理：二叉搜索树中序遍历是有序的
<ul>
<li>可以是递归写法：维护一个全局变量，记录上一个节点的指针pre</li>
<li>可以是迭代写法：中序迭代写法</li>
</ul>
</li>
<li><a href="https://www.programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95">98.验证二叉搜索树</a>极易想成简单左右子树判断，但此时根节点和右子树的左孩子的关系是无法判断的，只能中序遍历判断有序</li>
</ul>
</li>
<li>
<p><a href="https://www.programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E9%80%92%E5%BD%92">450.删除二叉搜索树中的节点</a> 【好题】</p>
<ul>
<li>对比递归方法与迭代方法：都是五种情况
<ul>
<li>迭代方法：小心删除根节点时的特判</li>
<li><a href="https://www.programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E9%80%92%E5%BD%92">递归方法</a>：使用root-&gt;left或root-&gt;right接受返回值，避免记录pre节点（同时也避免了删除根节点时pre==nullptr的判断）</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/description/">LCR 174.二叉搜索树的第k大节点</a></p>
<ul>
<li>中序倒序，维护全局变量的计数器</li>
</ul>
</li>
<li>
<p><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;&amp;tqId=11179&amp;qru=/ta/coding-interviews/question-ranking">426.将二叉搜索树转换为有序的双向链表</a></p>
<ul>
<li>递归函数返回有序双向链表的头</li>
</ul>
</li>
<li>
<p><a href="http://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/description/">LCR 152.验证二叉搜索树的后序遍历序列</a></p>
<ul>
<li>注意是二叉搜索树，因此可以确定根与左右子树，从而递归判断</li>
<li>第二种方法：单调栈+后序逆序，<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/submissions/494227458/">代码</a>，<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solutions/150225/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/">参考</a>，不太会
<ul>
<li>比如当前是根节点（栈顶）</li>
<li>如果下一个节点大于栈顶元素，则在右侧，因此入栈</li>
<li>如果下一个节点小于栈顶元素，则出栈（该节点在其祖先节点的右边），找到其祖先节点，后序节点应该都在该祖先节点的左边</li>
<li>假设有一个极大的虚拟根节点，整棵树都在其左边</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/recover-binary-search-tree/description/">99.恢复二叉搜索树</a></p>
<ul>
<li>遍历过程中，记录这两个节点，<a href="https://leetcode.cn/problems/recover-binary-search-tree/solutions/1429782/by-richard-az-j904">参考</a></li>
</ul>
</li>
</ul>
<h3 id="综合-1">综合</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/path-sum-iii/description/">437.路径总和Ⅲ</a> 【好题】，【二叉树】+【前缀和】+【回溯】</p>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/path-sum-iii/submissions/494355245">递归方法</a>：以每个节点为root（O(n)），再计算包含root时的路径数量（O(n)），复杂度O(n^2)</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/path-sum-iii/submissions/494373044">前缀和</a>：在前序遍历的过程中，记录当前节点的前缀和，并遍历过的节点的前缀和保存到map中（value是特定前缀和的个数）</p>
<ul>
<li>根据当前前缀和和root-&gt;val，可以得到当前分支上符合要求的路径的个数</li>
<li>当当前root返回时，当前的前缀和也需要从map中复原</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="回溯">回溯</h2>
<ul>
<li>
<p>回溯</p>
<ul>
<li>
<p>思路：二叉树/多叉树的递归遍历</p>
<ul>
<li>视为二叉树的话，每个元素选择或不选，每个dfs中有两条路径</li>
<li>视为多叉树的话，在每个for循环中进行选择，注意选择之后的回溯复原就表示没有选择当前元素，然后可以选择后面的元素</li>
</ul>
</li>
<li>
<p>写法：数组直接作为全局变量，进行多叉树的遍历时使用一个<code>startIdx</code>来表示当前搜索数组的位置</p>
</li>
<li>
<p>细节问题：</p>
<ul>
<li>使用startIdx还是从0开始</li>
<li>能否对数组排序？
<ul>
<li>能，如果需要去重，维护一个全局的used数组
<ul>
<li>used数组的索引，表示nums的下标（一般是这个，比如有重复元素时，使用<code>str[i]==str[i-1 &amp;&amp; isVisit[i-1]</code>来判断），还是nums元素的值</li>
</ul>
</li>
<li>不能，如果需要去重，则每一层应该维护一个局部的set</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>组合问题：从N个数中选k个数，有几种选法</p>
<ul>
<li><a href="https://leetcode.cn/problems/combinations/description/">77.组合</a>：模板题</li>
<li><a href="https://leetcode.cn/problems/combination-sum-iii/">216.组合总数Ⅲ</a>：直接在for循环中进行剪枝</li>
<li><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17.电话号码的字母组合</a>：使用字符串数组（或者二维数组）来进行数字到字符串的对应</li>
<li><a href="https://leetcode.cn/problems/combination-sum/">39.组合总和</a>：</li>
<li><a href="https://leetcode.cn/problems/combination-sum-ii/description/">40.组合总和Ⅱ</a>：使用<code>used</code>数组进行去重，初始化used=false：
<ul>
<li>当数组中相邻两个元素相等且used=true时，表示这两个元素在同一个树枝上（在一个分支上），此时不用去重（即组合内部使用了相同的元素）</li>
<li>当数组中相邻两个元素相等且user=false时，表示这两个元素在递归的同一层（同一树层上），此时表示后面会有相同的组合出现，因此需要去重（continue）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>切割问题：一个字符串不同切割方式，有几种方式</p>
<ul>
<li><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131.分割回文串</a>：逐个分割每个元素进行判断，同样是递归的树形结构</li>
<li><a href="https://leetcode.cn/problems/restore-ip-addresses/description/">93.复原IP地址</a>：感觉写成三叉树的递归方式，而非是for循环的递归方式更直观和易于理解
<ul>
<li>三叉树方式：从当前位置开始的子串，分别作为一个字符、两个字符、三个字符进行匹配</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子集问题：N个数中相关子集的个数</p>
<ul>
<li><a href="https://leetcode.cn/problems/subsets/description/">78.子集</a>：递归的树形结构的所有节点</li>
<li><a href="https://leetcode.cn/problems/subsets-ii/">90.子集Ⅱ</a>：理解“树枝去重”与“树层去重”的逻辑，对于相同的数字，前面的可以选或不选，后面的必须不能选</li>
<li><a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491.递增子序列</a>：同样需要去重，但不能使用全局的used数组来去重
<ul>
<li>90.子集Ⅱ中数组是有序的，可以保证相同的数字都是挨着的，</li>
<li>491.递增子序列中数组无序，如果按上面的方式，只能保证相同的连着的数字是去重的，相同的不挨着的数字会重复，因此只能每一层维护一个局部的used数组，动态判断该数字之前是否出现过</li>
</ul>
</li>
</ul>
</li>
<li>
<p>排列问题：N个数的不同排列方式</p>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/permutations/description/">46.全排列</a>：</p>
<ul>
<li>方法一：使用used数组记录该数字是否使用过，仔细考虑for循环和回溯（回退）的过程</li>
<li>方法二：使用swap和startIdx，每次减小排列的规模</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/permutations-ii/">47.全排列Ⅱ</a>：对比491.递增子序列</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/reconstruct-itinerary/description/">332.重新安排行程</a>：</p>
<ul>
<li>错误理解和写法：每个机场只到一次（因此使用一个数组记录该节点是否到过）</li>
<li>正确理解：所有路径都走且只走一次（可能比如北京到上海有好几张票，都要使用，因此使用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt;</code>来进行建图，然后dfs,回溯更新int的值）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>棋盘问题：</p>
<ul>
<li><a href="https://leetcode.cn/problems/n-queens/description/">51.N皇后</a>：画出搜索的树形结构，dfs中逐层放置皇后</li>
<li><a href="https://leetcode.cn/problems/sudoku-solver/description/">37.解数独</a>：
<ul>
<li>二维的递归，注意最外层for循环的是数组/棋盘，而不是各种可能性或组合（即选或不选）</li>
<li>判断合法性时，只是判断当前元素是否行、列、方格重复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="贪心">贪心</h2>
<h3 id="区间贪心">区间贪心</h3>
<ul>
<li><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a>：维护一个当前可以跳跃到的最右边界</li>
<li><a href="https://leetcode.cn/problems/jump-game-ii/">45.跳跃游戏Ⅱ</a></li>
<li><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435.无重叠区域</a>
<ul>
<li>当有重叠区域时，更新右端点<code>right = min(right, v[1]);</code>的含义：如果重叠，使得右端点最小
<ul>
<li>如果旧的right更小，则移除掉新来的区间</li>
<li>如果新来的区间<code>v[1]</code>更小，则移除原来的区间</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">452.用最少数量的箭引爆气球 </a> 对比<a href="https://leetcode.cn/problems/non-overlapping-intervals/">435.无重叠区域</a>
<ul>
<li>按照每个点的start进行排序，当前重叠范围为<code>[start, right]</code>，start递增，维护逐渐缩小的重叠区间<code>right = min(right, points[i][1])</code></li>
</ul>
</li>
<li><a href="https://www.nowcoder.com/practice/4edf6e6d01554870a12f218c94e8a299?tpId=295&amp;tqId=1267319&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj">主持人调度（二）</a>：排序+最小堆
<ul>
<li>按开始时间、结束时间先排序区间</li>
<li>使用最小堆保存当前正在进行的所有活动的结束时间，堆顶是最早的结束时间
<ul>
<li>因此，如果新来的某次活动，开始时间小于堆顶的最早结束时间，则这个活动可以连起来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="两个维度贪心">两个维度贪心</h3>
<ul>
<li><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406.根据身高重建队列</a>：先从高到低排队，再插队，复杂度O(n^2)</li>
</ul>
<h3 id="上下坡">上下坡</h3>
<ul>
<li><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">376.摆动序列</a>
<ul>
<li>方法一：<a href="https://leetcode.cn/problems/wiggle-subsequence/submissions/498171028">贪心</a>，也就是统计一共有几次变化</li>
<li>方法二：<a href="https://leetcode.cn/problems/wiggle-subsequence/submissions/498176392">带空间优化的动规</a>，<code>up[i], down[i]</code>为以<code>nums[i]</code>为结尾（最后一个是上升或下降）的摆动序列长度</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/candy/description/">135.分发糖果</a>：正着统计上坡，反着统计上坡</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122.买卖股票的最佳时机Ⅱ</a>：直接累加上坡的差值</li>
<li><a href="https://leetcode.cn/problems/gas-station/description/">134.加油站</a>：找剩余油量的前缀和中最小的位置</li>
</ul>
<h2 id="动态规划">动态规划</h2>
<h3 id="总结">总结</h3>
<p>动规五部曲：</p>
<ul>
<li>确定dp数组的含义和下标的含义</li>
<li>确定递推公式</li>
<li>确定dp数组的初始化</li>
<li>确定遍历顺序</li>
<li>举个例子</li>
</ul>
<h3 id="单纯动规">单纯动规</h3>
<h4 id="直接寻找使用最优子结构">直接寻找/使用最优子结构</h4>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/interleaving-string/description/?show=1">97.交错字符串</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/decode-ways/description/?show=1">91.解码方法</a></p>
<ul>
<li>最优子结构好找（相当于递推），只是中间判断有点多</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/word-break/description/">139.单词拆分</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/coin-change/description/">322.零钱兑换</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/integer-break/description/">343.整数拆分</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/maximal-square/description/">221.最大正方形</a></p>
<ul>
<li>子结构需要从三个方向考虑</li>
<li>使用滚动数组优化，注意有斜向上的依赖，需要使用一个变量记录</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/out-of-boundary-paths/description/?show=1">576.出界的路径数</a>：题目一般，就像递推</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/minimum-falling-path-sum/description/">931.下降路径最小和</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/triangle/description/">120.三角形最小路径和</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/?show=1">剑指 Offer 47. 礼物的最大价值 </a>同 <a href="https://leetcode.cn/problems/minimum-path-sum/description/">64.最小路径和</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/JEj789/description/?show=1">剑指Ⅱ 091.粉刷房子</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/dungeon-game/description/">174.地下城游戏</a></p>
<ul>
<li>从右下到左上的动规</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/binary-trees-with-factors/description/">823.带因子的二叉树</a></p>
</li>
<li></li>
</ul>
<h4 id="01背包">01背包</h4>
<ul>
<li><a href="https://leetcode.cn/problems/target-sum/description/">494.目标和</a>：要装满背包，有几种方法
<ul>
<li>注意，0可以特殊处理，也可以不用特殊处理</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416.分割等和子集</a>： 给定背包容量，能不能装满这个背包
<ul>
<li>方法一：dp[j]就表示背包容量为j时，能否将背包装满</li>
<li>方法二：视为标准01背包，物品价值和重量相等，最后看容量为j的背包里最大价值
<ul>
<li><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049.最后一块石头的重量Ⅱ</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049.最后一块石头的重量Ⅱ</a>：
<ul>
<li>首先转换成标准01背包：分成两堆石头，一堆小，一堆大，让小的那堆尽量接近一半</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/ones-and-zeroes/description/">474.一和零</a>：给定背包容量，装满背包最多有多少个物品
<ul>
<li>注意背包是二维的（长对应0的数量，宽对应1的数量）</li>
</ul>
</li>
</ul>
<h4 id="排列数与组合数">排列数与组合数</h4>
<ul>
<li><a href="https://leetcode.cn/problems/combination-sum-iv/">377.组合总和Ⅳ</a>：算组合数</li>
<li><a href="https://leetcode.cn/problems/climbing-stairs/">22.爬楼梯</a>：进阶版爬楼梯（每次可以爬[1 - m]个台阶）其实是一个完全背包下计算组合数的问题
<ul>
<li><a href="https://www.programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html#%E6%80%9D%E8%B7%AF">参考</a></li>
</ul>
</li>
</ul>
<h4 id="打家劫舍系列">打家劫舍系列</h4>
<ul>
<li><a href="https://leetcode.cn/problems/house-robber/description/">198.打家劫舍</a>：
<ul>
<li>不要硬套01背包，01背包只是动规中很套路的一个模板；除了直接题目可以直接套模板，剩下的还是要具体分析出来递推公式</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/house-robber-ii/">213.打家劫舍Ⅱ</a>
<ul>
<li>拆环为链，拆分成两种情况，各跑一遍</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/house-robber-iii/">337.打家劫舍Ⅲ</a>：<a href="https://www.programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html#%E6%80%9D%E8%B7%AF">树形DP</a>
<ul>
<li>每个节点有一个状态数组</li>
<li>在后序遍历中，得到左右子树的状态，更新当前节点的状态</li>
</ul>
</li>
</ul>
<h4 id="买卖股票的最佳时机系列">买卖股票的最佳时机系列</h4>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121.买卖股票的最佳时机</a></p>
<ul>
<li>dp数组表示持有/不持有股票，第0天持有即买入</li>
<li><strong>划分状态</strong>
<ul>
<li>首先为什么标准01背包不需要针对每个背包的容量分成两种状态的数组？
<ul>
<li>动规原理是最优子结构，标准01背包中物品之间是相互独立的，不存在某件放入a物品后必须放入b物品这样的关联</li>
</ul>
</li>
<li>其次为什么打家劫舍问题也不需要针对每一间房屋分成两种状态的数组？
<ul>
<li>首先可以分，而且公式写出来也很清晰，在比如树形DP中还必须要分</li>
<li>但是打家劫舍中，只是相邻两个房屋之间有关联，公式中可以直接将关联表示出来</li>
</ul>
</li>
<li>买卖股票中为什么必须要分成两种状态的数组？
<ul>
<li>因为买卖股票的两天之间的关联不是固定的</li>
<li>买卖股票中还需要注意两种状态的定义：是持有/不持有，而非买入/卖出</li>
</ul>
</li>
<li>什么是状态？
<ul>
<li>第i天进行第j笔交易，是持有还是不持有</li>
</ul>
</li>
</ul>
</li>
<li>注意如何保证只买入一次？区别<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机Ⅱ</a></li>
<li>加上手续费相同<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714.买卖股票的最佳时机含手续费</a></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机Ⅱ</a></p>
</li>
<li>
<p><a href="https://www.programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html#%E6%80%9D%E8%B7%AF">123.买卖股票的最佳时机Ⅲ</a></p>
<ul>
<li>
<p>每天有多种状态：第i天进行第j笔交易，是持有还是不持有</p>
</li>
<li>
<p>有一个技巧可以将空间复杂度降到O(1)，<a href="https://www.programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html#%E6%8B%93%E5%B1%95">参考</a></p>
<img src="https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-09-07-15:54:21.png" alt="QQ图片20230907155407" style="zoom:80%;" />
</li>
<li>
<p><a href="https://www.programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html#%E6%80%9D%E8%B7%AF">188.买卖股票的最佳时机Ⅳ</a> 同理</p>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309.最佳买卖股票时机含冷冻期</a></p>
<ul>
<li>细化状态（比如不持有股票可以细分为今天卖出还是维持原来不持有的状态）</li>
<li>画出状态转移图</li>
</ul>
</li>
</ul>
<h4 id="序列问题">序列问题</h4>
<h5 id="递增序列数组">递增序列/数组</h5>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列  </a>LIS</p>
<ul>
<li>
<p>更像是记忆化搜索或者递推，而非动规</p>
</li>
<li>
<p>对比<a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674.最长连续递增序列</a>（或者可称为最长递增数组？），是否连续决定是否内部要使用一个for循环找到比当前元素小的位置</p>
</li>
<li>
<p>可以使用贪心+二分实现更低的复杂度</p>
<ul>
<li>
<p>贪心：d[len]表示长度为len的LIS，末尾元素的最小值，最小值越小越好</p>
</li>
<li>
<p>二分：d[]数组单调递增</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// d[len]:长度为len的LIS，末尾元素的最小值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">len</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span><span class="p">[</span><span class="o">++</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 二分查找：find max l, nums[i] &gt; d[l]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因此d[l+1]找到一个更小的末尾元素nums[i]：d[l+1]&gt;nums[i]&gt;d[l]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">len</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/147667/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">参考</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/description/">673.最长递增子序列的个数</a></p>
<ul>
<li>使用贪心+树状数组实现O(nlogn)的复杂度，<a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/solutions/1007341/gong-shui-san-xie-lis-de-fang-an-shu-wen-obuz/">参考</a></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/russian-doll-envelopes/description/">354.俄罗斯套娃信封问题</a></p>
<ul>
<li>先排序，w正排，h倒排（保证相同w时，大h不能包含小h）</li>
<li>通过排序将二维LIS转换为一维的LIS</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/largest-divisible-subset/description/">368.最大整除子集</a></p>
<ul>
<li>与LIS方法差不多</li>
</ul>
</li>
</ul>
<h5 id="重复数组公共序列子数组序列问题">重复数组、公共序列、子数组/序列问题</h5>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718.最长重复子数组</a></p>
<ul>
<li>使用滚动数组进行优化：<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">代码</a>
<ul>
<li>内层逆序：之所以逆序，一是因为不将物品重复放入，二是因为可能依赖是斜向上的，逆序可以直接访问未更新之前的数值</li>
<li>也可以使用顺序，不过要将原来未更新之间的数值记录下来</li>
</ul>
</li>
<li>其实是这个题目对遍历顺序没有要求，因为if中dp依赖左上旧值，else中dp直接是0
<ul>
<li>其他题目中，else中可能需要用到刚才更新过的值，因此只能从前向后遍历</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143.最长公共子序列 </a> 和 <a href="https://leetcode.cn/problems/uncrossed-lines/description/">1035.不相交的线</a></p>
<ul>
<li>使用滚动数组进行优化：使用两个数组来回调替，或者直接记录依赖的旧值</li>
<li>极其注意如果使用一维数组优化，同时使用pre来记录斜上角的值时，此时<code>tmp=dp[j]</code>还是<code>tmp=dp[j+1]</code>，tmp保存的是当前dp要被覆盖的值</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/maximum-subarray/description/">53.最大子数组和</a></p>
<ul>
<li>遇到数组和第一直觉总是前缀和，但是这个题目使用动规很简单</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/is-subsequence/description/">392.判断子序列</a></p>
<ul>
<li>可以使用双指针</li>
<li>使用动规：状态转移方程很类似
<ul>
<li>dp可以表示相同序列的长度</li>
<li>dp也可以是bool数组，表示s[0, i]是否为t[0, j]的子序列
<ul>
<li>使用滚动数组优化二维数组时，注意将初始化方式从原来的二维情况下转换到一维情况下，比如当i=0时容易记起初始化，但是i=1,2,3&hellip;之后，dp[0]或者dp数组开头几个数字就容易忘记初始化，<a href="https://leetcode.cn/problems/is-subsequence/submissions/464079888/">代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/distinct-subsequences/description/">115.不同的子序列</a></p>
<ul>
<li>代码模板是<a href="https://leetcode.cn/problems/is-subsequence/description/">392.判断子序列</a>，只是递推公式需要多考虑一下</li>
</ul>
</li>
</ul>
<h5 id="字符串操作">字符串操作</h5>
<ul>
<li><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">583.两个字符串的删除操作</a>
<ul>
<li>动规方式1：先求出最长公共子序列，再相减</li>
<li>动规方式2：dp直接表示删除的最小步数，逻辑相同
<ul>
<li>注意原来使用二维数组时，有一定初始化方式；使用一维数组进行优化时，dp[0]很容易忘记初始化，<a href="https://leetcode.cn/problems/delete-operation-for-two-strings/submissions/">代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/">712.两个字符串的最小ASCII删除和</a></li>
<li><a href="https://leetcode.cn/problems/edit-distance/">72.编辑距离</a>
<ul>
<li>当word1[i]与word2[j]不相同时，如果进行插入和删除，只需要考虑将word1[i]当前字符插入或删除</li>
</ul>
</li>
<li><a href="https://www.nowcoder.com/practice/05fed41805ae4394ab6607d0d745c8e4?tpId=117&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1&amp;tab=answerKey">牛客NC35 编辑距离二</a>
<ul>
<li>有O(nlogn)的算法吗？？？</li>
</ul>
</li>
</ul>
<h5 id="回文相关">回文相关</h5>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/palindromic-substrings/">647.回文子串</a>：【好题】，<a href="https://www.programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95">分析</a></p>
<ul>
<li>i倒着遍历，j顺着遍历</li>
<li>有<strong>时dp数组的含义并不是直接求什么，定义什么</strong>
<ul>
<li>如果$dp[i][j]$表示$s[i:j]$内的回文子串的数量，当s[i]==s[j]时，此时无法判断$s[i+1:j-1]$是否为回文串，由此无法确定递推公式中是否要+1，<a href="https://leetcode.cn/problems/palindromic-substrings/submissions/465238949/">错误代码</a></li>
<li>$dp[i][j]$表示$s[i:j]$是否为回文串，在递推公式之后根据true or false进行累加，<a href="https://leetcode.cn/problems/palindromic-substrings/submissions/443143742/">正确代码</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5.最长回文子串</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516.最长回文子序列</a></p>
<ul>
<li><strong>注意看是子序列（不必连续）还是子串（必须连续）</strong></li>
<li>这个回文动规中，dp的含义，就是求什么定义什么</li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/">1312.让字符串成为回文串的最少插入次数</a></p>
</li>
</ul>
<h4 id="其他">其他</h4>
<ul>
<li><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152.乘积最大子数组</a>：【好题】，也是分状态，但是其中另一个状态隐含在题目中，需要分析，很巧</li>
</ul>
<h4 id="第一次几乎完全不会">第一次几乎完全不会</h4>
<ul>
<li><a href="https://leetcode.cn/problems/longest-valid-parentheses/description/">32.最长有效括号</a></li>
</ul>
<h3 id="动规单调队列">动规+单调队列</h3>
<ul>
<li><a href="https://leetcode.cn/problems/jump-game-vi/description/">1696.跳跃游戏</a>： 模板题</li>
<li><a href="https://leetcode.cn/problems/constrained-subsequence-sum/description/">14253带限制的子序列和</a>：【好题】
<ul>
<li>比1696在动规上多了一点</li>
</ul>
</li>
</ul>
<h2 id="图论">图论</h2>
<h3 id="dfs与bfs">DFS与BFS</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">797.所有可能的路径</a>：DFS+回溯</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/number-of-islands/description/">200.岛屿数量</a>：DFS，BFS模板题</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/number-of-enclaves/">1020.飞地的数量</a>：第一阶段原地修改原来的二维数组标记，第二阶段再次遍历</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/surrounded-regions/description/">130.被围绕的区域</a>：原地修改二维数组标记</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/making-a-large-island/description/">827.最大人工岛</a>：保存中间计算结果（岛屿面积），避免重复计算</p>
<ul>
<li>首先遍历，每个岛屿进行编号，同时使用map记录id到岛屿面积的映射</li>
<li>对于水块，上下左右累加岛屿面积</li>
</ul>
</li>
<li>
<p><a href="">127.单词接龙</a>：</p>
<blockquote>
<p>单词个数n，单词长度m</p>
</blockquote>
<ul>
<li>方法一：BFS内部，对单词进行遍历，找到相邻的单词，最坏情况复杂度O(nnm)</li>
<li>方法二：BSF内部，对当前单词逐字母进行替换，判断替换后的单词是否在词表中，复杂度O(26*n)</li>
</ul>
</li>
<li>
<p><a href="https://www.nowcoder.com/practice/7a71a88cdf294ce6bdf54c899be967a2?tpId=295&amp;tqId=1076860&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295">BM61 矩阵最长递增路径 </a>  DFS+动规</p>
<ul>
<li>
<p>DFS的模板，动规的公式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 从(x,y)到(xx,yy)递增
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">inBound</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mat</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="p">[</span><span class="n">xx</span><span class="p">][</span><span class="n">yy</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">    <span class="n">dfs</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">);</span> <span class="c1">// DFS计算dp[xx][yy]的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">xx</span><span class="p">][</span><span class="n">yy</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="并查集">并查集</h3>
<ul>
<li>
<p>并查集：一个用数组表示的森林</p>
<ul>
<li>当存在u-&gt;v的有向边时，添加到并查集：<code>father[v] = u; // v的father是u</code></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/find-if-path-exists-in-graph/">1971.寻找图中是否存在路径</a>：模板题</p>
</li>
<li></li>
</ul>
<h2 id="数学">数学</h2>
<h3 id="模拟-1">模拟</h3>
<ul>
<li><a href="https://leetcode.cn/problems/palindrome-number/description/">9.回文数</a>：
<ul>
<li>空间复杂度<code>O(1)</code>的方法：原来数字取模除十的过程中，与反转后的数组比较大小</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/factorial-trailing-zeroes/description/">172.阶乘后的零</a>：实际上就是找因子5的个数</li>
</ul>
<h3 id="位运算">位运算</h3>
<ul>
<li>
<p>常用技巧：对于<code>int n</code></p>
<ul>
<li>获取n的最低位的1：<code>n &amp; (-n)</code></li>
<li>将n的最低位1变为0：<code>n &amp; (n-1)</code></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/number-of-1-bits/description/">191.位1的个数</a>：</p>
<ul>
<li>循环检查二进制位：<code>if(n &amp; (1 &lt;&lt; i)) ++cnt</code></li>
<li>lsb翻转：<code>n &amp; (n-1)</code>结果为将n的二进制lsb变为0，因此：<code>while(n) {n &amp;= (n-1); ++cnt;}</code></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/single-number/description/">136.只出现一次的数字</a>：数组异或，原理是异或具有交换律</p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/single-number-ii/description/">137.只出现一次的数字Ⅱ</a>：</p>
<ul>
<li>对于32位int，统计每一个bit中1的个数cnt，如果cnt无法整除3，则只出现一次的数字在当前bit为1，<code>ans |= (1 &lt;&lt; i)</code></li>
</ul>
</li>
<li>
<p><a href="https://leetcode.cn/problems/single-number-iii/description/">260.只出现一次的数字Ⅲ</a>：分组异或</p>
<ul>
<li>
<p><code>xorsum</code>一定不为0，否则所有数字都出现两次，假设两个出现一次的数字为a和b</p>
</li>
<li>
<p><code>xorsum</code>的最低有效位lsb，则一定是a的lsb=1，b的lsb=0（或反过来）</p>
<ul>
<li>为什么要取最低有效位？为了实现分组，a和b在最低有效位不同，</li>
</ul>
</li>
<li>
<p>出现两次的数字，其lsb一定相同；因此根据这个lsb可以将所有数字分成两类，分别进行异或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">FindNumsAppearOnce</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// write code here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">xorsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">n</span><span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="n">xorsum</span> <span class="o">^=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">lsb</span> <span class="o">=</span> <span class="n">xorsum</span> <span class="o">==</span> <span class="n">INT_MIN</span> <span class="o">?</span> <span class="nl">xorsum</span> <span class="p">:</span> <span class="n">xorsum</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="n">xorsum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">n</span><span class="p">:</span> <span class="n">nums</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">lsb</span><span class="p">)</span> <span class="n">a</span> <span class="o">^=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="n">b</span> <span class="o">^=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="其他-1">其他</h3>
<ul>
<li>快速幂</li>
<li><a href="https://leetcode.cn/problems/implement-rand10-using-rand7/description/">470.用Rand7()实现Rand10()</a>：拒绝采样
<ul>
<li>注意不能直接使用<code>rand7() * rand7()</code>，因为其中元素概率不完全相同，比如14的概率是2/49，1的概率是1/49，6的概率是4/49</li>
<li>视为行列索引：<code>row=rand7(); col=rand7(); c = (row-1)*7 + col;</code>，这样每个元素等概率</li>
</ul>
</li>
</ul>
<h2 id="设计">设计</h2>
<ul>
<li><a href="https://leetcode.cn/problems/design-hashset/description/">705.设计哈希集合</a>：基于<code>vector&lt;list&lt;int&gt;&gt;</code>的链地址法</li>
<li><a href="https://leetcode.cn/problems/design-hashmap/description/">706.设计哈希映射</a>：基于<code>vector&lt;list&lt;pair&lt;int,int&gt;&gt;&gt;</code>的链地址法</li>
<li><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/">380.O(1)时间插入、删除和获取随机元素</a>：
<ul>
<li>一个<code>vector</code>用来获取随机元素</li>
<li>一个<code>unordered_map&lt;int, int&gt;</code>用来记录val到idx的映射</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">208.实现Trie（前缀树）</a>
<ul>
<li>类似二叉树，<code>Trie</code>本身就是一个node，里面有<code>vector&lt;Trie*&gt; children(26, nullptr)</code>表示26叉树</li>
<li><code>Trie</code>节点中包含一个属性<code>isEnd</code>，如果当前节点表示字符串的最后一个字符，则当前节点的下一个节点的<code>isEnd=true</code></li>
<li>包含一个辅助函数<code>Trie* searchPrefix(string prefix)</code>，返回prefix字符串结尾的下一个节点</li>
</ul>
</li>
</ul>
<h2 id="继续刷">继续刷</h2>
<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142.环形链表Ⅱ</a></p>
<p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">124.二叉树中的最大路径和 </a></p>
<p><a href="https://leetcode.cn/problems/path-sum-iii/description/">437.路径总和Ⅲ</a></p>
<p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/6098/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/">4.寻找两个正序数组的中位数</a></p>
<p><a href="https://leetcode.cn/problems/maximal-rectangle/description/">85.最大矩形</a></p>
<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28.找出字符串中第一个匹配项的下标</a>：KMP模板</p>
<h2 id="附录一acm输入输出模板">附录一：ACM输入输出模板</h2>
<ul>
<li>
<p><a href="https://kamacoder.com/problempage.php?pid=1000">A+B问题</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d %d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// while(cin &gt;&gt; a &gt;&gt; b) {} // 或者cin输入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意<code>scanf</code>输入中的换行，对于输入int不影响，但是对于输入char会影响，比如可能会将换行吃掉</p>
</li>
<li>
<p><a href="https://kamacoder.com/problempage.php?pid=1006">平均绩点</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 接受一整行字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="附录二刷题列表">附录二：刷题列表</h2>
<p><a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=%E7%AE%97%E6%B3%95%E7%AF%87&amp;topicId=295">牛客面试笔刷TOP101</a></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch19 特殊工具与技术</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch19-%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Tue, 27 Feb 2024 15:59:07 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch19-%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF/</guid>
      <description>第十八章 用于大型程序的工具 18.1 异常处理 18.2 命名空间 命名空间定义 语法相关： 只要能出现在全局作用域的声明就能置于命名空间中 命名空间不能定义在函数或类</description>
      <content:encoded><![CDATA[<h1 id="第十八章-用于大型程序的工具">第十八章 用于大型程序的工具</h1>
<h2 id="181-异常处理">18.1 异常处理</h2>
<h2 id="182-命名空间">18.2 命名空间</h2>
<h3 id="命名空间定义">命名空间定义</h3>
<ul>
<li>语法相关：
<ul>
<li>只要能出现在全局作用域的声明就能置于命名空间中</li>
<li>命名空间不能定义在函数或类内部</li>
<li>每个命名空间是一个作用域。</li>
<li>命名空间可以不连续，即同一命名空间可以定义为几个不同的部分，在多处出现
<ul>
<li>在头文件中声明命名空间中的成员，在源文件中定义命名空间中的成员</li>
</ul>
</li>
<li>通常不将<code>#include</code>放在命名空间中，否则会将该头文件中的所有名字定义为该命名空间中的成员</li>
</ul>
</li>
<li>几种命名空间
<ul>
<li>全局命名空间：使用<code>::</code>显式指明</li>
<li>嵌套命名空间</li>
<li>内联命名空间：无需使用该命名空间的前缀，通过外层命名空间就可以直接访问。
<ul>
<li>inline必须出现在命名空间第一次定义的地方，后续打开命名空间时可以不加inline</li>
<li>程序代码更新版本时经常使用内联空间，当前版本放在内联空间中，历史版本放在非内联空间中，
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* 文件名：FifthEd.h */</span> 
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">namespace</span> <span class="n">FifthEd</span><span class="p">{</span> <span class="c1">//定义第五版命名空间，是内联，使用时不需显式指定该空间的名字 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">class</span> <span class="nc">Query_base</span><span class="p">{</span><span class="cm">/* 类的定义 */</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：FourthEd.h */</span> 
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">FourthEd</span><span class="p">{</span> <span class="c1">//定义第四版命名空间 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">class</span> <span class="nc">Query_base</span><span class="p">{</span><span class="cm">/* 类的定义 */</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：cplusplus_primer.h */</span> 
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">cplusplus_primer</span><span class="p">{</span> <span class="c1">//将上面两个命名空间嵌套进外层空间 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cp">#include&#34;FifthEd.h&#34; </span><span class="c1">//引入头文件中的所有名字 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cp">#include&#34;FourthEd.h&#34; 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：main.cc */</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#include&#34;cplusplus_primer.h&#34; 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">cplusplus_primer</span><span class="o">::</span><span class="n">Query_base</span><span class="p">;</span> <span class="c1">//默认使用第五版中的成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">cplusplus_primer</span><span class="o">::</span><span class="n">FourthEd</span><span class="o">::</span><span class="n">Query_base</span><span class="p">;</span> <span class="c1">//手动指定第四版中的成员
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>未命名的命名空间
<ul>
<li>未命名的命名空间可以在一个文件内不连续（是同一个命名空间），但是不可跨越文件（否则是两个无关的命名空间）</li>
<li>未命名的命名空间中定义的变量拥有静态的声明周期：在第一次使用前创建，直到程序结束才销毁。</li>
<li>如果头文件中定义了未命名的命名空间，则不同源文件中包含了该头文件后，该空间中的名字对应不同实体</li>
<li>未命名的命名空间中的名字可以跨越到上一次作用域，因此定义在未命名的命名空间中的名字可以直接使用，不能对未命名的命名空间的成员使用作用域算符</li>
<li>应用：未命名的命名空间取代文件中的静态声明
<ul>
<li>原来将全局变量声明为<code>static</code>以转变为内部变量（C方式）</li>
<li>现在将全局变量放在未命名的命名空间中（C++方式，原因见上述语法），但是此时全局变量仍然是外部的，</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用命名空间成员">使用命名空间成员</h3>
<ul>
<li>命名空间的别名：<code>namespace new_name = old_name1::old_name2;</code>
<ul>
<li>一个命名空间可以有多个别名，但不能在未定义命名空间之前就声明别名</li>
</ul>
</li>
<li><code>using</code>声明：<code>using my_namespace::mem;</code>
<ul>
<li>一次只能引入命名空间的一个成员</li>
<li>声明的名字的作用域与using语句本身的作用域一致</li>
<li>在类作用域中<code>using</code>声明只能声明基类成员</li>
</ul>
</li>
<li><code>using</code>指示：<code>using nemespace my_namespace;</code>
<ul>
<li>引入命名空间中所有名字</li>
<li>using指示将命名空间注入到外层作用域，即将命名空间中所有名字出现在最近的外层作用域中（相当于using声明的外层作用域）</li>
<li>不可出现在类作用域</li>
</ul>
</li>
<li>命名空间污染：
<ul>
<li>使用了多个命名空间的using指示后，外层作用域中来自不同命名空间的名字可能发生冲突，这种冲突允许存在，但是使用时需要使用<code>::</code>明确指定版本</li>
<li>在头文件中，不要在全局作用域中使用using声明/指示，最多在函数、命名空间中使用</li>
<li>using指示引发的二义性错误只有在使用冲突名字的地方才会被发现，难以定位bug</li>
<li>尽量使用using声明而非using指示</li>
</ul>
</li>
</ul>
<h3 id="类命名空间与作用域">类、命名空间与作用域</h3>
<ul>
<li>名字查找的例外：给函数传递类类型对象/引用/指针时，先在常规的作用域中查找函数名，随后还会在实参类（及其基类）所属的命名空间中查找函数名。
<ul>
<li>这个规则使得概念上作为接口一部分的非成员函数不需单独using声明就可被程序使用</li>
<li>例子：<code>std::cin&gt;&gt;str;</code>表达式中，作用域中没有声明<code>operator&gt;&gt;()</code>函数，但是仍可以使用，这是因为在<code>istream</code>（实参<code>std::cin</code>所属类）和<code>string</code>（实参<code>str</code>所属类）所在的命名空间中进行了查找。否则需要显式声明：<code>using std::operator&gt;&gt;</code>，使用<code>operator&gt;&gt;(std::cin, str);</code></li>
</ul>
</li>
<li>友元相关：
<ul>
<li>当类声明友元时，还需要在类外给出友元的正式声明</li>
<li>一个未声明的类/函数若第一次出现在友元声明中，则认为它是最近的外层命名空间的成员。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">A</span><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">C</span><span class="p">{</span> <span class="c1">//这2个友元声明时还没有正式声明，认为它是最近的外层空间的成员，即隐式声明为空间A的成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">friend</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">();</span> <span class="c1">//没有形参 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">friend</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">//接受C类型对象作为实参 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span> 
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="o">::</span><span class="n">C</span> <span class="n">cobj</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="n">cobj</span><span class="p">);</span> <span class="c1">//对，f被隐式声明为A的成员，且实参决定会在A中查找函数f 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f2</span><span class="p">();</span> <span class="c1">//错，虽然f2被隐式声明为A的成员，但未显式指明 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="重载与命名空间">重载与命名空间</h3>
<ul>
<li><code>using</code>声明
<ul>
<li><code>using</code>声明语句声明的是一个名字，而非特定的函数，也就是包括该函数的所有版本，都被引入到当前作用域中。</li>
<li><code>using</code>声明引入的函数将重载该声明语句所属作用域中已有的同名函数。</li>
</ul>
</li>
<li><code>using</code>指示
<ul>
<li>若命名空间中函数名与外层作用域中函数同名，即使函数同名同参也不会报错，只需要使用时指明版本</li>
</ul>
</li>
</ul>
<h2 id="183-多重继承与虚继承">18.3 多重继承与虚继承</h2>
<h3 id="多重继承">多重继承</h3>
<ul>
<li>可以从多个基类中继承构造函数，但是这些构造函数必须形参列表不同
<ul>
<li>如果相同，则派生类必须为这种形参列表的构造函数定义自己的版本</li>
</ul>
</li>
</ul>
<h3 id="类型转换与多个基类">类型转换与多个基类</h3>
<ul>
<li>在派生类向基类的转换中，如果有多个基类，编译器不会进行比较，转换到任何基类一样好</li>
<li>对象的指针/引用的静态类型决定了哪些成员可见</li>
</ul>
<h3 id="多重继承下的类作用域">多重继承下的类作用域</h3>
<ul>
<li>在派生类中使用了某个名字，则程序并行的在多个基类中查找名字
<ul>
<li>派生类继承多个基类的同名成员合法，只是使用时需要<code>::</code>指明版本</li>
<li>派生类只是引入潜在的二义性，如果不调用该重名的对象，则不会报错</li>
</ul>
<ul>
<li>只有使用该重名对象时，才会产生二义性报错
<ul>
<li>该名字在多个基类中是形参列表不同的函数</li>
<li>该名字在一个基类中是private，而在另一个基类中是public/protected</li>
<li>该名字在一个基类中直接找到，而在另一个基类的间接基类中找到</li>
</ul>
</li>
<li>避免这种二义性的方法是在派生类中再定义一次这个名字，覆盖基类名字，避免在基类中查找</li>
</ul>
</li>
<li>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。</li>
</ul>
<h3 id="虚继承">虚继承</h3>
<ul>
<li>背景：菱形继承中，间接基类应该只有一个，如果不使用虚继承，则间接基类在派生类对象中有两个部分</li>
<li>虚继承：令某个类做出声明，承诺愿意共享它的基类。被共享的基类子对象称为<strong>虚基类</strong>，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。
<ul>
<li>经常并不知道一个类是否会被继承多次，因此不知道由它而来的派生是否应该是虚派生</li>
<li>实际编程中，位于中间层次的类将其继承基类的方式声明为虚继承并不会出问题。虚派生只影响从虚基类的派生类中进一步派生出的类，它不影响虚基类的派生类。</li>
</ul>
</li>
<li>语法相关：
<ul>
<li>在派生列表中添加<code>virtual</code>，表示后续的派生类共享虚基类的同一份实例</li>
<li>菱形继承：类B定义了成员x，D1和D2由B虚继承得到，D继承自D1和D2，则在D的作用域中，x通过两个基类都可见。若通过D的对象使用x，有几种可能：
<ul>
<li>若D1和D2中都未定义x，则x被解析为B的成员，不存在二义性。因为只在虚基类中有定义</li>
<li>若D1或D2其中之一定义了x，则x被解析为D1或D2的成员，不存在二义性。因为D1和D2是派生类，位于内层作用域，优先级更高</li>
<li>若D1和D2中都定义了x，则直接访问x时是二义性。因为D1和D2的优先级相同</li>
</ul>
</li>
<li>解决二义性最好的方法就是在派生类中为成员自定义新的实例</li>
</ul>
</li>
</ul>
<h3 id="构造函数与虚继承">构造函数与虚继承</h3>
<ul>
<li>在虚派生中，虚基类由最终的派生类在其构造函数初值列表中初始化（越过了继承链），而非由其直接派生类初始化，否则被重复初始化</li>
<li>只要创建了虚基类的派生类对象，该派生类的构造函数就会越过继承链初始化虚基类</li>
<li>含有虚基类的对象的构造顺序：
<ul>
<li>首先使用提供给最终派生类构造函数的初值来初始化虚基类（否则虚基类默认初始化）</li>
<li>一个类可有多个虚基类，这些虚基类的初始化顺序是它们在派生列表中的顺序</li>
<li>然后按照直接基类在派生列表中的顺序初始化非虚基类</li>
</ul>
</li>
<li>构造派生类时，编译器按照直接基类的声明顺序对其依次检查，若基类中含有虚基类，则先构造虚基类，然后按照声明顺序逐一构造其他非虚基类</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch18 用于大型程序的工具</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch18-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:59 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch18-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/</guid>
      <description>第十八章 用于大型程序的工具 18.1 异常处理 18.2 命名空间 命名空间定义 语法相关： 只要能出现在全局作用域的声明就能置于命名空间中 命名空间不能定义在函数或类</description>
      <content:encoded><![CDATA[<h1 id="第十八章-用于大型程序的工具">第十八章 用于大型程序的工具</h1>
<h2 id="181-异常处理">18.1 异常处理</h2>
<h2 id="182-命名空间">18.2 命名空间</h2>
<h3 id="命名空间定义">命名空间定义</h3>
<ul>
<li>语法相关：
<ul>
<li>只要能出现在全局作用域的声明就能置于命名空间中</li>
<li>命名空间不能定义在函数或类内部</li>
<li>每个命名空间是一个作用域。</li>
<li>命名空间可以不连续，即同一命名空间可以定义为几个不同的部分，在多处出现
<ul>
<li>在头文件中声明命名空间中的成员，在源文件中定义命名空间中的成员</li>
</ul>
</li>
<li>通常不将<code>#include</code>放在命名空间中，否则会将该头文件中的所有名字定义为该命名空间中的成员</li>
</ul>
</li>
<li>几种命名空间
<ul>
<li>全局命名空间：使用<code>::</code>显式指明</li>
<li>嵌套命名空间</li>
<li>内联命名空间：无需使用该命名空间的前缀，通过外层命名空间就可以直接访问。
<ul>
<li>inline必须出现在命名空间第一次定义的地方，后续打开命名空间时可以不加inline</li>
<li>程序代码更新版本时经常使用内联空间，当前版本放在内联空间中，历史版本放在非内联空间中，
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* 文件名：FifthEd.h */</span> 
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">namespace</span> <span class="n">FifthEd</span><span class="p">{</span> <span class="c1">//定义第五版命名空间，是内联，使用时不需显式指定该空间的名字 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">class</span> <span class="nc">Query_base</span><span class="p">{</span><span class="cm">/* 类的定义 */</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：FourthEd.h */</span> 
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">FourthEd</span><span class="p">{</span> <span class="c1">//定义第四版命名空间 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">class</span> <span class="nc">Query_base</span><span class="p">{</span><span class="cm">/* 类的定义 */</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：cplusplus_primer.h */</span> 
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">cplusplus_primer</span><span class="p">{</span> <span class="c1">//将上面两个命名空间嵌套进外层空间 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cp">#include&#34;FifthEd.h&#34; </span><span class="c1">//引入头文件中的所有名字 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cp">#include&#34;FourthEd.h&#34; 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="cm">/* 文件名：main.cc */</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#include&#34;cplusplus_primer.h&#34; 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">cplusplus_primer</span><span class="o">::</span><span class="n">Query_base</span><span class="p">;</span> <span class="c1">//默认使用第五版中的成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">cplusplus_primer</span><span class="o">::</span><span class="n">FourthEd</span><span class="o">::</span><span class="n">Query_base</span><span class="p">;</span> <span class="c1">//手动指定第四版中的成员
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>未命名的命名空间
<ul>
<li>未命名的命名空间可以在一个文件内不连续（是同一个命名空间），但是不可跨越文件（否则是两个无关的命名空间）</li>
<li>未命名的命名空间中定义的变量拥有静态的声明周期：在第一次使用前创建，直到程序结束才销毁。</li>
<li>如果头文件中定义了未命名的命名空间，则不同源文件中包含了该头文件后，该空间中的名字对应不同实体</li>
<li>未命名的命名空间中的名字可以跨越到上一次作用域，因此定义在未命名的命名空间中的名字可以直接使用，不能对未命名的命名空间的成员使用作用域算符</li>
<li>应用：未命名的命名空间取代文件中的静态声明
<ul>
<li>原来将全局变量声明为<code>static</code>以转变为内部变量（C方式）</li>
<li>现在将全局变量放在未命名的命名空间中（C++方式，原因见上述语法），但是此时全局变量仍然是外部的，</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用命名空间成员">使用命名空间成员</h3>
<ul>
<li>命名空间的别名：<code>namespace new_name = old_name1::old_name2;</code>
<ul>
<li>一个命名空间可以有多个别名，但不能在未定义命名空间之前就声明别名</li>
</ul>
</li>
<li><code>using</code>声明：<code>using my_namespace::mem;</code>
<ul>
<li>一次只能引入命名空间的一个成员</li>
<li>声明的名字的作用域与using语句本身的作用域一致</li>
<li>在类作用域中<code>using</code>声明只能声明基类成员</li>
</ul>
</li>
<li><code>using</code>指示：<code>using nemespace my_namespace;</code>
<ul>
<li>引入命名空间中所有名字</li>
<li>using指示将命名空间注入到外层作用域，即将命名空间中所有名字出现在最近的外层作用域中（相当于using声明的外层作用域）</li>
<li>不可出现在类作用域</li>
</ul>
</li>
<li>命名空间污染：
<ul>
<li>使用了多个命名空间的using指示后，外层作用域中来自不同命名空间的名字可能发生冲突，这种冲突允许存在，但是使用时需要使用<code>::</code>明确指定版本</li>
<li>在头文件中，不要在全局作用域中使用using声明/指示，最多在函数、命名空间中使用</li>
<li>using指示引发的二义性错误只有在使用冲突名字的地方才会被发现，难以定位bug</li>
<li>尽量使用using声明而非using指示</li>
</ul>
</li>
</ul>
<h3 id="类命名空间与作用域">类、命名空间与作用域</h3>
<ul>
<li>名字查找的例外：给函数传递类类型对象/引用/指针时，先在常规的作用域中查找函数名，随后还会在实参类（及其基类）所属的命名空间中查找函数名。
<ul>
<li>这个规则使得概念上作为接口一部分的非成员函数不需单独using声明就可被程序使用</li>
<li>例子：<code>std::cin&gt;&gt;str;</code>表达式中，作用域中没有声明<code>operator&gt;&gt;()</code>函数，但是仍可以使用，这是因为在<code>istream</code>（实参<code>std::cin</code>所属类）和<code>string</code>（实参<code>str</code>所属类）所在的命名空间中进行了查找。否则需要显式声明：<code>using std::operator&gt;&gt;</code>，使用<code>operator&gt;&gt;(std::cin, str);</code></li>
</ul>
</li>
<li>友元相关：
<ul>
<li>当类声明友元时，还需要在类外给出友元的正式声明</li>
<li>一个未声明的类/函数若第一次出现在友元声明中，则认为它是最近的外层命名空间的成员。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">A</span><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">C</span><span class="p">{</span> <span class="c1">//这2个友元声明时还没有正式声明，认为它是最近的外层空间的成员，即隐式声明为空间A的成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">friend</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">();</span> <span class="c1">//没有形参 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">friend</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">//接受C类型对象作为实参 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span> 
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="o">::</span><span class="n">C</span> <span class="n">cobj</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="n">cobj</span><span class="p">);</span> <span class="c1">//对，f被隐式声明为A的成员，且实参决定会在A中查找函数f 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f2</span><span class="p">();</span> <span class="c1">//错，虽然f2被隐式声明为A的成员，但未显式指明 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="重载与命名空间">重载与命名空间</h3>
<ul>
<li><code>using</code>声明
<ul>
<li><code>using</code>声明语句声明的是一个名字，而非特定的函数，也就是包括该函数的所有版本，都被引入到当前作用域中。</li>
<li><code>using</code>声明引入的函数将重载该声明语句所属作用域中已有的同名函数。</li>
</ul>
</li>
<li><code>using</code>指示
<ul>
<li>若命名空间中函数名与外层作用域中函数同名，即使函数同名同参也不会报错，只需要使用时指明版本</li>
</ul>
</li>
</ul>
<h2 id="183-多重继承与虚继承">18.3 多重继承与虚继承</h2>
<h3 id="多重继承">多重继承</h3>
<ul>
<li>可以从多个基类中继承构造函数，但是这些构造函数必须形参列表不同
<ul>
<li>如果相同，则派生类必须为这种形参列表的构造函数定义自己的版本</li>
</ul>
</li>
</ul>
<h3 id="类型转换与多个基类">类型转换与多个基类</h3>
<ul>
<li>在派生类向基类的转换中，如果有多个基类，编译器不会进行比较，转换到任何基类一样好</li>
<li>对象的指针/引用的静态类型决定了哪些成员可见</li>
</ul>
<h3 id="多重继承下的类作用域">多重继承下的类作用域</h3>
<ul>
<li>在派生类中使用了某个名字，则程序并行的在多个基类中查找名字
<ul>
<li>派生类继承多个基类的同名成员合法，只是使用时需要<code>::</code>指明版本</li>
<li>派生类只是引入潜在的二义性，如果不调用该重名的对象，则不会报错</li>
</ul>
<ul>
<li>只有使用该重名对象时，才会产生二义性报错
<ul>
<li>该名字在多个基类中是形参列表不同的函数</li>
<li>该名字在一个基类中是private，而在另一个基类中是public/protected</li>
<li>该名字在一个基类中直接找到，而在另一个基类的间接基类中找到</li>
</ul>
</li>
<li>避免这种二义性的方法是在派生类中再定义一次这个名字，覆盖基类名字，避免在基类中查找</li>
</ul>
</li>
<li>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。</li>
</ul>
<h3 id="虚继承">虚继承</h3>
<ul>
<li>背景：菱形继承中，间接基类应该只有一个，如果不使用虚继承，则间接基类在派生类对象中有两个部分</li>
<li>虚继承：令某个类做出声明，承诺愿意共享它的基类。被共享的基类子对象称为<strong>虚基类</strong>，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。
<ul>
<li>经常并不知道一个类是否会被继承多次，因此不知道由它而来的派生是否应该是虚派生</li>
<li>实际编程中，位于中间层次的类将其继承基类的方式声明为虚继承并不会出问题。虚派生只影响从虚基类的派生类中进一步派生出的类，它不影响虚基类的派生类。</li>
</ul>
</li>
<li>语法相关：
<ul>
<li>在派生列表中添加<code>virtual</code>，表示后续的派生类共享虚基类的同一份实例</li>
<li>菱形继承：类B定义了成员x，D1和D2由B虚继承得到，D继承自D1和D2，则在D的作用域中，x通过两个基类都可见。若通过D的对象使用x，有几种可能：
<ul>
<li>若D1和D2中都未定义x，则x被解析为B的成员，不存在二义性。因为只在虚基类中有定义</li>
<li>若D1或D2其中之一定义了x，则x被解析为D1或D2的成员，不存在二义性。因为D1和D2是派生类，位于内层作用域，优先级更高</li>
<li>若D1和D2中都定义了x，则直接访问x时是二义性。因为D1和D2的优先级相同</li>
</ul>
</li>
<li>解决二义性最好的方法就是在派生类中为成员自定义新的实例</li>
</ul>
</li>
</ul>
<h3 id="构造函数与虚继承">构造函数与虚继承</h3>
<ul>
<li>在虚派生中，虚基类由最终的派生类在其构造函数初值列表中初始化（越过了继承链），而非由其直接派生类初始化，否则被重复初始化</li>
<li>只要创建了虚基类的派生类对象，该派生类的构造函数就会越过继承链初始化虚基类</li>
<li>含有虚基类的对象的构造顺序：
<ul>
<li>首先使用提供给最终派生类构造函数的初值来初始化虚基类（否则虚基类默认初始化）</li>
<li>一个类可有多个虚基类，这些虚基类的初始化顺序是它们在派生列表中的顺序</li>
<li>然后按照直接基类在派生列表中的顺序初始化非虚基类</li>
</ul>
</li>
<li>构造派生类时，编译器按照直接基类的声明顺序对其依次检查，若基类中含有虚基类，则先构造虚基类，然后按照声明顺序逐一构造其他非虚基类</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch17 标准库特殊设施</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch17-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:50 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch17-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/</guid>
      <description>第十六章 模板和泛型编程 16.1 定义模板 模板参数列表：&amp;lt;&amp;gt; 模板参数（也称(模板)类型参数）：T typename或class（作用相同），</description>
      <content:encoded><![CDATA[<h1 id="第十六章-模板和泛型编程">第十六章 模板和泛型编程</h1>
<h2 id="161-定义模板">16.1 定义模板</h2>
<ul>
<li>模板参数列表：<code>&lt;&gt;</code></li>
<li>模板参数（也称(模板)类型参数）：<code>T</code>
<ul>
<li><code>typename</code>或<code>class</code>（作用相同），用来表示模板参数</li>
</ul>
</li>
<li>模板非类型参数：模板参数列表中表示一个值而非一个类型</li>
</ul>
<h3 id="函数模板">函数模板</h3>
<ul>
<li>模板实例化时，可以使用[[ch16-模板和泛型编程#函数模板显式实参|显式实参]]，根据实参[[ch16-模板和泛型编程#类型转换与模板类型参数|隐式推断模板参数类型]]</li>
<li>模板非类型参数：
<ul>
<li>可以是一个整型、指针或左值引用</li>
<li>实例化时，整型实参必须是常量表达式，指针/引用指向的对象必须有静态的生存周期（即对象不能是非static局部变量或动态对象），这样做可以使编译器在编译时实例化模板</li>
<li>使用场景：比如数组类型作为模板参数时大小固定，但是使用模板非类型参数就不必固定
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">M</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="n">T</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r2</span><span class="p">)[</span><span class="n">M</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">strcmp</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><code>inline</code>或<code>constexpr</code>的函数模板：模板参数列表之后，返回类型之前</li>
<li>模板编译
<ul>
<li>只有模板实例化时，编译器才生成代码</li>
<li>通常将类定义和函数声明放在头文件中，其实现放在源文件中；但是，函数模板和类模板成员函数的实现通常也放在头文件中。因为编译器知道模板的完整定义后才能进行实例化</li>
<li>大多数模板的编译错误在实例化期间才报告</li>
</ul>
</li>
</ul>
<h3 id="类模板">类模板</h3>
<ul>
<li>使用类模板必须提供显式模板参数列表，编译器不能推断模板参数类型</li>
<li>一个类模板的成员函数只有当程序用到它时，才进行<span id="类模板的实例化">实例化</span></li>
<li>使用类模板类型时必须提供模板参数，只有在类模板作用域内部才可以只使用模板名而不提供实参</li>
<li>友元相关，<a href="https://blog.csdn.net/caroline_wendy/article/details/16916441">例子</a>
<ul>
<li>如果一个类模板包含一个非模板友元，则友元可以访问该类模板的所有实例</li>
<li>如果一个类模板包含一个模板友元，则类可以授权给所有友元模板实例，也可以只授权给特定实例
<ul>
<li>一对一友好关系：友好关系被限定在相同类型的友元和类本身之间
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Fri</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 比如Fri&lt;int&gt;实例可以访问MyClass&lt;int&gt;实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span> <span class="c1">// 友元函数，重载==
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="p">()</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span><span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span> <span class="nf">clone</span><span class="p">();</span> <span class="c1">// 处于类模板作用域中，编译器会将MyClass当作是MyClass&lt;T&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">clone</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">MyClass</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 一对一友好关系，Fri&lt;T&gt;是MyClass&lt;T&gt;的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">size</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 但是Fri&lt;T&gt;就不是MyClass&lt;K&gt;的友元(T!=K)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">char_class</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_class</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Fri</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fri</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">char_class</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// fri.func(int_class);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>    
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>通用和特定的模板友好关系：一个类可以将另一个模板的每个实例都声明为为自己的友元，或者限定特定的实例为友元
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Common</span><span class="p">{</span> <span class="c1">// 普通类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal</span><span class="p">;</span> <span class="c1">// 【Pal的所有实例】都是类Common的友元，此时Fri可以不用提前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span> <span class="c1">// 模板类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Fri</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 一对一友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">MyFri</span><span class="p">;</span> <span class="c1">// 【MyPal的所有实例】都是MyClass每个实例的友元，此时MyPal可以不用提前声明，且声明中使用了不同的模板参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Commom_fri</span><span class="p">;</span> <span class="c1">// 普通类作为模板类的友元，此时不需要提前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>      
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>虽然友元通常是类或函数，但是允许将模板类型参数<code>T</code>作为友元，因此类型<code>T</code>的对象可以访问类模板的private成员。<a href="https://blog.csdn.net/craftsman1970/article/details/81748184">例子</a>。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">T</span><span class="p">;</span> <span class="c1">// 类型T是MyClass的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">private_func</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;private func of MyClass &#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">func</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">test</span><span class="p">.</span><span class="n">private_func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">;</span> <span class="c1">// 类型Test是MyClass的友元，Test类型的对象可以访问【类模板MyClass基于Test类型的实例】的private成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Test</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>模板类型别名
<ul>
<li>为类模板的实例创建别名：<code>typedef MyClass&lt;int&gt; MC;</code></li>
<li>为类模板定义别名：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 固定一个类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>类模板的static成员
<ul>
<li>相同类型类模板的实例的static成员是共享的，不同类型之间类模板的实例的static成员是不同的</li>
</ul>
</li>
</ul>
<h3 id="模板参数">模板参数</h3>
<ul>
<li>模板内不能重用模板参数名，且同一个模板参数名<code>T</code>在同一个模板参数列表中只能出现一次</li>
<li>声明中的模板参数不必与定义中的模板参数相同，且模板声明通常一起放在文件开始位置（使用模板的代码之前）</li>
<li>使用<code>T::mem</code>，无法判断mem是类型T的static成员还是类型T的类型成员
<ul>
<li>普通类中编译器已知类的定义因此可以判断</li>
<li>默认<code>T::mem</code>访问的是static成员</li>
<li>使用<code>typename</code>显式说明访问的是类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">age</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">;</span> <span class="c1">// 类型成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="c1">// static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Person</span><span class="o">::</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;zhang&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">age</span> <span class="n">func</span><span class="p">(){</span> <span class="c1">// 显式说明T::age是一个类型而非static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">T</span><span class="o">::</span><span class="n">name</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 默认T::name是static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">age</span> <span class="n">myAge</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">myAge</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>默认模板实参：默认模板实参都在最右侧，对函数模板和类模板都可以提供默认模板实参</li>
</ul>
<h3 id="成员模板">成员模板</h3>
<ul>
<li>成员模板：普通类或模板类的成员函数是模板函数，成员模板不能是虚函数</li>
<li>普通类的成员模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span> <span class="c1">// 普通类中包含成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 普通类中的成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 对比模板类中的普通成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span> <span class="n">myClass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 普通类中的成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Test</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">test</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 模板类中的普通函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>类模板的成员模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">K</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">H</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 类模板的模板参数列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">H</span><span class="o">&gt;</span> <span class="c1">// 类模板的成员模板的模板参数列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">(</span><span class="n">H</span> <span class="n">h</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">H</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myClass</span><span class="p">(</span><span class="sc">&#39;k&#39;</span><span class="p">);</span> <span class="c1">// 显式提供T=int, 隐式推断K=char
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span> <span class="c1">// 隐式推断H=double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;str&#34;</span><span class="p">);</span> <span class="c1">// 显式提供H=string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="显式实例化">显式实例化</h3>
<ul>
<li>背景：模板只有使用时才被实例化，因此相同的实例可能出现在多个文件中，造成额外开销</li>
<li>显式实例化
<ul>
<li>当编译器遇到<code>extern</code>模板声明时，不会在本文件中生成模板的实例化代码，表示使用其他位置的实例化代码</li>
<li><code>extern</code>声明必须出现在使用此实例化版本的代码之前，否则编译器进行实例化，起不到外部定义的效果</li>
<li>显式实例化定义会实例化所有成员</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 在a.cpp中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 实例化声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="kt">int</span> <span class="n">compare</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 在b.cpp中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 实例化定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="效率与灵活性">效率与灵活性</h3>
<ul>
<li>shared_ptr在运行时绑定删除器，因此删除器保存为一个指针而不是一个成员，因此删除器的类型直到运行时才直到，而且可以随时改变删除器的类型
<ul>
<li>需要间接调用删除器，但是用户重载删除器的操作更加便捷（只需要传入一个可调用对象）</li>
</ul>
</li>
<li>unique_ptr在编译期绑定删除器，删除器的类型是类类型的一部分（因此删除器类型在编译器是已知的），从而删除器可以直接保存在成员中
<ul>
<li>避免了间接调用删除器的运行时开销</li>
</ul>
</li>
</ul>
<h2 id="162-函数模板实参推断">16.2 函数模板实参推断</h2>
<ul>
<li>可以[[ch16-模板和泛型编程#类型转换与模板类型参数|基于实参推导模板参数类型]]，也可以[[ch16-模板和泛型编程#函数指针和实参推断|函数指针指向函数模板推导模板参数类型]]</li>
<li>有时比如返回值类型无法推导出来，可以指定[[ch16-模板和泛型编程#函数模板显式实参|模板显式实参]]，也可以使用[[ch16-模板和泛型编程#尾置返回类型与类型转换|尾置返回类型]]（同时可以[[ch16-模板和泛型编程#尾置返回类型后进行类型转换|去除引用]]）</li>
<li>当模板类型<code>T</code>为引用时，需要依据实参是左值/右值来判断T的引用类型，而且可以使用完美转发保持实参的类型不变</li>
</ul>
<h3 id="类型转换与模板类型参数">类型转换与模板类型参数</h3>
<ul>
<li>模板实参推断：根据实参类型推断出模板参数<code>T</code>的类型
<ul>
<li>一般<code>T</code>就是实参类型</li>
<li>编译器会对以下几种实参进行类型转换，得到的<code>T</code>并不完全是实参类型
<ul>
<li>顶层<code>const</code>会被忽略</li>
<li>可以将非const对象的指针或引用传递给一个const的指针或引用形参</li>
<li>如果形参不是引用类型，数组名/函数名转换为指针类型</li>
</ul>
</li>
</ul>
</li>
<li><code>template&lt;typename T&gt; void func(T a, T b);</code>中，a和b推断的类型必须相同</li>
</ul>
<h3 id="函数模板显式实参">函数模板显式实参</h3>
<ul>
<li>背景：类型<code>T</code>只出现在返回值/函数体，不在形参列表中时，编译器无法推断出模板实参的类型：</li>
<li>函数模板显式实参从左到右进行对应，如果模板参数可以推导出来，放在模板参数列表右侧，实例化时可以进行推导</li>
<li>当显式指定实参时，对实参可以使用正常的类型转换</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span> <span class="n">T1</span> <span class="n">sum</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">);</span> <span class="c1">// T1在返回值中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="kt">double</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// T1类型是long long, T2、T3类型可以推导出来，放在右侧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">test</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// T2类型显式指定为long long，因此将a转换为long long型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">compare</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// 使用显式模板实参，a、b都转换为long long类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="尾置返回类型与类型转换">尾置返回类型与类型转换</h3>
<h4 id="尾置返回类型">尾置返回类型</h4>
<ul>
<li>背景：有时函数模板的返回值类型不能由实参推导而来，比如[[ch16-模板和泛型编程#函数模板显式实参|函数模板显式实参]]的背景
<ul>
<li>可以使用函数模板显式实参进行指定，也可以<strong>使用尾置返回类型自动推导</strong></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="n">Iter</span> <span class="n">beg</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">){</span> <span class="c1">// 从局部变量中推导出返回类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="尾置返回类型后进行类型转换">尾置返回类型后进行类型转换</h4>
<ul>
<li>背景：通过模板显式实参可以指定返回值类型，但是通过尾置返回类型推导得到的类型可能不是想要的，比如有时不希望得到引用类型</li>
<li><strong>标准库的类型转换模板</strong>
<ul>
<li>定义在头文件<code>type_traits</code>中，常用于模板元程序设计</li>
<li>Mod是一个类模板，将类型<code>T</code>转换为类型<code>type</code>；如果无法转化，则类型<code>type</code></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="n">Iter</span> <span class="n">beg</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">{</span> <span class="c1">// 表明type是一个类型而非一个static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th><code>Mod</code></th>
<th><code>T</code></th>
<th><code>Mod&lt;T&gt;::type</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_const</code></td>
<td><code>X&amp;</code>或<code>const X</code>或函数</td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>const T</code></td>
</tr>
<tr>
<td><code>add_lvalue_reference</code></td>
<td><code>X&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td><code>X&amp;&amp;</code></td>
<td><code>X&amp;</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;</code></td>
</tr>
<tr>
<td><code>add_rvalue_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;&amp;</code></td>
</tr>
<tr>
<td><code>remove_pointer</code></td>
<td><code>X*</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_pointer</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X*</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T*</code></td>
</tr>
<tr>
<td><code>make_signed</code></td>
<td><code>unsigned X</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>make_unsigned</code></td>
<td>带符号类型</td>
<td><code>unsigned X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_extent</code></td>
<td><code>X[n]</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_all_extents</code></td>
<td><code>X[n1][n2]...</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<h3 id="函数指针和实参推断">函数指针和实参推断</h3>
<ul>
<li>将函数模板赋值给函数指针：
<ul>
<li>函数指针指向函数模板的一个实例</li>
<li>使用函数指针的类型来推断模板实参</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>  <span class="c1">// T是int，f指向函数模板的实例compare(const int&amp;, const int&amp;)
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果函数func的形参是函数指针，实参可以传入函数模板，这样函数指针指向一个模板实例且进行了参数推断
<ul>
<li>但是当func有多个重载的版本时（接受不同类型的函数指针），传入函数模板可能产生歧义，此时可以指定【显式模板实参】</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">));</span> <span class="c1">// 重载
</span></span></span><span class="line"><span class="cl"><span class="c1">// func(compare); // 歧义：函数模板compare实例化为哪一种函数指针？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">func</span><span class="p">(</span><span class="n">compare</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="模板实参推断和引用">模板实参推断和引用</h3>
<h4 id="模板参数t的类型推断">模板参数<code>T&amp;</code>的类型推断</h4>
<table>
<thead>
<tr>
<th style="text-align:center">模板类型参数</th>
<th style="text-align:center">实参要求</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>T&amp;</code></td>
<td style="text-align:center">必须传递一个左值</td>
<td style="text-align:center">实参为<code>int</code>，<code>T</code>为<code>int</code>;实参为<code>const int</code>，<code>T</code>为<code>const int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>const T&amp;</code></td>
<td style="text-align:center">可以传递左值或右值</td>
<td style="text-align:center">实参为<code>int, const int, const int&amp;&amp;</code>，<code>T</code>都为<code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>T&amp;&amp;</code></td>
<td style="text-align:center">必须传递一个右值</td>
<td style="text-align:center">实参为<code>int&amp;&amp;</code>， <code>T</code>为<code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>T&amp;&amp;</code></td>
<td style="text-align:center">例外：传递一个类型为<code>type</code>的左值，推导<code>T</code>为<code>type&amp;</code>类型</td>
<td style="text-align:center">实参为<code>int&amp;</code>,<code>T</code>为<code>int&amp;</code></td>
</tr>
</tbody>
</table>
<h4 id="引用折叠">引用折叠</h4>
<ul>
<li>背景：基于上面这个例外，创造出了引用的引用，或者通过类型别名也可以创造出引用的引用，可以将多个引用折叠为一个引用</li>
<li>引用折叠规则：
<ul>
<li><code>type&amp; &amp;、 type&amp; &amp;&amp;、 type&amp;&amp; &amp;</code>折叠为<code>type &amp;</code></li>
<li><code>type&amp;&amp; &amp;&amp;</code>折叠为<code>T&amp;&amp;</code></li>
</ul>
</li>
<li>使用：
<ul>
<li>若函数形参是<code>T&amp;&amp;</code>，则可以传递一个左值（实参的const属性可以保持，因为是底层const）</li>
<li>如果传入的是左值<code>type&amp;</code>，推导出<code>T=type&amp;</code></li>
<li>万能引用（或称为模板类型参数右值引用）：函数形参为<code>T&amp;&amp;</code>时，传递左值/右值均可
<ul>
<li>使用万能引用导致只有在运行时才能确定形参是左值还是右值，使得模板的编写变得困难</li>
<li>通常在两种情况中使用万能引用：模板转发实参，模板重载</li>
<li>使用万能引用的形参通常重载为两个版本：
<ul>
<li>拷贝版本：<code>template&lt;typename T&gt; void f(const T&amp;)</code>  绑定到左值和const右值</li>
<li>移动版本：<code>template&lt;typename T&gt; void f(T&amp;&amp;)</code> 绑定到非const右值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="stdmove"><code>std::move</code></h4>
<ul>
<li>[[ch13-拷贝控制#^d3a2a0|std::move函数]]的定义：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>可以使用<code>static_cast</code>显式地将左值转换为右值引用</li>
</ul>
<h3 id="转发">转发</h3>
<ul>
<li>背景：比如函数f内部调用函数g时，可能需要将f的实参传递给g，而且同时要求保持实参性质不变（比如const属性，左值/右值属性）
<ul>
<li>即希望达到这样的效果：将实参传递给f，再传递给g，与实参直接传递给g，的效果等价</li>
<li>例子一：f形参类型是非引用，g形参类型是左值引用，传入一个左值引用，则此时f转发参数给g时会使用自己的拷贝而非原来的引用</li>
<li>例子二：f形参类型是万能引用<code>T&amp;&amp;</code>，g形参类型是右值引用，f可以接受右值（或左值），此时f转发参数给g时，使用的右值引用本身是一个左值，不能传参给g的右值引用</li>
</ul>
</li>
<li>比较：都是定义在<code>utility</code>中的函数模板，最好显式指明是<code>std::</code>中的
<ul>
<li><code>std::forward</code>：可指定模板参数，并且可以对返回值使用引用折叠来保留左右值属性</li>
<li><code>std::move</code>：返回值一定是右值引用</li>
</ul>
</li>
<li>使用：完美转发
<ul>
<li>通过万能引用在传入外层f时保留实参的全部属性</li>
<li>通过<code>std::forward</code>在传入内层函数g时再次保留实参的全部属性</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">arg</span><span class="p">){</span> <span class="c1">// 万能引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span> <span class="c1">// std::forward&lt;T&gt;的返回类型是T&amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果实参是左值，推导出<code>T=type&amp;</code>，<code>std::forward&lt;T&gt;</code>的返回类型<code>T&amp;&amp;</code>折叠为<code>type&amp;</code></li>
<li>如果实参是右值，推导出<code>T=type</code>，<code>std::forward&lt;T&gt;</code>的返回类型即为<code>type&amp;&amp;</code></li>
</ul>
</li>
<li>例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">flip</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">K</span> <span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34;  &#34;</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">flip</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// F=void(*)(int&amp;&amp;, int&amp;), T=int&amp;, K=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">flip</span><span class="p">(</span><span class="n">g</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// F=void(*)(int&amp;&amp;, int&amp;), T=int&amp;, K=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="163-重载与模板">16.3 重载与模板</h2>
<ul>
<li>函数模板可以被另一个函数模板或普通函数重载
<ul>
<li>[[ch06-函数#6.6 函数匹配|函数的重载与匹配]]：有一些重载的函数，根据实参情况，调用时用哪个函数？</li>
<li>函数模板的重载与匹配：有一些重载的函数模板和普通函数，根据实参情况（函数模板进行函数模板实参推断），实例化并调用哪个函数模板</li>
</ul>
</li>
<li>到函数模板的函数匹配规则（[[ch06-函数#6.6 函数匹配|普通函数匹配的拓展]]）
<ul>
<li>确定候选函数：同名的函数，包括实参推断成功的函数模板实例</li>
<li>确定可行函数：参数类型和数量都匹配，
<ul>
<li>候选的函数模板实例都是可行的，因为实参推断会排除掉不可行的模板</li>
</ul>
</li>
<li>按照类型转换进行排序，寻找最佳匹配（普通函数和函数模板实例都可能发生类型转换，只是应用于函数模板的[[ch16-模板和泛型编程#类型转换与模板类型参数|类型转换]]十分有限）
<ul>
<li>若恰有一个函数提供比其他函数都好的匹配，则选择它</li>
<li>如果多个函数都提供相同级别的匹配
<ul>
<li>非模板和模板重载：如果只有一个是非模板函数，选择非模板函数</li>
<li>多个可行模板：如果没有非模板函数（有多个函数模板），选择最特例化的函数模板（特例化：比如<code>T&amp;</code>可以匹配任意类型，<code>T*</code>只能匹配指针类型）</li>
<li>调用有歧义，失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最佳实践：在定义重载函数之前，应该先声明所有重载的版本，否则可能重载一个模板函数进行实例化（因为没有找到想使用的版本，使用函数模板进行实例化），编译期不会报错，但是运行期会调用不期望使用的版本</li>
</ul>
<h2 id="164-可变参数模板">16.4 可变参数模板</h2>
<ul>
<li><strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类，可变数目的参数被称为<strong>参数包</strong>
<ul>
<li>模板参数包：表示零个或多个模板参数（模板类型参数或模板非类型参数）
<ul>
<li><code>typename</code>后跟<code>...</code>表示模板类型参数包</li>
<li>类型名后跟<code>...</code>表示模板非类型参数包</li>
</ul>
</li>
<li>函数参数包：表示零个或多个函数参数。</li>
</ul>
</li>
<li><code>sizeof...</code>运算符：返回参数包中的元素数量，且不会对其实参求值（类似于sizeof）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span> <span class="c1">// 模板参数包：Args是模板类型参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="p">...</span> <span class="n">rest</span><span class="p">){</span>  <span class="c1">// 函数参数包：rest是函数参数包（其类型是模板参数包Args）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">rest</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="编写可变参数函数模板">编写可变参数函数模板</h3>
<ul>
<li>[[ch06-函数#可变形参|可变形参]]<code>initializer_list</code>可以接受可变数目实参，但是需要是相同类型的</li>
<li>可变参数函数通常是递归的
<ul>
<li>第一步调用处理参数包中的第一个实参，然后用剩余实参调用自身</li>
<li>还需要定义一个非可变参数的函数（因为函数匹配时会使用这个更加特例化的版本，而不是使用0个参数的可变参数模板的实例），来处理参数包中最后一个实参</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="c1">// 打印最后一个元素，用来终止递归，必须在可变参数版本的print定义之前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rest</span><span class="p">...);</span>   <span class="c1">// 递归调用，实参是将除了第一个，剩余的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="包扩展">包扩展</h3>
<ul>
<li>扩展<code>...</code>：将参数包分解为单个元素，每个元素应用模式，得到拓展后的列表</li>
<li>常用情况：
<ul>
<li><code>const Args&amp; ...</code>：将模板参数包<code>Args</code>中所有类型<code>T</code>都扩展为<code>const T&amp;</code></li>
<li><code>args...</code>：将函数参数包<code>args</code>扩展为参数列表</li>
<li><code>f(args)...</code>：对函数参数包<code>args</code>中每个元素调用函数<code>f</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">){</span> <span class="c1">// 扩展模板参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">debug_reg</span><span class="p">(</span><span class="n">rest</span><span class="p">)...);</span> <span class="c1">// 扩展函数参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="转发参数包">转发参数包</h3>
<ul>
<li>组合使用可变参数模板和<code>forward</code>机制，实现将可变参数的完美转发，例子：<code>emplace_back</code></li>
<li>如果同时存在模板参数包和函数参数包，则同时拓展：
<ul>
<li><code>f&lt;Args&gt;(args)...</code>等价于<code>f&lt;Args1&gt;(args1), f&lt;Args2&gt;(args2), ... </code></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">work</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="165-模板特例化specializations">16.5 模板特例化（Specializations）</h2>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=03b4a1a4-b85a-ef1b-901a-178f5542609b&amp;page=650&amp;rect=86.880,83.040,255.996,90.480">背景和例子</a>：对于某个类型，不想用（对特定类型可以做优化）或者不能用（对特定类型的使用并非预期）模板</li>
</ul>
<h3 id="定义函数模板特例化">定义函数模板特例化</h3>
<ul>
<li>必须为原模板中每个模板参数都提供实参（全特例化）</li>
<li>关键字<code>template</code>后面跟一个空尖括号对（<code>&lt;&gt;</code>），表示所有模板参数都已被指定</li>
<li>特例化版本的参数类型必须与一个先前声明的模板中对应的类型相匹配。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">// T为const char*
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="函数重载与模板特例化">函数重载与模板特例化</h3>
<ul>
<li>特例化的本质是实例化一个模板，而不是重载它。因此特例化不影响[[ch16-模板和泛型编程#16.3 重载与模板|函数的匹配规则]]，即非模板函数先，再是特例化版本的函数（模板的实例化），最后是函数模板的实例</li>
<li>最佳实践：模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是特例化版本。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span> <span class="c1">// 特例化版本，T为const char*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span> <span class="c1">// 普通函数
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="类模板特例化">类模板特例化</h3>
<ul>
<li>必须在原模板定义所在的命名空间中进行类模板特例化</li>
<li>类模板可以进行部分特例化（偏特例化），得到的是模板；也可以全部特例化（全特例化），得到的是实例</li>
<li>类模板的部分特例化
<ul>
<li>未完全确定类型的模板参数仍放在<code>&lt;&gt;</code>中，即偏特化的模板参数列表非空。使用时也需提供模板实参，这些实参与原始模板中的参数按位置对应</li>
<li>部分特例化的模板参数列表是原始模板参数列表的一个子集或者特例化版本</li>
<li>例子：标准库remove_reference类型是通过一系列的特例化版本来完成其功能的
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//原始的、最通用的版本，可用于任意类型实例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span> <span class="p">{</span>  <span class="c1">//针对于左值引用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span> <span class="p">{</span> <span class="c1">//针对于右值引用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//调用原始模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">a</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//decltype(i)==int&amp;，调用第一个（T&amp;）部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">b</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//decltype(std::move(i))==int&amp;&amp;，调用第二个（T&amp;&amp;）部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">c</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//a、b、c均为int
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>特例化成员函数而不是整个类
<ul>
<li>使用模板的实例调用成员时，若该实例的模板实参与特化该成员时的参数一致，则调用特化版本的成员</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="p">())</span> <span class="o">:</span><span class="n">mem</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span> <span class="c1">//通用的Bar()函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">T</span> <span class="n">mem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//特例化Foo&lt;int&gt;版本的的成员Bar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Bar</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">fs</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">fs</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>       <span class="c1">//使用Foo&lt;string&gt;的通用的Bar()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fi</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="n">fi</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>       <span class="c1">//使用Foo&lt;int&gt;的特例化的Bar()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch16 模板和泛型编程</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:40 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</guid>
      <description>第十六章 模板和泛型编程 16.1 定义模板 模板参数列表：&amp;lt;&amp;gt; 模板参数（也称(模板)类型参数）：T typename或class（作用相同），</description>
      <content:encoded><![CDATA[<h1 id="第十六章-模板和泛型编程">第十六章 模板和泛型编程</h1>
<h2 id="161-定义模板">16.1 定义模板</h2>
<ul>
<li>模板参数列表：<code>&lt;&gt;</code></li>
<li>模板参数（也称(模板)类型参数）：<code>T</code>
<ul>
<li><code>typename</code>或<code>class</code>（作用相同），用来表示模板参数</li>
</ul>
</li>
<li>模板非类型参数：模板参数列表中表示一个值而非一个类型</li>
</ul>
<h3 id="函数模板">函数模板</h3>
<ul>
<li>模板实例化时，可以使用[[ch16-模板和泛型编程#函数模板显式实参|显式实参]]，根据实参[[ch16-模板和泛型编程#类型转换与模板类型参数|隐式推断模板参数类型]]</li>
<li>模板非类型参数：
<ul>
<li>可以是一个整型、指针或左值引用</li>
<li>实例化时，整型实参必须是常量表达式，指针/引用指向的对象必须有静态的生存周期（即对象不能是非static局部变量或动态对象），这样做可以使编译器在编译时实例化模板</li>
<li>使用场景：比如数组类型作为模板参数时大小固定，但是使用模板非类型参数就不必固定
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">M</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="n">T</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r1</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r2</span><span class="p">)[</span><span class="n">M</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">strcmp</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><code>inline</code>或<code>constexpr</code>的函数模板：模板参数列表之后，返回类型之前</li>
<li>模板编译
<ul>
<li>只有模板实例化时，编译器才生成代码</li>
<li>通常将类定义和函数声明放在头文件中，其实现放在源文件中；但是，函数模板和类模板成员函数的实现通常也放在头文件中。因为编译器知道模板的完整定义后才能进行实例化</li>
<li>大多数模板的编译错误在实例化期间才报告</li>
</ul>
</li>
</ul>
<h3 id="类模板">类模板</h3>
<ul>
<li>使用类模板必须提供显式模板参数列表，编译器不能推断模板参数类型</li>
<li>一个类模板的成员函数只有当程序用到它时，才进行<span id="类模板的实例化">实例化</span></li>
<li>使用类模板类型时必须提供模板参数，只有在类模板作用域内部才可以只使用模板名而不提供实参</li>
<li>友元相关，<a href="https://blog.csdn.net/caroline_wendy/article/details/16916441">例子</a>
<ul>
<li>如果一个类模板包含一个非模板友元，则友元可以访问该类模板的所有实例</li>
<li>如果一个类模板包含一个模板友元，则类可以授权给所有友元模板实例，也可以只授权给特定实例
<ul>
<li>一对一友好关系：友好关系被限定在相同类型的友元和类本身之间
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span> <span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Fri</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 比如Fri&lt;int&gt;实例可以访问MyClass&lt;int&gt;实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span> <span class="c1">// 友元函数，重载==
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="p">()</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span><span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span> <span class="nf">clone</span><span class="p">();</span> <span class="c1">// 处于类模板作用域中，编译器会将MyClass当作是MyClass&lt;T&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">clone</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">MyClass</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 一对一友好关系，Fri&lt;T&gt;是MyClass&lt;T&gt;的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">size</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 但是Fri&lt;T&gt;就不是MyClass&lt;K&gt;的友元(T!=K)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">char_class</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_class</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Fri</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fri</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">char_class</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// fri.func(int_class);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>    
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>通用和特定的模板友好关系：一个类可以将另一个模板的每个实例都声明为为自己的友元，或者限定特定的实例为友元
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Common</span><span class="p">{</span> <span class="c1">// 普通类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal</span><span class="p">;</span> <span class="c1">// 【Pal的所有实例】都是类Common的友元，此时Fri可以不用提前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span> <span class="c1">// 模板类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Fri</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 一对一友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">MyFri</span><span class="p">;</span> <span class="c1">// 【MyPal的所有实例】都是MyClass每个实例的友元，此时MyPal可以不用提前声明，且声明中使用了不同的模板参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Commom_fri</span><span class="p">;</span> <span class="c1">// 普通类作为模板类的友元，此时不需要提前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>      
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>虽然友元通常是类或函数，但是允许将模板类型参数<code>T</code>作为友元，因此类型<code>T</code>的对象可以访问类模板的private成员。<a href="https://blog.csdn.net/craftsman1970/article/details/81748184">例子</a>。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">T</span><span class="p">;</span> <span class="c1">// 类型T是MyClass的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">private_func</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;private func of MyClass &#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">func</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">test</span><span class="p">.</span><span class="n">private_func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">;</span> <span class="c1">// 类型Test是MyClass的友元，Test类型的对象可以访问【类模板MyClass基于Test类型的实例】的private成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Test</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>模板类型别名
<ul>
<li>为类模板的实例创建别名：<code>typedef MyClass&lt;int&gt; MC;</code></li>
<li>为类模板定义别名：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 固定一个类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>类模板的static成员
<ul>
<li>相同类型类模板的实例的static成员是共享的，不同类型之间类模板的实例的static成员是不同的</li>
</ul>
</li>
</ul>
<h3 id="模板参数">模板参数</h3>
<ul>
<li>模板内不能重用模板参数名，且同一个模板参数名<code>T</code>在同一个模板参数列表中只能出现一次</li>
<li>声明中的模板参数不必与定义中的模板参数相同，且模板声明通常一起放在文件开始位置（使用模板的代码之前）</li>
<li>使用<code>T::mem</code>，无法判断mem是类型T的static成员还是类型T的类型成员
<ul>
<li>普通类中编译器已知类的定义因此可以判断</li>
<li>默认<code>T::mem</code>访问的是static成员</li>
<li>使用<code>typename</code>显式说明访问的是类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">age</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">;</span> <span class="c1">// 类型成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="c1">// static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Person</span><span class="o">::</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;zhang&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">age</span> <span class="n">func</span><span class="p">(){</span> <span class="c1">// 显式说明T::age是一个类型而非static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">T</span><span class="o">::</span><span class="n">name</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 默认T::name是static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">age</span> <span class="n">myAge</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">myAge</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>默认模板实参：默认模板实参都在最右侧，对函数模板和类模板都可以提供默认模板实参</li>
</ul>
<h3 id="成员模板">成员模板</h3>
<ul>
<li>成员模板：普通类或模板类的成员函数是模板函数，成员模板不能是虚函数</li>
<li>普通类的成员模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span> <span class="c1">// 普通类中包含成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 普通类中的成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 对比模板类中的普通成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span> <span class="n">myClass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 普通类中的成员模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Test</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">test</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 模板类中的普通函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>类模板的成员模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">K</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">H</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 类模板的模板参数列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">H</span><span class="o">&gt;</span> <span class="c1">// 类模板的成员模板的模板参数列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">(</span><span class="n">H</span> <span class="n">h</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">H</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myClass</span><span class="p">(</span><span class="sc">&#39;k&#39;</span><span class="p">);</span> <span class="c1">// 显式提供T=int, 隐式推断K=char
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span> <span class="c1">// 隐式推断H=double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">myClass</span><span class="p">.</span><span class="n">func</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;str&#34;</span><span class="p">);</span> <span class="c1">// 显式提供H=string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="显式实例化">显式实例化</h3>
<ul>
<li>背景：模板只有使用时才被实例化，因此相同的实例可能出现在多个文件中，造成额外开销</li>
<li>显式实例化
<ul>
<li>当编译器遇到<code>extern</code>模板声明时，不会在本文件中生成模板的实例化代码，表示使用其他位置的实例化代码</li>
<li><code>extern</code>声明必须出现在使用此实例化版本的代码之前，否则编译器进行实例化，起不到外部定义的效果</li>
<li>显式实例化定义会实例化所有成员</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 在a.cpp中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 实例化声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="kt">int</span> <span class="n">compare</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 在b.cpp中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 实例化定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="效率与灵活性">效率与灵活性</h3>
<ul>
<li>shared_ptr在运行时绑定删除器，因此删除器保存为一个指针而不是一个成员，因此删除器的类型直到运行时才直到，而且可以随时改变删除器的类型
<ul>
<li>需要间接调用删除器，但是用户重载删除器的操作更加便捷（只需要传入一个可调用对象）</li>
</ul>
</li>
<li>unique_ptr在编译期绑定删除器，删除器的类型是类类型的一部分（因此删除器类型在编译器是已知的），从而删除器可以直接保存在成员中
<ul>
<li>避免了间接调用删除器的运行时开销</li>
</ul>
</li>
</ul>
<h2 id="162-函数模板实参推断">16.2 函数模板实参推断</h2>
<ul>
<li>可以[[ch16-模板和泛型编程#类型转换与模板类型参数|基于实参推导模板参数类型]]，也可以[[ch16-模板和泛型编程#函数指针和实参推断|函数指针指向函数模板推导模板参数类型]]</li>
<li>有时比如返回值类型无法推导出来，可以指定[[ch16-模板和泛型编程#函数模板显式实参|模板显式实参]]，也可以使用[[ch16-模板和泛型编程#尾置返回类型与类型转换|尾置返回类型]]（同时可以[[ch16-模板和泛型编程#尾置返回类型后进行类型转换|去除引用]]）</li>
<li>当模板类型<code>T</code>为引用时，需要依据实参是左值/右值来判断T的引用类型，而且可以使用完美转发保持实参的类型不变</li>
</ul>
<h3 id="类型转换与模板类型参数">类型转换与模板类型参数</h3>
<ul>
<li>模板实参推断：根据实参类型推断出模板参数<code>T</code>的类型
<ul>
<li>一般<code>T</code>就是实参类型</li>
<li>编译器会对以下几种实参进行类型转换，得到的<code>T</code>并不完全是实参类型
<ul>
<li>顶层<code>const</code>会被忽略</li>
<li>可以将非const对象的指针或引用传递给一个const的指针或引用形参</li>
<li>如果形参不是引用类型，数组名/函数名转换为指针类型</li>
</ul>
</li>
</ul>
</li>
<li><code>template&lt;typename T&gt; void func(T a, T b);</code>中，a和b推断的类型必须相同</li>
</ul>
<h3 id="函数模板显式实参">函数模板显式实参</h3>
<ul>
<li>背景：类型<code>T</code>只出现在返回值/函数体，不在形参列表中时，编译器无法推断出模板实参的类型：</li>
<li>函数模板显式实参从左到右进行对应，如果模板参数可以推导出来，放在模板参数列表右侧，实例化时可以进行推导</li>
<li>当显式指定实参时，对实参可以使用正常的类型转换</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span> <span class="n">T1</span> <span class="n">sum</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">);</span> <span class="c1">// T1在返回值中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="kt">double</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// T1类型是long long, T2、T3类型可以推导出来，放在右侧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">test</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// T2类型显式指定为long long，因此将a转换为long long型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">compare</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// 使用显式模板实参，a、b都转换为long long类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="尾置返回类型与类型转换">尾置返回类型与类型转换</h3>
<h4 id="尾置返回类型">尾置返回类型</h4>
<ul>
<li>背景：有时函数模板的返回值类型不能由实参推导而来，比如[[ch16-模板和泛型编程#函数模板显式实参|函数模板显式实参]]的背景
<ul>
<li>可以使用函数模板显式实参进行指定，也可以<strong>使用尾置返回类型自动推导</strong></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="n">Iter</span> <span class="n">beg</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">){</span> <span class="c1">// 从局部变量中推导出返回类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="尾置返回类型后进行类型转换">尾置返回类型后进行类型转换</h4>
<ul>
<li>背景：通过模板显式实参可以指定返回值类型，但是通过尾置返回类型推导得到的类型可能不是想要的，比如有时不希望得到引用类型</li>
<li><strong>标准库的类型转换模板</strong>
<ul>
<li>定义在头文件<code>type_traits</code>中，常用于模板元程序设计</li>
<li>Mod是一个类模板，将类型<code>T</code>转换为类型<code>type</code>；如果无法转化，则类型<code>type</code></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="n">Iter</span> <span class="n">beg</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">{</span> <span class="c1">// 表明type是一个类型而非一个static成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th><code>Mod</code></th>
<th><code>T</code></th>
<th><code>Mod&lt;T&gt;::type</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_const</code></td>
<td><code>X&amp;</code>或<code>const X</code>或函数</td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>const T</code></td>
</tr>
<tr>
<td><code>add_lvalue_reference</code></td>
<td><code>X&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td><code>X&amp;&amp;</code></td>
<td><code>X&amp;</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;</code></td>
</tr>
<tr>
<td><code>add_rvalue_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;&amp;</code></td>
</tr>
<tr>
<td><code>remove_pointer</code></td>
<td><code>X*</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_pointer</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X*</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T*</code></td>
</tr>
<tr>
<td><code>make_signed</code></td>
<td><code>unsigned X</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>make_unsigned</code></td>
<td>带符号类型</td>
<td><code>unsigned X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_extent</code></td>
<td><code>X[n]</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_all_extents</code></td>
<td><code>X[n1][n2]...</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<h3 id="函数指针和实参推断">函数指针和实参推断</h3>
<ul>
<li>将函数模板赋值给函数指针：
<ul>
<li>函数指针指向函数模板的一个实例</li>
<li>使用函数指针的类型来推断模板实参</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>  <span class="c1">// T是int，f指向函数模板的实例compare(const int&amp;, const int&amp;)
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果函数func的形参是函数指针，实参可以传入函数模板，这样函数指针指向一个模板实例且进行了参数推断
<ul>
<li>但是当func有多个重载的版本时（接受不同类型的函数指针），传入函数模板可能产生歧义，此时可以指定【显式模板实参】</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">));</span> <span class="c1">// 重载
</span></span></span><span class="line"><span class="cl"><span class="c1">// func(compare); // 歧义：函数模板compare实例化为哪一种函数指针？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">func</span><span class="p">(</span><span class="n">compare</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="模板实参推断和引用">模板实参推断和引用</h3>
<h4 id="模板参数t的类型推断">模板参数<code>T&amp;</code>的类型推断</h4>
<table>
<thead>
<tr>
<th style="text-align:center">模板类型参数</th>
<th style="text-align:center">实参要求</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>T&amp;</code></td>
<td style="text-align:center">必须传递一个左值</td>
<td style="text-align:center">实参为<code>int</code>，<code>T</code>为<code>int</code>;实参为<code>const int</code>，<code>T</code>为<code>const int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>const T&amp;</code></td>
<td style="text-align:center">可以传递左值或右值</td>
<td style="text-align:center">实参为<code>int, const int, const int&amp;&amp;</code>，<code>T</code>都为<code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>T&amp;&amp;</code></td>
<td style="text-align:center">必须传递一个右值</td>
<td style="text-align:center">实参为<code>int&amp;&amp;</code>， <code>T</code>为<code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>T&amp;&amp;</code></td>
<td style="text-align:center">例外：传递一个类型为<code>type</code>的左值，推导<code>T</code>为<code>type&amp;</code>类型</td>
<td style="text-align:center">实参为<code>int&amp;</code>,<code>T</code>为<code>int&amp;</code></td>
</tr>
</tbody>
</table>
<h4 id="引用折叠">引用折叠</h4>
<ul>
<li>背景：基于上面这个例外，创造出了引用的引用，或者通过类型别名也可以创造出引用的引用，可以将多个引用折叠为一个引用</li>
<li>引用折叠规则：
<ul>
<li><code>type&amp; &amp;、 type&amp; &amp;&amp;、 type&amp;&amp; &amp;</code>折叠为<code>type &amp;</code></li>
<li><code>type&amp;&amp; &amp;&amp;</code>折叠为<code>T&amp;&amp;</code></li>
</ul>
</li>
<li>使用：
<ul>
<li>若函数形参是<code>T&amp;&amp;</code>，则可以传递一个左值（实参的const属性可以保持，因为是底层const）</li>
<li>如果传入的是左值<code>type&amp;</code>，推导出<code>T=type&amp;</code></li>
<li>万能引用（或称为模板类型参数右值引用）：函数形参为<code>T&amp;&amp;</code>时，传递左值/右值均可
<ul>
<li>使用万能引用导致只有在运行时才能确定形参是左值还是右值，使得模板的编写变得困难</li>
<li>通常在两种情况中使用万能引用：模板转发实参，模板重载</li>
<li>使用万能引用的形参通常重载为两个版本：
<ul>
<li>拷贝版本：<code>template&lt;typename T&gt; void f(const T&amp;)</code>  绑定到左值和const右值</li>
<li>移动版本：<code>template&lt;typename T&gt; void f(T&amp;&amp;)</code> 绑定到非const右值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="stdmove"><code>std::move</code></h4>
<ul>
<li>[[ch13-拷贝控制#^d3a2a0|std::move函数]]的定义：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>可以使用<code>static_cast</code>显式地将左值转换为右值引用</li>
</ul>
<h3 id="转发">转发</h3>
<ul>
<li>背景：比如函数f内部调用函数g时，可能需要将f的实参传递给g，而且同时要求保持实参性质不变（比如const属性，左值/右值属性）
<ul>
<li>即希望达到这样的效果：将实参传递给f，再传递给g，与实参直接传递给g，的效果等价</li>
<li>例子一：f形参类型是非引用，g形参类型是左值引用，传入一个左值引用，则此时f转发参数给g时会使用自己的拷贝而非原来的引用</li>
<li>例子二：f形参类型是万能引用<code>T&amp;&amp;</code>，g形参类型是右值引用，f可以接受右值（或左值），此时f转发参数给g时，使用的右值引用本身是一个左值，不能传参给g的右值引用</li>
</ul>
</li>
<li>比较：都是定义在<code>utility</code>中的函数模板，最好显式指明是<code>std::</code>中的
<ul>
<li><code>std::forward</code>：可指定模板参数，并且可以对返回值使用引用折叠来保留左右值属性</li>
<li><code>std::move</code>：返回值一定是右值引用</li>
</ul>
</li>
<li>使用：完美转发
<ul>
<li>通过万能引用在传入外层f时保留实参的全部属性</li>
<li>通过<code>std::forward</code>在传入内层函数g时再次保留实参的全部属性</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">arg</span><span class="p">){</span> <span class="c1">// 万能引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span> <span class="c1">// std::forward&lt;T&gt;的返回类型是T&amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果实参是左值，推导出<code>T=type&amp;</code>，<code>std::forward&lt;T&gt;</code>的返回类型<code>T&amp;&amp;</code>折叠为<code>type&amp;</code></li>
<li>如果实参是右值，推导出<code>T=type</code>，<code>std::forward&lt;T&gt;</code>的返回类型即为<code>type&amp;&amp;</code></li>
</ul>
</li>
<li>例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">flip</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">K</span> <span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34;  &#34;</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">flip</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// F=void(*)(int&amp;&amp;, int&amp;), T=int&amp;, K=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">flip</span><span class="p">(</span><span class="n">g</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// F=void(*)(int&amp;&amp;, int&amp;), T=int&amp;, K=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="163-重载与模板">16.3 重载与模板</h2>
<ul>
<li>函数模板可以被另一个函数模板或普通函数重载
<ul>
<li>[[ch06-函数#6.6 函数匹配|函数的重载与匹配]]：有一些重载的函数，根据实参情况，调用时用哪个函数？</li>
<li>函数模板的重载与匹配：有一些重载的函数模板和普通函数，根据实参情况（函数模板进行函数模板实参推断），实例化并调用哪个函数模板</li>
</ul>
</li>
<li>到函数模板的函数匹配规则（[[ch06-函数#6.6 函数匹配|普通函数匹配的拓展]]）
<ul>
<li>确定候选函数：同名的函数，包括实参推断成功的函数模板实例</li>
<li>确定可行函数：参数类型和数量都匹配，
<ul>
<li>候选的函数模板实例都是可行的，因为实参推断会排除掉不可行的模板</li>
</ul>
</li>
<li>按照类型转换进行排序，寻找最佳匹配（普通函数和函数模板实例都可能发生类型转换，只是应用于函数模板的[[ch16-模板和泛型编程#类型转换与模板类型参数|类型转换]]十分有限）
<ul>
<li>若恰有一个函数提供比其他函数都好的匹配，则选择它</li>
<li>如果多个函数都提供相同级别的匹配
<ul>
<li>非模板和模板重载：如果只有一个是非模板函数，选择非模板函数</li>
<li>多个可行模板：如果没有非模板函数（有多个函数模板），选择最特例化的函数模板（特例化：比如<code>T&amp;</code>可以匹配任意类型，<code>T*</code>只能匹配指针类型）</li>
<li>调用有歧义，失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最佳实践：在定义重载函数之前，应该先声明所有重载的版本，否则可能重载一个模板函数进行实例化（因为没有找到想使用的版本，使用函数模板进行实例化），编译期不会报错，但是运行期会调用不期望使用的版本</li>
</ul>
<h2 id="164-可变参数模板">16.4 可变参数模板</h2>
<ul>
<li><strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类，可变数目的参数被称为<strong>参数包</strong>
<ul>
<li>模板参数包：表示零个或多个模板参数（模板类型参数或模板非类型参数）
<ul>
<li><code>typename</code>后跟<code>...</code>表示模板类型参数包</li>
<li>类型名后跟<code>...</code>表示模板非类型参数包</li>
</ul>
</li>
<li>函数参数包：表示零个或多个函数参数。</li>
</ul>
</li>
<li><code>sizeof...</code>运算符：返回参数包中的元素数量，且不会对其实参求值（类似于sizeof）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span> <span class="c1">// 模板参数包：Args是模板类型参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="p">...</span> <span class="n">rest</span><span class="p">){</span>  <span class="c1">// 函数参数包：rest是函数参数包（其类型是模板参数包Args）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">rest</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="编写可变参数函数模板">编写可变参数函数模板</h3>
<ul>
<li>[[ch06-函数#可变形参|可变形参]]<code>initializer_list</code>可以接受可变数目实参，但是需要是相同类型的</li>
<li>可变参数函数通常是递归的
<ul>
<li>第一步调用处理参数包中的第一个实参，然后用剩余实参调用自身</li>
<li>还需要定义一个非可变参数的函数（因为函数匹配时会使用这个更加特例化的版本，而不是使用0个参数的可变参数模板的实例），来处理参数包中最后一个实参</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="c1">// 打印最后一个元素，用来终止递归，必须在可变参数版本的print定义之前声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rest</span><span class="p">...);</span>   <span class="c1">// 递归调用，实参是将除了第一个，剩余的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="包扩展">包扩展</h3>
<ul>
<li>扩展<code>...</code>：将参数包分解为单个元素，每个元素应用模式，得到拓展后的列表</li>
<li>常用情况：
<ul>
<li><code>const Args&amp; ...</code>：将模板参数包<code>Args</code>中所有类型<code>T</code>都扩展为<code>const T&amp;</code></li>
<li><code>args...</code>：将函数参数包<code>args</code>扩展为参数列表</li>
<li><code>f(args)...</code>：对函数参数包<code>args</code>中每个元素调用函数<code>f</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">){</span> <span class="c1">// 扩展模板参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">debug_reg</span><span class="p">(</span><span class="n">rest</span><span class="p">)...);</span> <span class="c1">// 扩展函数参数包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="转发参数包">转发参数包</h3>
<ul>
<li>组合使用可变参数模板和<code>forward</code>机制，实现将可变参数的完美转发，例子：<code>emplace_back</code></li>
<li>如果同时存在模板参数包和函数参数包，则同时拓展：
<ul>
<li><code>f&lt;Args&gt;(args)...</code>等价于<code>f&lt;Args1&gt;(args1), f&lt;Args2&gt;(args2), ... </code></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">work</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="165-模板特例化specializations">16.5 模板特例化（Specializations）</h2>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=03b4a1a4-b85a-ef1b-901a-178f5542609b&amp;page=650&amp;rect=86.880,83.040,255.996,90.480">背景和例子</a>：对于某个类型，不想用（对特定类型可以做优化）或者不能用（对特定类型的使用并非预期）模板</li>
</ul>
<h3 id="定义函数模板特例化">定义函数模板特例化</h3>
<ul>
<li>必须为原模板中每个模板参数都提供实参（全特例化）</li>
<li>关键字<code>template</code>后面跟一个空尖括号对（<code>&lt;&gt;</code>），表示所有模板参数都已被指定</li>
<li>特例化版本的参数类型必须与一个先前声明的模板中对应的类型相匹配。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">// T为const char*
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="函数重载与模板特例化">函数重载与模板特例化</h3>
<ul>
<li>特例化的本质是实例化一个模板，而不是重载它。因此特例化不影响[[ch16-模板和泛型编程#16.3 重载与模板|函数的匹配规则]]，即非模板函数先，再是特例化版本的函数（模板的实例化），最后是函数模板的实例</li>
<li>最佳实践：模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是特例化版本。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span> <span class="c1">// 特例化版本，T为const char*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span> <span class="c1">// 普通函数
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="类模板特例化">类模板特例化</h3>
<ul>
<li>必须在原模板定义所在的命名空间中进行类模板特例化</li>
<li>类模板可以进行部分特例化（偏特例化），得到的是模板；也可以全部特例化（全特例化），得到的是实例</li>
<li>类模板的部分特例化
<ul>
<li>未完全确定类型的模板参数仍放在<code>&lt;&gt;</code>中，即偏特化的模板参数列表非空。使用时也需提供模板实参，这些实参与原始模板中的参数按位置对应</li>
<li>部分特例化的模板参数列表是原始模板参数列表的一个子集或者特例化版本</li>
<li>例子：标准库remove_reference类型是通过一系列的特例化版本来完成其功能的
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//原始的、最通用的版本，可用于任意类型实例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span> <span class="p">{</span>  <span class="c1">//针对于左值引用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span> <span class="p">{</span> <span class="c1">//针对于右值引用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//调用原始模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">a</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//decltype(i)==int&amp;，调用第一个（T&amp;）部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">b</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//decltype(std::move(i))==int&amp;&amp;，调用第二个（T&amp;&amp;）部分特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">c</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//a、b、c均为int
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>特例化成员函数而不是整个类
<ul>
<li>使用模板的实例调用成员时，若该实例的模板实参与特化该成员时的参数一致，则调用特化版本的成员</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="p">())</span> <span class="o">:</span><span class="n">mem</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span> <span class="c1">//通用的Bar()函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">T</span> <span class="n">mem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//特例化Foo&lt;int&gt;版本的的成员Bar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Bar</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">fs</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">fs</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>       <span class="c1">//使用Foo&lt;string&gt;的通用的Bar()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fi</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="n">fi</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>       <span class="c1">//使用Foo&lt;int&gt;的特例化的Bar()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch15 面向对象程序设计</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:30 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</guid>
      <description>第十五章 面向对象程序设计 OOP的核心思想是多态性（polymorphism）。 多态即具有继承关系的多个类型 引用或指针的静态类型与动态类型不同</description>
      <content:encoded><![CDATA[<h1 id="第十五章-面向对象程序设计">第十五章 面向对象程序设计</h1>
<p>OOP的核心思想是多态性（polymorphism）。</p>
<ul>
<li>多态即具有继承关系的多个类型</li>
<li>引用或指针的静态类型与动态类型不同是C++支持多态的根本</li>
</ul>
<p>本章内容：</p>
<ul>
<li>基类与派生类语法及其类型转换</li>
<li>虚函数、纯虚函数、抽象基类</li>
<li>访问控制：成员访问控制、派生访问控制、using声明</li>
<li>继承过程中的函数解析和作用域</li>
<li>继承过程中的构造函数和（合成）拷贝控制成员</li>
</ul>
<h2 id="151-oop概述">15.1 OOP：概述</h2>
<ul>
<li>基类，派生类、类派生列表</li>
<li>[[ch15-面向对象程序设计#15.3 虚函数|虚函数]]：基类将函数声明为虚函数，派生类定义适合自己的版本</li>
<li><strong>动态绑定</strong>（dynamic binding，又称运行时绑定）：
<ul>
<li>使用基类的引用或指针调用一个虚函数时将发生动态绑定（即在运行时，根据传入参数的类型选择函数版本）</li>
</ul>
</li>
</ul>
<h2 id="152-定义基类和派生类">15.2 定义基类和派生类</h2>
<h3 id="定义基类">定义基类</h3>
<ul>
<li>如果函数希望被派生类覆盖，则基类将其定义为虚函数；否则基类中的函数希望派生类直接继承而且不要改变</li>
<li>基类中的虚函数 ^ae3c55
<ul>
<li>基类通常都应该定义一个【虚析构函数】，即使该函数不执行任何实际操作。</li>
<li>除构造函数之外的任何非静态函数都可以定义为虚函数</li>
<li>如果基类把一个函数声明为虚函数，则该函数在派生类中隐式的也是虚函数</li>
</ul>
</li>
<li>[[ch15-面向对象程序设计#^8deb68|访问控制]]</li>
</ul>
<h3 id="定义派生类">定义派生类</h3>
<ul>
<li>【类派生列表中的访问说明符】用于控制【派生类从基类继承而来的成员】是否【对派生类的对象】可见
<ul>
<li>派生类必须将继承而来的成员函数中需要覆盖的那些重新声明</li>
<li>如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分，因此可以将派生类类型的对象绑定到基类的指针或引用上</li>
</ul>
</li>
<li>派生类中的虚函数 ^91e48b
<ul>
<li>如果派生类没有覆盖基类中的某个虚函数，则派生类会直接继承其在基类中的版本</li>
<li>派生类必须在其内部对所有重新定义的虚函数进行声明，virtual关键字可加可不加</li>
<li>派生类中覆盖虚函数时，形参类型和返回值类型必须相同
<ul>
<li>返回值不相同只有一个例外：虚函数返回类型是类本身的指针或引用，比如类Base派生出类Derived，则基类Base的虚函数返回值可以返回<code>*Base</code>，而派生类Derived中覆盖的虚函数可以返回<code>*Derived</code></li>
</ul>
</li>
<li>C++11使用<code>override</code>显式指明重新定义虚函数（<code>override</code>放在引用限定符之后）</li>
</ul>
</li>
<li>派生类到基类的类型转换
<ul>
<li>基类与派生类之间的[[#类型转换与继承]]</li>
<li>[[ch15-面向对象程序设计#^ec492b|派生类向基类转换的可访问性]]</li>
</ul>
</li>
<li>派生类构造函数：每个类控制自己的成员初始化过程
<ul>
<li>派生类必须使用【基类的构造函数】来初始化它的基类部分，【派生类的构造函数】通过【[[ch07-类#^742596|构造函数初始值列表]]】来将实参传递给【基类构造函数】，同时在【构造函数初始值列表】初始化自己的数据成员</li>
<li>遵循基类的接口，尽管从语法上可以在派生类中给基类的公有成员直接进行赋值</li>
<li>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化</li>
<li>顺序：先初始化基类部分，在按声明顺序依次初始化派生类的成员</li>
</ul>
</li>
<li>静态成员
<ul>
<li>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一实例。</li>
<li>静态成员遵循通用的访问控制规则</li>
</ul>
</li>
<li>派生类的声明中不包含它的派生列表，派生列表必须于派生类的定义一起出现</li>
<li>如果想用某个类作为基类，该类必须已经定义而非仅仅声明
<ul>
<li>一个类不能派生它本身</li>
<li>直接基类与间接基类：派生类构造函数只初始化它的直接基类</li>
</ul>
</li>
<li>防止继承：在类名后面跟一个关键字<code>final</code>。
<ul>
<li>final关键字除了防止继承，还可以防止函数被覆盖</li>
</ul>
</li>
</ul>
<h3 id="类型转换与继承">类型转换与继承</h3>
<ul>
<li>可以将【指向基类的指针/引用】绑定到派生类对象上，因此【指向基类的指针/引用】的静态类型与动态类型可能不一致
<ul>
<li>静态类型：变量或表达式类型在编译时已知</li>
<li>动态类型：变量或表达式类型在运行时才可知，是指针指向的内存中对象的类型</li>
</ul>
</li>
<li>编译器自动将【指向派生类的指针/引用】转换为【指向基类的指针/引用】</li>
<li>不存在【指向基类的指针/引用】隐式转换到【指向派生类的指针/引用】
<ul>
<li>除了使用强制类型转换：使用<code>dynamic_cast</code>，将【指向基类的指针/引用】安全的转换成【指向派生类的指针/引用】，将在运行期进行安全检查</li>
<li>如果已知某个基类到派生类的转换是安全的，可以使用<code>static_cast</code>强制覆盖掉编译器的检查工作</li>
</ul>
</li>
<li>派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。
<ul>
<li>如果表达式不是引用/指针，则它的静态类型与动态类型永远一致</li>
<li>有时确实希望将派生类对象转换成基类类型，派生类的部分被切掉(sliced down)了</li>
</ul>
</li>
</ul>
<h2 id="153-虚函数">15.3 虚函数</h2>
<ul>
<li>[[ch15-面向对象程序设计#^ae3c55|基类中的虚函数]]</li>
<li>[[ch15-面向对象程序设计#^91e48b|派生类中的虚函数]]</li>
<li>virtual关键字只能出现在类内部的声明语句，而不能用于类外部的函数定义</li>
<li>必须为每一个虚函数提供定义，不管是否被用到（因为编译器也无法确定哪个虚函数会被使用）</li>
<li>默认实参
<ul>
<li>如果虚函数中有默认实参，则默认实参的值由本次调用的指针/引用的静态类型决定</li>
<li>因此可能使用的是基类中的默认实参，但是实际运行的是派生类的虚函数版本</li>
<li>最好基类和派生类中的默认实参一致</li>
</ul>
</li>
<li>回避虚函数：对虚函数的调用不要进行动态绑定，而强迫执行虚函数的某个版本
<ul>
<li>使用<strong>作用域运算符</strong>（<code>::</code>）来回避虚函数</li>
<li>通常，只有成员函数（或友元）中才需要使用使用回避虚函数的机制，比如一个派生类的虚函数调用它覆盖的基类的虚函数版本（如果不使用回避机制，在运行时该调用将被解析为派生类版本自身的调用，导致无限循环递归）</li>
<li>例子：<code>Derived* p = Derived(); p-&gt;Base::func();</code></li>
</ul>
</li>
</ul>
<h2 id="154-抽象基类">15.4 抽象基类</h2>
<ul>
<li>纯虚函数：一个没有意义的虚函数
<ul>
<li>纯虚函数无需定义，或者也可以提供定义，但是函数体必须定义在类的外部</li>
<li>声明时末尾加上<code>=0</code>将函数声明为纯虚函数，且只能出现在类内部的函数声明中</li>
</ul>
</li>
<li>抽象基类
<ul>
<li>含有（或未经覆盖直接继承）纯虚函数的类
<ul>
<li>如果派生类不覆盖抽象基类中的纯虚函数，则该派生类仍然是抽象基类</li>
</ul>
</li>
<li>抽象基类负责定义接口，后续的其他类可以覆盖该接口</li>
<li>不能创建抽象基类的对象。</li>
</ul>
</li>
</ul>
<h2 id="155-访问控制与继承">15.5 访问控制与继承</h2>
<ul>
<li>派生类中继承而来的成员的访问权限受到两个因素影响：基类中成员的访问控制（<strong>成员访问说明符</strong>）、类派生列表中的访问控制（<strong>派生访问说明符</strong>）
<ul>
<li>基类中成员的访问控制 ^8deb68
<ul>
<li><code>public</code>：基类本身、派生类、友元、类对象都可以访问</li>
<li><code>protected</code> ： 基类本身、派生类、友元可以访问，类对象无法访问
<ul>
<li>派生类和友元可以通过派生类对象访问基类的protected成员，但是不能直接通过基类对象来访问。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=af2c58f1-ba76-b811-d0dc-29291dabce5c&amp;page=569&amp;rect=166.478,559.210,246.731,566.890">例子</a>。</li>
</ul>
</li>
<li><code>private</code> ： 基类本身、友元可以访问，其他都无法访问</li>
</ul>
</li>
<li>类派生列表中的访问控制：基类中public/protected的成员，在派生类中的访问说明符
<ul>
<li>如果继承是public的，则成员遵循原来的访问说明符</li>
<li>如果继承是private的，则派生类中【从基类中继承而来的成员】是private的</li>
<li>如果继承是protected的，则派生类中【从基类中继承而来的成员】是protected的</li>
</ul>
</li>
</ul>
</li>
<li>派生类向基类转换的可访问性 ^ec492b
<ul>
<li>总体原则：对于继承树中的某个节点，如果基类的共有成员是可以访问的，则派生类可以向基类进行类型转换；反之则不行。<a href="https://blog.csdn.net/monster_acm/article/details/81200777">示例说明</a>。</li>
<li>只有当继承是public的时，派生类才能转换到基类（基类指针指向派生类对象）</li>
<li>不管D以什么方式继承B，【D的成员函数和友元函数】中【派生类D可以转换到直接基类B】</li>
<li>如果D继承B的方式是public的或protected的，则【D派生类的成员和友元】可以使用【D向B的类型转换】；反之如果是私有的，则不能使用</li>
</ul>
</li>
<li>友元关系是单向的，不具有传递性，且不能继承
<ul>
<li>如果Pal是基类Base的友元，则Pal可以访问Base的对象的成员和派生类Derived中属于Base部分的成员</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">protected_val</span><span class="p">;</span> <span class="c1">// 每个类负责控制自己成员的访问权限，protected_val访问权限由Base控制（即使Base是内嵌在派生类对象中）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="k">class</span> <span class="nc">PPal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">de_protected_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Pal</span><span class="p">{</span> <span class="c1">// 基类的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">f</span><span class="p">(</span><span class="n">Derived</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">protected_val</span><span class="p">;}</span> <span class="c1">// protected_val的访问控制权限由Baes控制，这种可访问性包括了Base对象内嵌在其派生类对象中的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="n">Derived</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">de_protected_val</span><span class="p">;}</span> <span class="c1">// error: 基类的友元不能随便访问派生类的成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DPal</span><span class="o">:</span> <span class="k">public</span> <span class="n">Pal</span><span class="p">{</span> <span class="c1">// 【基类友元】的派生类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">k</span><span class="p">(</span><span class="n">Derived</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">protected_val</span><span class="p">;}</span> <span class="c1">// error：友元关系不能继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PPal</span><span class="p">{</span> <span class="c1">// 派生类的友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">h</span><span class="p">(</span><span class="n">Derived</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">protected_val</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>改变派生类个别成员的可访问性：使用<code>using</code>。 ^f2ba1c
<ul>
<li>将基类的public/protected成员使用using进行标记，放在派生类public/protected/private的位置，就获得了相应的访问级别</li>
<li>派生类只能针对基类的public/protected成员使用using声明改变可访问性（因为派生类无法访问基类的private成员）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">pub_func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="nf">pub_func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">pro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">pri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">private</span> <span class="n">Base</span><span class="p">{</span> <span class="c1">// Derived中从基类Base中继承而来的成员默认都是private的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">pub_func</span><span class="p">;</span> <span class="c1">// 使用using声明，两个重载的pub_func现在都被添加，都是public的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">pro</span><span class="p">;</span> <span class="c1">// 使用using声明，pro现在是protected的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 派生类无法访问到基类的private成员    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>class</code>与<code>struct</code>
<ul>
<li>默认使用<code>clas</code>定义的类成员是private的，使用<code>struct</code>定义的类成员是public的</li>
<li>默认使用<code>class</code>定义的派生类是私有继承的，使用<code>struct</code>定义的派生类是公有继承的。</li>
<li>除此之外再无不同</li>
</ul>
</li>
</ul>
<h2 id="156-继承中的类作用域">15.6 继承中的类作用域</h2>
<ul>
<li>派生类的作用域嵌套在其基类的作用域之内</li>
<li>函数调用的解析过程：<code>p-&gt;mem()</code>或者<code>obj.mem()</code>
<ol>
<li>确定p或obj的静态类型</li>
<li>名字查找：在该静态类型对应的类中查找mem，如果找不到，则依次在直接继承中不断查找，直到继承链的顶端</li>
<li>类型检查：假如找到mem，进行常规的类型检查，以确认本次调用是否合法</li>
<li>假如合法，编译器根据调用的是否为虚函数产生不同的代码：
<ul>
<li>mem是虚函数且通过指针或引用来调用：编译器产生的代码将在运行时确定到底是运行该虚函数的哪个版本，依据是对象的动态类型</li>
<li>mem不是虚函数或者通过对象进行调用：产生一个常规的函数调用</li>
</ul>
</li>
</ol>
</li>
<li>函数调用的解析过程导致的现象：
<ul>
<li>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的
<ul>
<li>比如将基类指针绑定到派生类，基类指针静态类型是指向基类（因此无法调用派生类特有的成员），但是动态类型是指向派生类</li>
</ul>
</li>
<li>派生类的成员将隐藏同名的基类成员，即使成员函数形参列表不同
<ul>
<li>可以使用域运算符<code>::</code>使用被隐藏的基类成员</li>
<li>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</li>
<li>派生类中继承来的虚函数要保持相同的参数列表，否则派生类定义的是一个新函数，该新函数不是虚函数</li>
</ul>
</li>
<li>虚函数解析过程：
<ul>
<li>在编译期，基类指针在静态类型中进行名字查找和类型检查</li>
<li>在运行期，根据动态类型决定运行虚函数的哪个版本</li>
</ul>
</li>
</ul>
</li>
<li>覆盖重载的函数：
<ul>
<li>派生类可以覆盖重载函数的0个或多个版本</li>
<li>如果派生类希望所有的重载版本对它来说都是可见的，那么就需要覆盖所有的版本，或者一个也不覆盖（因此到基类中寻找名字）</li>
<li>如果像重写一部分而非全部，可以使用using声明将同名的重载版本都添加到派生类作用域中，然后再重写</li>
<li>根本原因还是相应静态类型中查找到名字后但是类型不匹配，如果只覆盖一部分相当于重载版本变少了</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Base 1&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Base 2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Base 3&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">D1</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;D1 &#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 只覆盖一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">D2</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 一个都不覆盖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">D3</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;D3 2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">D1</span> <span class="n">d1</span><span class="p">;</span> <span class="n">D2</span> <span class="n">d2</span><span class="p">;</span> <span class="n">D3</span> <span class="n">d3</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="c1">//  d1.f(1); // 报错：因为d1静态类型为D1，D1中有函数f，但是类型检查失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">d2</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Base 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">d3</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// D3 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//  D1* p = &amp;d1; // 这样定义就错，原因同上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Base</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">;</span> <span class="c1">// p的静态类型为Base，Base中有函数f(int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">p</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Base 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>重载、重写（覆盖）与隐藏，<a href="https://www.cnblogs.com/sunbines/p/9130227.html">参考</a>
<ul>
<li>重载：同一作用域内的几个函数同名但是形参列表不同</li>
<li>隐藏：派生类中的函数屏蔽了与其同名的基类函数，不管参数列表是否相同</li>
<li>重写（覆盖）：虚函数重写</li>
</ul>
</li>
</ul>
<h2 id="157-构造函数与拷贝控制">15.7 构造函数与拷贝控制</h2>
<h3 id="虚析构函数">虚析构函数</h3>
<ul>
<li>基类通常应该定义一个虚析构函数，这样最终执行动态类型版本的析构函数</li>
<li>一般来说，如果一个类需要析构函数，那么它也需要拷贝和赋值操作，但是基类的析构函数不遵循该规则</li>
<li>虚析构函数将阻止使用合成的移动操作，即使使用<code>=default</code>显式声明</li>
</ul>
<h3 id="合成的拷贝控制与继承">合成的拷贝控制与继承</h3>
<ul>
<li>派生类的合成拷贝控制成员，通过调用基类的合成拷贝控制成员，来对基类部分进行相应的拷贝、移动、销毁等操作</li>
<li>某些定义基类的方式可能导致部分派生类成员成为被删除的函数：
<ul>
<li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或者不可访问的函数，则派生类中对应的成员也会是被删除的。</li>
<li>如果基类的析构函数是被删除的或者不可访问的，则派生类中合成的默认和拷贝构造函数也会是被删除的。</li>
<li>如果基类的移动操作是删除的，则派生类中对应的函数也是删除的。</li>
<li>在实际编程中，如果基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。</li>
</ul>
</li>
<li>移动操作与继承
<ul>
<li>大多数基类都会定义一个虚析构函数，因此基类通常没有合成的移动操作</li>
<li>如果需要移动操作，首先在基类中定义，之后派生类会自动合成移动操作</li>
</ul>
</li>
</ul>
<h3 id="派生类的拷贝控制成员">派生类的拷贝控制成员</h3>
<ul>
<li>当派生类定义了拷贝或移动操作时，该操作通过调用基类的对应成员，来拷贝或移动包括基类在内的整个对象。</li>
<li>与拷贝和移动操作不同，派生类的析构函数只负责销毁由派生类自己分配的资源，对象销毁的顺序与创建顺序相反</li>
<li>在构造函数和析构函数中尽量不要调用虚函数：<a href="https://zhuanlan.zhihu.com/p/424508028#:~:text=%E9%A6%96%E5%85%88%E7%BB%99%E5%87%BA%E7%AD%94%E6%A1%88%EF%BC%9A%20%E5%9C%A8C%2B%2B,primer%E4%B8%AD%E8%AF%B4%E5%88%B0%E8%BF%87%E6%98%AF%E6%9C%80%E5%A5%BD%20%E4%B8%8D%E8%A6%81%E8%B0%83%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%AF%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%EF%BC%8C%20%E6%89%80%E4%BB%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B7%9F%E8%99%9A%E6%9E%84%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%E9%83%BD%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E4%BC%9A%E6%8A%A5%E9%94%99%E3%80%82">例子</a>。
<ul>
<li>比如在进行基类的初始化时，调用了派生类版本的虚函数，但是此时派生类还未进行初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// 构造函数中调用虚函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Base</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="p">(</span><span class="n">Base</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Base</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="n">Base</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Base&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="p">()</span><span class="o">:</span> <span class="n">Base</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="p">(</span><span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// 使用基类的构造函数初始化对象的基类部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Derived</span><span class="p">(</span><span class="n">Derived</span><span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">Base</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">// 使用基类的拷贝赋值运算符赋值对象的基类部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="cm">/* do something*/</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Derived</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/*销毁派生类自己分配的资源*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Derived&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Derived</span> <span class="n">d</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 先构造基类部分，此时派生类部分还未创建，基类构造函数中使用的是Base::func()
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="继承的构造函数">继承的构造函数</h3>
<ul>
<li>背景
<ul>
<li>如果基类有多个不同的构造函数，那么派生类也需要相应实现多个构造函数，<a href="https://blog.csdn.net/K346K346/article/details/81703914">参考</a></li>
<li>派生类不能继承默认、拷贝、移动构造函数，派生类如果没有直接定义这些构造函数，编译器会为派生类合成</li>
</ul>
</li>
<li>派生类可以使用using声明重用基类的构造函数，编译器在派生类中生成一个形参列表完全相同的构造函数，派生类自己的数据成员被默认初始化
<ul>
<li>和普通的using声明不一样（可以[[ch15-面向对象程序设计#^f2ba1c|改变派生类个别成员的可访问性]]），构造函数的using声明不会改变构造函数的访问声明符</li>
<li>如果基类构造函数是<code>explict</code>的或<code>constexpr</code>的，则重用的构造函数也拥有相同的属性</li>
<li>如果一个基类构造函数含有默认实参，这些实参并不会被直接继承，派生类会获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。</li>
<li>基类有几个构造函数，派生类会重用所有的这些构造函数，除了两个例外：
<ul>
<li>派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本：如果派生类定义的构造函数与重用基类的构造函数具有相同的参数列表，则派生类中的构造函数将替换重用的基类构造函数</li>
<li>默认、拷贝和移动构造函数不会被继承，这些构造函数按照正常规则被合成</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="158-容器与继承">15.8 容器与继承</h2>
<ul>
<li>当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式，即在容器中放置（智能）指针而非对象，否则派生类对象的部分会被切掉</li>
</ul>
<h2 id="159-文本查询程序再探">15.9 文本查询程序再探</h2>
<ul>
<li>使系统支持：单词查询、逻辑非查询、逻辑或查询、逻辑与查询。</li>
</ul>
<h3 id="面向对象的解决方案">面向对象的解决方案</h3>
<ul>
<li>将几种不同的查询建模成相互独立的类，这些类共享一个公共基类：
<ul>
<li><code>WordQuery</code></li>
<li><code>NotQuery</code></li>
<li><code>OrQuery</code></li>
<li><code>AndQuery</code></li>
</ul>
</li>
<li>这些类包含两个操作：
<ul>
<li><code>eval</code>：接受一个<code>TextQuery</code>对象并返回一个<code>QueryResult</code>。</li>
<li><code>rep</code>：返回基础查询的<code>string</code>表示形式。</li>
</ul>
</li>
<li>继承和组合：
<ul>
<li>当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（Is A）”的关系。</li>
<li>类型之间另一种常见的关系是“有一个（Has A）”的关系。</li>
</ul>
</li>
<li>对于面向对象编程的新手来说，想要理解一个程序，最困难的部分往往是理解程序的设计思路。一旦掌握了设计思路，接下来的实现也就水到渠成了。
<strong>Query程序设计</strong>:</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Query</code>程序接口类和操作</td>
<td></td>
</tr>
<tr>
<td><code>TextQuery</code></td>
<td>该类读入给定的文件并构建一个查找图。包含一个<code>query</code>操作，它接受一个<code>string</code>实参，返回一个<code>QueryResult</code>对象；该<code>QueryResult</code>对象表示<code>string</code>出现的行。</td>
</tr>
<tr>
<td><code>QueryResult</code></td>
<td>该类保存一个<code>query</code>操作的结果。</td>
</tr>
<tr>
<td><code>Query</code></td>
<td>是一个接口类，指向<code>Query_base</code>派生类的对象。</td>
</tr>
<tr>
<td><code>Query q(s)</code></td>
<td>将<code>Query</code>对象<code>q</code>绑定到一个存放着<code>string s</code>的新<code>WordQuery</code>对象上。</td>
</tr>
<tr>
<td><code>q1 &amp; q2</code></td>
<td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q1</code>和<code>q2</code>的新<code>AndQuery</code>对象上。</td>
</tr>
<tr>
<td>`q1</td>
<td>q2`</td>
</tr>
<tr>
<td><code>~q</code></td>
<td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q</code>的新<code>NotQuery</code>对象上。</td>
</tr>
<tr>
<td><code>Query</code>程序实现类</td>
<td></td>
</tr>
<tr>
<td><code>Query_base</code></td>
<td>查询类的抽象基类</td>
</tr>
<tr>
<td><code>WordQuery</code></td>
<td><code>Query_base</code>的派生类，用于查找一个给定的单词</td>
</tr>
<tr>
<td><code>NotQuery</code></td>
<td><code>Query_base</code>的派生类，用于查找一个给定的单词</td>
</tr>
<tr>
<td><code>BinaryQuery</code></td>
<td><code>Query_base</code>的派生类，查询结果是<code>Query</code>运算对象没有出现的行的集合</td>
</tr>
<tr>
<td><code>OrQuery</code></td>
<td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的并集</td>
</tr>
<tr>
<td><code>AndQuery</code></td>
<td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的交集</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch14 重载运算与类型转换</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:22 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>第十四章 重载运算与类型转换 14.1 基本概念 语法相关： 重载的运算符必须是某个类的成员或至少拥有一个类类型的运算对象 重载运算符函数的参数数量和该运算符</description>
      <content:encoded><![CDATA[<h1 id="第十四章-重载运算与类型转换">第十四章 重载运算与类型转换</h1>
<h2 id="141-基本概念">14.1 基本概念</h2>
<ul>
<li>语法相关：
<ul>
<li>重载的运算符必须是某个类的成员或至少拥有一个类类型的运算对象</li>
<li>重载运算符函数的参数数量和该运算符作用的运算对象数量一样多，左侧运算对象传递给第一个参数，右侧传递给第二个，除了重载函数调用符<code>()</code>，其他重载运算符不能有默认实参，调用方式：<code>operator+(data1, data2)</code></li>
<li>如果一个重载的运算符是成员函数，<strong><code>this</code>指向左侧运算对象</strong>，因此定义成员运算符时的参数数量比运算符的运算对象少一个，调用方式：<code>data1.operator+=(data2)</code></li>
<li>重载运算符的优先级和结合律跟对应的内置运算符保持一致。</li>
</ul>
</li>
<li>使用：
<ul>
<li>一些运算符通常一起进行重载，比如重载了<code>==</code>也应该重载<code>!=</code>，重载了<code>&lt;</code>也应该重载其他关系操作，重载了算数运算符或位运算符，也应该重载对应的复合赋值运算符</li>
<li>考虑定义为成员函数还是普通函数
<ul>
<li>赋值（<code>=</code>）、下标（<code>[]</code>）、调用（<code>()</code>）和成员访问箭头（<code>-&gt;</code>）运算符必须是成员。</li>
<li>递增、递减、解引用、复合赋值运算符一般是成员</li>
<li>具有对称性的运算符如算术、相等性、关系和位运算符等，通常是非成员函数。</li>
<li>IO运算符应该声明为类的友元</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="142-运算符重载">14.2 运算符重载</h2>
<h3 id="1421-重载输出运算符">14.2.1 重载输出运算符<code>&lt;&lt;</code></h3>
<ul>
<li><code>ostream&amp; operator&lt;&lt; (ostream &amp;os, const T &amp;t);</code></li>
<li>第一个形参通常是一个非常量的<code>ostream</code>对象的引用，第二个形参是要打印类型的常量引用</li>
<li>输出运算符应该尽量减少格式化操作（比如不应该打印换行符）</li>
</ul>
<h3 id="1422-重载输入运算符">14.2.2 重载输入运算符<code>&gt;&gt;</code></h3>
<ul>
<li><code>istream&amp; operator&gt;&gt; (istream&amp; is, T &amp;t);</code></li>
<li>第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用。</li>
<li>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。
<ul>
<li>如果读取失败，输入运算符应该负责从错误中恢复，主要是将输入对象重置为合法状态，一般为未输入前的状态。</li>
</ul>
</li>
</ul>
<h3 id="1423-重载算数运算符-">14.2.3 重载算数运算符<code>+、-、*、/</code></h3>
<ul>
<li>一般设置为非成员函数，形参一般为常量引用，返回值不为引用（因为返回值一般是局部变量的拷贝）</li>
<li>一般都是先定义复合赋值运算符（成员函数），在基于此实现算数运算符（普通函数）</li>
</ul>
<h3 id="1424-相等运算符">14.2.4 相等运算符<code>==</code></h3>
<ul>
<li>如果定义了<code>operator==</code>，则这个类也应该定义<code>operator!=</code>。</li>
<li>相等运算符和不等运算符的一个应该把工作委托给另一个</li>
</ul>
<h3 id="1425-关系运算符">14.2.5 关系运算符<code>&lt;</code></h3>
<ul>
<li>如果两个对象是!=的，则一个对象应该<code>&lt;</code>另一个对象</li>
</ul>
<h3 id="1426-赋值运算符">14.2.6 赋值运算符<code>=</code></h3>
<ul>
<li>赋值运算符和复合赋值运算符应该返回左侧运算对象的引用。</li>
</ul>
<h3 id="1427-下标运算符">14.2.7 下标运算符<code>[]</code></h3>
<ul>
<li>一般会定义两个版本：
<ul>
<li>返回普通引用：<code>T&amp; operator[]();</code></li>
<li>是类的常量成员，并返回常量引用：<code>const T&amp; operator[] const;</code></li>
</ul>
</li>
</ul>
<h3 id="1428-递增和递减运算符--">14.2.8 递增和递减运算符<code>++、--</code></h3>
<ul>
<li>应该同时定义前置版本和后置版本，而且通常为类的成员。
<ul>
<li>前置运算符应该返回递增或递减后对象的引用：<code>string&amp; operator++();</code></li>
<li>后置运算符应该返回递增或递减前对象的值，而不是引用：<code>T operator++(int);</code>
<ul>
<li>后置版本接受一个额外的、不被使用的<code>int</code>类型的形参，且无需命名，编译器提供一个值为0的实参。该形参唯一的作用就是区分前置和后置递增。</li>
<li>如果想通过函数调用的方式使用后置递增，需要为这个int形参传递一个值（比如0）</li>
</ul>
</li>
<li>后置版本可以通过调用前置版本来实现。</li>
</ul>
</li>
</ul>
<h3 id="1429-成员访问运算符-">14.2.9 成员访问运算符<code>*、-&gt;</code></h3>
<ul>
<li>箭头运算符必须是类的成员，解引用运算符通常也是类的成员，且通常为const的成员函数，而且箭头运算符一般通过调用解引用运算符来实现</li>
</ul>
<h3 id="14210-函数调用运算符">14.2.10 函数调用运算符<code>()</code></h3>
<h2 id="148-函数调用运算符">14.8 函数调用运算符</h2>
<ul>
<li>如果类定义了调用运算符，则该类的对象称作【<strong>函数对象</strong>】。
<ul>
<li>函数对象可以被调用，同时因为函数对象可以存储状态（即数据成员），所以与普通函数相比更加灵活，通常作为泛型算法的实参</li>
</ul>
</li>
<li>C++中的【可调用对象】：函数、函数指针、lambda表达式、bind创建的对象、函数对象（或者说重载了调用运算符的类）
<ul>
<li>【可调用对象的类型】：lambda表达式有他自己唯一（未命名）的类类型，函数、函数指针的类型由返回值类型和实参类型决定</li>
<li>【调用形式】：指明了调用返回的类型和传递给调用的实参类型，比如<code>int(int,int)</code>
<ul>
<li>不同类型的可调用对象可以共享同一种调用形式，但它们并不是同一类型。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=29b2448c-5e82-8903-6155-e45a101f91f1&amp;page=538&amp;rect=58.810,599.770,427.200,622.320">例子</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="lambda是函数对象"><code>lambda</code>是函数对象</h3>
<ul>
<li>编译器将[[ch10-泛型算法#lambda表达式|lambda表达式]]转换成一个未命名类的未命名对象（即类中重载了函数调用运算符）
<ul>
<li>这个未命名类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认的拷贝/移动构造函数，通常视捕获变量的类型而定</li>
</ul>
</li>
<li>lambda默认不能改变它捕获的变量，此时未命名类中的函数调用运算符是一个const成员函数；如果lambda被声明为可变的，则调用运算符就不再是const成员函数
<ul>
<li>如果进行引用捕获，编译器直接使用该引用而无须在产生的类中相应存储为数据成员（由程序确保该引用绑定的对象确实存在）</li>
<li>如果进行值捕获，产生的类必须为捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化相应的数据成员</li>
</ul>
</li>
</ul>
<h3 id="标准库定义的函数对象">标准库定义的函数对象</h3>
<h6 id="标准库函数对象">标准库函数对象</h6>
<table>
<thead>
<tr>
<th>算术</th>
<th>关系</th>
<th>逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>plus&lt;Type&gt;</code></td>
<td><code>equal_to&lt;Type&gt;</code></td>
<td><code>logical_and&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>minus&lt;Type&gt;</code></td>
<td><code>not_equal_to&lt;Type&gt;</code></td>
<td><code>logical_or&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>multiplies&lt;Type&gt;</code></td>
<td><code>greater&lt;Type&gt;</code></td>
<td><code>logical_not&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>divides&lt;Type&gt;</code></td>
<td><code>greater_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>modulus&lt;Type&gt;</code></td>
<td><code>less&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>negate&lt;Type&gt;</code></td>
<td><code>less_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>一组表示算数运算符、关系运算符和逻辑运算符的模板类，每个类中重载了调用运算符来实现相应的命名操作</li>
<li>标准库函数对象经常用来替换算法中的默认运算符</li>
<li>如果想根据指针（或者说内存地址）进行排序，Type可以是指针类型，但是无法通过自定义的函数来进行内存地址的比较</li>
</ul>
<h3 id="可调用对象与function">可调用对象与function</h3>
<ul>
<li>调用形式相同的可调用对象，其类型不一定相同</li>
<li><code>function</code>封装了相同调用形式、但是不同类型的可调用对象
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">mod</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">mod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;%&#34;</span><span class="p">,</span> <span class="n">mod</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">[</span><span class="s">&#34;+&#34;</span><span class="p">](</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 将不同可调用类型的可调用对象存储在一起    
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>不能直接将重载函数的名字存入<code>function</code>类型的对象中，因为会产生二义性，消除二义性的方法是使用lambda或者函数指针而非函数名字
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">add</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="n">t</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">mp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">});</span> <span class="c1">// error: which add?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">fp</span><span class="p">});</span> 
</span></span><span class="line"><span class="cl"><span class="n">mp</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);};</span> <span class="c1">// 另一种写法
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="149-重载类型转换运算符">14.9 重载、类型转换、运算符</h2>
<p>类类型转换（或者称用户定义的类型转换）：转换构造函数（从其他类型转换到类类型）+类型转换运算符（从类类型转换到其他类型）</p>
<h3 id="类型转换运算符">类型转换运算符</h3>
<ul>
<li>一般类型：<code>operator type() const;</code></li>
<li>语法相关：
<ul>
<li>可以转换到任意类型（除了void），只要该类型能作为函数的返回类型</li>
<li>必须是类的成员函数，不能声明返回类型（但是函数返回一个对应类型的值），形参列表为空，一般为const成员函数</li>
</ul>
</li>
<li>使用：
<ul>
<li>类型转换运算符不需要显式调用，在执行运算时会隐式的执行</li>
<li>尽量确保类型转换是有意义的，避免过度使用</li>
<li>尽管编译器一次只能执行一个【用户定义的类型转换】，但是隐式的【用户定义的类型转换】可以置于一个标准内置类型转换之前或之后</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">smallInt</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">smallInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;bad value&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="o">-</span><span class="n">val</span><span class="p">;}</span> <span class="c1">// 为了说明类型转换运算符的效果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">size_t</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">smallInt</span> <span class="n">s</span> <span class="o">=</span> <span class="mf">2.1</span><span class="p">;</span> <span class="c1">// 先将double转换为int，再使用转换构造函数将int转换为smallInt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span> <span class="o">+</span> <span class="mf">2.1</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 使用【类型转换运算符】将s隐式地转换为int，再转换为double相加
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>显式的类型转换运算符（C++11）：<code>explicit operator type() const;</code>
<ul>
<li>需要使用<code>static_cast&lt;type&gt;</code>进行显式的类型转换
<ul>
<li>例外：当表达式被用作条件时，显式的类型转换将被隐式的执行</li>
</ul>
</li>
<li>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的。</li>
</ul>
</li>
</ul>
<h3 id="避免有二义性的类型转换">避免有二义性的类型转换</h3>
<ul>
<li>必须确保在类类型和目标类型之间只存在唯一一种转换方式，否则很可能有二义性</li>
<li>两种情况会产生多重转换路径：
<ul>
<li>【用A的转换构造函数还是B的类型转换运算符】：A类定义了一个参数为B类的转换构造函数，B类定义了一个目标类型为A类的类型转换运算符，此时可以显式指定调用哪一种
<ul>
<li>无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">B</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">()</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="o">&amp;</span><span class="n">B</span><span class="p">);</span> <span class="c1">// 转换构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">B</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="nf">A</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 类型转换运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 定义一个函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">B</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 二义性：使用B的【类型转换运算符】，还是使用A的【转换构造函数】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="k">operator</span> <span class="n">A</span><span class="p">());</span> <span class="c1">// 使用B的类型转换运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">A</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="p">));</span> <span class="c1">// 使用A的转换构造函数
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>【有多个类型转换运算符，用哪个】：类定义了多个类型转换规则，转换目标为内置类型，且转换级别一致
<ul>
<li>标准类型转换的级别决定编译器如何选择最佳匹配，转换级别一致就会出现二义性</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="nf">double</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 二义性错误：a转换成int还是转换成double，再提升为long double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">short</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="nf">a2</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// 不会产生二义性错误，因为short类型提升为int优先于short类型提升为double
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>经验：尽量避免定义类型转换，且限制非显式构造函数
<ul>
<li>不要令两个类执行相同的类型转换</li>
<li>避免转换目标是内置算数类型的类型转换，特别是已经定义了一个转换成算数类型的类型转换</li>
</ul>
</li>
</ul>
<h3 id="重载与函数匹配">重载与函数匹配</h3>
<ul>
<li>[[ch06-函数#6.6 函数匹配|函数匹配]]</li>
<li>重载函数与转换构造函数
<ul>
<li>当调用重载函数时，如果两个或多个类型转换都提供了同一种可行匹配，则这些类型转换一样好</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">C</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">D</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">D</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 重载函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">func</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 二义性错误：
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=efa03877-7c33-c199-b557-f956b4531c90&amp;page=546&amp;rect=70.080,407.290,216.481,415.930">重载函数与用户定义的类型转换</a></li>
<li>重载运算符与函数匹配
<ul>
<li>如果既定义了类型转换运算符（转换到内置类型），又将运算符进行重载，会遇到二义性问题
<ul>
<li>如果<code>a</code>是一种类类型，则表达式<code>a sym b</code>可能是：
<ul>
<li><code>a.operatorsym(b);</code> 成员函数</li>
<li><code>operatorsym(a,b);</code> 普通函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">T</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">T</span> <span class="k">operator</span><span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// 转换构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// 类型转换运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 二义性：可以将t转换成int进行内置加法，或者将1转换成类型T进行重载加法
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch13 拷贝控制</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:13 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</guid>
      <description>第十三章 拷贝控制 一些术语 构造函数： （合成的）[[ch07-类#^15282e|默认构造函数]]：编译器创建或是使用=default修饰的构造</description>
      <content:encoded><![CDATA[<h1 id="第十三章-拷贝控制">第十三章 拷贝控制</h1>
<h2 id="一些术语">一些术语</h2>
<ul>
<li>构造函数：
<ul>
<li>（合成的）[[ch07-类#^15282e|默认构造函数]]：编译器创建或是使用<code>=default</code>修饰的构造函数</li>
<li>一般的构造函数</li>
<li>拷贝构造函数</li>
<li>转换构造函数（或称为[[ch07-类#隐式的类型转换|隐式的类型转换]]）</li>
<li>移动构造函数</li>
<li>[[ch07-类#委托构造函数 （delegating constructor）|委托构造函数]]</li>
</ul>
</li>
<li>初始化类型：
<ul>
<li>默认初始化：<code>int* a = new int;</code></li>
<li>值初始化：<code>int *a = new int(); // 默认a=0</code></li>
<li>直接初始化：<code>int *a = new int(1);</code></li>
<li>拷贝初始化：<code>=</code></li>
<li>列表初始化：<code>{}</code></li>
</ul>
</li>
<li><strong>拷贝控制操作</strong>（copy control）（或者称为拷贝控制成员）:一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值、和销毁操作
<ul>
<li>拷贝构造函数（copy constructor）</li>
<li>拷贝赋值运算符（copy-assignment operator）</li>
<li>移动构造函数（move constructor）</li>
<li>移动赋值函数（move-assignement operator）</li>
<li>析构函数（destructor）</li>
</ul>
</li>
</ul>
<h2 id="131-拷贝赋值和销毁">13.1 拷贝、赋值和销毁</h2>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<ul>
<li>拷贝构造函数：
<ul>
<li>第一个参数是自身类型的引用（而且一般是const引用，否则导致无限递归，因为传递实参本身就是拷贝），且其他参数都有默认值</li>
<li>通常不会声明为explicit的</li>
</ul>
</li>
<li>合成的拷贝构造函数：
<ul>
<li>编译器将参数的非static成员逐个拷贝到正在创建的对象中。</li>
<li>对于某些类，合成的拷贝构造函数使用<code>=delete</code>来禁止对该类型对象的拷贝</li>
</ul>
</li>
<li>拷贝初始化：
<ul>
<li>通常使用拷贝构造函数完成，但也可能使用移动构造函数</li>
<li>出现场景：
<ul>
<li>用<code>=</code>定义变量时。</li>
<li>将一个对象作为实参传递给一个非引用类型的形参。</li>
<li>从一个返回类型为非引用类型的函数返回一个对象。</li>
<li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="拷贝赋值运算符">拷贝赋值运算符</h3>
<ul>
<li>重载赋值运算符：
<ul>
<li>通常返回一个指向其左侧运算对象（即自身）的引用：<code>return *this;</code></li>
</ul>
</li>
<li>合成拷贝赋值运算符：
<ul>
<li>将右侧运算对象的每个非<code>static</code>成员赋予左侧运算对象的对应成员，之后返回左侧对象的引用</li>
<li>对于某些类，合成的拷贝赋值运算符使用<code>=delete</code>来禁止对该类型对象的赋值</li>
</ul>
</li>
</ul>
<h3 id="析构函数">析构函数</h3>
<ul>
<li>析构顺序：
<ul>
<li>先执行析构函数体：因为销毁指针并不会delete它所指的对象，因此需要手动释放空间</li>
<li>再执行析构部分，按初始化顺序的逆序销毁非static的数据成员</li>
</ul>
</li>
</ul>
<h3 id="三五法则">三/五法则</h3>
<ul>
<li>背景：一个类通常需要拷贝构造函数、拷贝赋值运算符、析构函数（和移动构造函数、移动赋值运算符），虽然通常不会全部自定义，但是有时需要将这些拷贝控制成员看作一个整体</li>
<li>三五法则：
<ul>
<li>一个需要自定义析构函数的类，一定也需要一个拷贝构造函数和拷贝赋值运算符（比如类中有一个指向动态内存的指针，使用合成版本的构造函数只会复制指针的值）</li>
<li>一个需要自定义拷贝构造函数的类，也一定需要一个拷贝赋值运算符，反之亦然；但是未必需要析构函数（比如每个类需要有一个唯一id）</li>
</ul>
</li>
</ul>
<h3 id="显式合成default">显式合成<code>=default</code></h3>
<ul>
<li>可以通过将拷贝控制成员定义为<code>=default</code>来显式地要求编译器生成合成的版本。
<ul>
<li>只能对具有合成版本的成员函数（即默认构造函数或拷贝控制成员）使用=default</li>
<li>在类内部使用=default修饰成员声明时，合成的函数是隐式内联的；如果不希望合成的是内联函数，应该只对成员的类外定义使用=default</li>
</ul>
</li>
</ul>
<h3 id="阻止拷贝delete">阻止拷贝<code>=delete</code></h3>
<ul>
<li>删除的函数<code>=delete</code>：虽然声明了该函数，但是不能使用它们</li>
<li>语法相关：
<ul>
<li><code>=delete</code>只能出现在函数第一次声明的地方（即告诉编译器不定义这些函数）</li>
<li>可以对任何函数（除了析构函数，否则动态分配了对象后无法释放）使用</li>
<li>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的构造、拷贝、复制、析构函数被定义为删除的。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=87750c2e-2368-c105-88dd-7f6d8e702f15&amp;page=476&amp;rect=90.240,157.210,339.610,165.130">原文</a>。
<ul>
<li>如果类的某个数据成员的析构函数是删除的或不可访问的（如 private 的），则该类的合成析构函数、合成拷贝构造函数和默认构造函数被定义为删除的</li>
<li>如果类的某个数据成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。</li>
<li>如果类的某个数据成员的拷贝赋值运算符是删除的或不可访问的，则类的合成拷贝赋值运算符被定义为删除的。</li>
<li>如果类有一个 const 成员或引用成员，则类的合成拷贝赋值运算符被定义为删除的。（但是拷贝构造函数在初始化时执行）</li>
<li>如果类有一个没有类内初始化器且未显式定义默认构造函数的 const 成员或没有类内初始化器的引用成员，则该类的默认构造函数被定义为删除的</li>
</ul>
</li>
</ul>
</li>
<li>老版本的阻止拷贝
<ul>
<li>将拷贝控制成员设置为<code>private</code>，阻止普通用户拷贝对象（编译期报错）</li>
<li>将拷贝控制成员只声明不定义，友元和成员函数调用时报错（链接时报错）</li>
</ul>
</li>
</ul>
<h2 id="132-拷贝控制和资源管理">13.2 拷贝控制和资源管理</h2>
<ul>
<li>通常管理类外资源的类必须定义拷贝控制成员</li>
<li>类的行为可以像一个值，也可以像一个指针，主要是依据拷贝指针成员的行为
<ul>
<li>不允许拷贝和赋值的类，行为既不像值，也不像指针</li>
</ul>
</li>
</ul>
<h4 id="行为像值">行为像值</h4>
<ul>
<li>对象有自己的状态，副本和原对象是完全独立的，需要定义一个拷贝构造函数、一个析构函数、一个拷贝赋值运算符
<ul>
<li>赋值运算符通常组合析构函数（销毁左侧对象的资源）和构造函数（从右侧对象拷贝构造）的操作</li>
<li>拷贝赋值运算符要考虑到【自赋值】的正确性：</li>
</ul>
</li>
<li>好的方法是先将右侧对象（动态内存的指针对象）拷贝到一个局部临时对象，再销毁左侧对象的资源。（P453<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=79f6e710-cfdb-8315-7af9-bccf63645b0b&amp;page=479&amp;rect=80.880,111.600,117.360,120.720">例子</a>）</li>
</ul>
<h4 id="行为像指针">行为像指针</h4>
<ul>
<li>共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据，需要定义一个拷贝构造函数、一个析构函数、一个拷贝赋值运算符</li>
<li>最好使用shared_ptr管理资源，或者使用一个<strong>引用计数</strong>来直接管理（引用计数和资源一样是共享的，应该保存在动态内存中）。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=0cd2068b-d080-32af-4d30-59bb8bec3168&amp;page=481&amp;rect=80.160,327.130,164.400,334.810">引用计数的工作方式</a>：
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。创建一个对象时，计数器初始化为1。</li>
<li>拷贝构造函数不创建新的引用计数，而是拷贝对象的计数器并递增它。</li>
<li>析构函数递减计数器，如果计数器变为 0，则析构函数释放状态。</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为 0 就销毁状态。</li>
</ul>
</li>
<li>拷贝赋值运算符类似于shared_ptr，需要递增右侧对象的引用计数，递减左侧对象的引用计数</li>
<li>此时处理【自赋值】问题：先是右侧对象引用计数递增，后是左侧对象引用计数递减，自赋值时引用计数不变（P457<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=2715fed7-26b5-0064-9720-b469350a27a6&amp;page=482&amp;rect=236.842,53.760,344.400,62.160">例子</a>）</li>
</ul>
<h2 id="133-交换操作">13.3 交换操作</h2>
<ul>
<li>管理资源的类通常还定义一个名为<code>swap</code>的函数，经常用于重排元素顺序的算法。</li>
<li>优先使用自定义的swap，否则使用标准库的<code>std::swap</code></li>
<li>通常可以使用swap来实现赋值运算符
<ul>
<li>右侧对象传值，然后将左侧对象与右侧对象的副本进行交换（copy and swap），可以正确处理自赋值的情况</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">HasPtr</span><span class="p">{</span> <span class="c1">// 行为类似值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">HasPtr</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">HasPtr</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">())</span> <span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// 拷贝构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HasPtr</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;&amp;</span><span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">ps</span> <span class="mi">0</span><span class="p">;}</span> <span class="c1">// 移动构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span> <span class="c1">// 拷贝赋值操作符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ps</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 特点：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1.用swap实现赋值运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2.既是拷贝赋值运算符（参数是左值），又是移动赋值运算符（参数是右值）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="n">HasPtr</span> <span class="n">rhs</span><span class="p">){</span> <span class="c1">// copy and swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 传入的是rhs的副本（假设是rhs-copy），this还是指向本身（假设是lhs）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// 交换左侧对象(lhs)和右侧对象的副本(rhs-copy)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 此时this指向rhs-copy（更准确来说还是指向lhs地址，但是原来lhs的内容已经被swap为了rhs-copy）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// swap后的lhs没有变量来接管，因此被析构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因此实现了this指向从lhs改变为rhs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span><span class="k">delete</span> <span class="n">ps</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span> <span class="c1">// 当某个成员没有自定义的swap时，使用标准库版本的swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">ps</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">i</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span> <span class="n">h</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Foo</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span> <span class="c1">// 优先使用自定义版本的swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">h</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// 使用HasPtr版本的swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">HasPtr</span> <span class="nf">p1</span><span class="p">(</span><span class="s">&#34;test)</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span> <span class="c1">// 使用拷贝赋值运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span> <span class="c1">// 使用移动赋值运算符
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="134-拷贝控制示例">13.4 拷贝控制示例</h2>
<h2 id="135-动态内存管理类">13.5 动态内存管理类</h2>
<h2 id="136-对象移动">13.6 对象移动</h2>
<p>使用对象移动的原因：</p>
<ul>
<li>一些拷贝操作后，原对象会被立即销毁，因此引入移动操作可以大幅度提升性能。</li>
<li>C++11可以用容器保存不可拷贝的类型，只要它们可以被移动即可。
<ul>
<li>标准库容器、<code>string</code>和<code>shared_ptr</code>类既可以支持移动也支持拷贝。<code>IO</code>类和<code>unique_ptr</code>类可以移动但不能拷贝。</li>
</ul>
</li>
</ul>
<h3 id="左值与右值">左值与右值</h3>
<ul>
<li>左值：
<ul>
<li>返回左值的表达式：返回左值引用的函数，赋值、下标、解引用、前置递增递减运算符，</li>
<li>左值引用：可以绑定到变量（包括右值引用变量）、返回左值的表达式</li>
<li>const的左值引用可以绑定到右值</li>
</ul>
</li>
<li>右值：
<ul>
<li>右值要么是字面常量（没有其他用户），要么是表达式求值过程中创建的临时变量（即将被销毁）</li>
<li>返回右值的表达式：返回非引用类型的函数，算数、关系、位、后置递增递减运算符</li>
<li>右值引用：可以绑定到要求转换的表达式、字面常量、返回右值的表达式</li>
</ul>
</li>
<li>move函数： ^d3a2a0
<ul>
<li>可以将一个右值引用绑定到左值上 <code>int a=1; int &amp;&amp;r = std::move(a);</code></li>
<li>定义在头文件utility中</li>
<li><code>move</code>告诉编译器，我们有一个左值，但我希望像右值一样处理它。</li>
<li>对左值调用<code>move</code>意味着：不在使用该左值的值，除非销毁它或者对它重新赋值</li>
<li>使用move的代码应该使用std::move而不是move，可以避免潜在的名字冲突</li>
</ul>
</li>
</ul>
<h3 id="移动构造函数和移动赋值运算符">移动构造函数和移动赋值运算符</h3>
<ul>
<li>移动构造函数
<ul>
<li>第一个参数是该类类型的一个右值引用，比如<code>StrVec::StrVec(StrVec &amp;&amp;s) noexcept{}</code></li>
<li>在形参列表后添加关键字<code>noexcept</code>可以指明该函数不会抛出任何异常，在声明和定义中均应该指明<code>noexcept</code>
<ul>
<li>不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code></li>
<li>原因：如果用移动构造函数，移动到一半抛出异常，容器不能满足即使发生异常也保持自身不变的要求，因此需要显式标记<code>noexcept</code>；否则编译器基于上面的考虑，会调用拷贝构造函数而非移动构造函数</li>
</ul>
</li>
<li>除了完成资源移动，还要确保移动后源对象是可以安全销毁的（比如将源对象中数组的指针指向nullptr，然后源对象进行正确析构，否则会释放掉刚才移动的对象），用户不能使用移动后源对象的值</li>
</ul>
</li>
<li>移动赋值运算符
<ul>
<li><code>StrVec&amp; StrVec::operator=(StrVec &amp;&amp; rhs) noexcept{}</code></li>
<li>使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能，依赖于实参的类型：实参是左值，则实参被拷贝；实参是右值，则实参被移动：<code>StrVec&amp;   StrVec::operator=(StrVec rhs);</code></li>
</ul>
</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=e9cc2ba7-e7de-20c5-6d18-bd84fd5f6733&amp;page=506&amp;rect=180.960,300.960,227.280,309.840">移动迭代器</a>：
<ul>
<li>普通迭代器的解引用运算符返回一个指向元素的左值，移动迭代器的解引用运算符生成一个右值引用</li>
<li><code>make_move_iterator</code>函数将一个普通迭代器转换为一个移动迭代器。</li>
<li>因此，可以将移动迭代器传递给算法或是allocator的伴随算法</li>
<li>但是，标准库不能保证哪些算法适用于移动迭代器，哪些不适用。由于移动一个对象可能销毁掉源对象，因此要确定以后不再访问这个元素时，才能将移动迭代器传递给算法。</li>
<li>移后源对象具有不确定的状态，必须确认移后源对象没有其他用户，因此要小心使用</li>
</ul>
</li>
<li>合成的移动操作
<ul>
<li>如果一个类定义了自己的拷贝构造函数、拷贝赋值函数或者析构函数，编译器不会为它合成移动构造函数和移动赋值运算符</li>
<li>如果一个类没有移动操作，类会用对应的拷贝操作来代替移动操作，即使使用move函数也是如此</li>
<li>只有当一个类没有自定义的拷贝控制成员，且类的每个非static数据成员都可以移动（内置类型可以移动，类类型要有对应的移动操作）时，编译器才会为类合成移动构造函数和移动赋值运算符；否则即使显式要求合成移动操作<code>=default</code>，编译器也会将移动操作定义为<code>=delele</code></li>
<li>与拷贝操作不同，移动操作永远不会隐式定义为<code>=delete</code>
<ul>
<li>例外：<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=26545b20-71fb-2bf8-83a8-871ae37ad44a&amp;page=502&amp;rect=64.080,328.080,432,350.400">将合成的移动操作定义为删除的</a></li>
</ul>
</li>
<li>如果一个类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝函数和拷贝赋值运算符会被定义为删除的</li>
<li>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的</li>
</ul>
</li>
</ul>
<h3 id="引用限定符">引用限定符</h3>
<ul>
<li>成员函数一般有接受拷贝的<code>const T&amp;</code>版本和接受右值的<code>T&amp;&amp;</code>版本</li>
<li><strong>引用限定符</strong><code>&amp;</code>和<code>&amp;&amp;</code>：
<ul>
<li>限制调用者必须是左值还是右值</li>
<li>语法相关：
<ul>
<li>引用限定符只能用于非static成员函数</li>
<li>引用限定符必须同时出现在函数的声明和定义中</li>
<li>一个函数可以同时使用const和引用限定，即引用限定符必须在const限定符之后</li>
<li>如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符</li>
</ul>
</li>
<li>可以综合使用引用限定符和const限定符来区分一个函数的重载版本
<ul>
<li>使用const &amp;&amp;进行限定时，调用者必须是右值</li>
<li>使用const &amp;进行限定时，调用者可以是左值，也可以是右值</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Test</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">show</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="k">return</span> <span class="n">val</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// const int show() &amp; {} // 报错：返回值与重载无关，见6.4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="nf">show</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="k">return</span> <span class="n">val</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">show</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="k">return</span> <span class="n">val</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">show</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;&amp;</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="k">return</span> <span class="n">val</span><span class="p">;}</span> <span class="c1">// 右值本来就是常量，这种方法无法被调用（被show() &amp;&amp;）覆盖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Test</span> <span class="n">t1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">t1</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Test</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">show</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Test</span> <span class="n">t3</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">t3</span><span class="p">.</span><span class="n">show</span><span class="p">();</span> <span class="c1">// const对象或是const对象的指针/引用，只能调用const成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 输出1 2 3 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>  
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch12 动态内存</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</link>
      <pubDate>Tue, 27 Feb 2024 15:58:04 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</guid>
      <description>第十二章 动态内存 对象的生命周期： 全局对象在程序启动时分配，结束时销毁。 局部对象在进入程序块时创建，离开块时销毁。 局部static对象在第一次</description>
      <content:encoded><![CDATA[<h1 id="第十二章-动态内存">第十二章 动态内存</h1>
<ul>
<li>对象的生命周期：
<ul>
<li>全局对象在程序启动时分配，结束时销毁。</li>
<li>局部对象在进入程序块时创建，离开块时销毁。</li>
<li>局部<code>static</code>对象在第一次使用前分配，在程序结束时销毁。</li>
<li>动态分配对象：只能显式地被释放。</li>
</ul>
</li>
<li>对象的内存位置：
<ul>
<li><strong>静态内存</strong>用来保存局部<code>static</code>对象、类<code>static</code>对象、定义在任何函数之外的变量。</li>
<li><strong>栈内存</strong>用来保存定义在函数内的非<code>static</code>对象；由操作系统自动分配和释放，内存空间比较小</li>
<li><strong>堆内存</strong>，又称自由空间，用来存储<strong>动态分配</strong>的对象；手动申请和释放，内存空间比较大</li>
</ul>
</li>
</ul>
<h2 id="121-动态内存与智能指针">12.1 动态内存与智能指针</h2>
<h3 id="1210-动态内存">12.1.0 动态内存</h3>
<ul>
<li>使用<code>new</code>动态分配内存，返回的是一个指向该对象的指针
<ul>
<li>动态分配的对象是默认初始化的，也可以使用值初始化、直接初始化（圆括号中有初始值）、列表初始化方式来进行初始化
<ul>
<li>对于类而言，值初始化与默认初始化没有区别</li>
<li>对于内置类型而言，
<ul>
<li>值初始化有一个确定的初始值：<code>int *p = new int(); // 此时所指对象值为0</code></li>
<li>默认初始化的初始值未定：<code>int *p = new int;</code></li>
<li>直接初始化：<code>auto *p = new int(2);</code></li>
</ul>
</li>
</ul>
</li>
<li>可以使用new分配const对象，返回指向const类型的指针，但是动态分配的const对象必须初始化
<ul>
<li><code>const int* pc = new const int(1);</code></li>
</ul>
</li>
<li>new失败会抛出<code>bad_alloc</code>异常
<ul>
<li>使用定位new可以阻止抛出异常，定位new允许将new传递额外参数</li>
<li>如果传递<code>nothrow</code>给new，则new在分配失败之后会返回空指针：<code>int* p = new(nothrow) int;</code></li>
</ul>
</li>
</ul>
</li>
<li>使用<code>delete</code>销毁对象，并释放内存
<ul>
<li><code>delete</code>后的指针称为空悬指针（dangling pointer），应该在delete之后将指针值置空。</li>
</ul>
</li>
<li>使用<code>new/delete</code>，要么容易忘记释放内存引起内存泄露，要么释放内存后再使用引起use after free</li>
<li>智能指针：定义在头文件<code>memory</code>中
<ul>
<li><code>shared_ptr</code>：允许多个指针指向同一个对象，共享内存</li>
<li><code>unique_ptr</code>：独占所指向的对象</li>
<li><code>weak_ptr</code>：是一种弱引用，指向<code>shared_ptr</code>所管理的对象</li>
</ul>
</li>
</ul>
<h3 id="1211-shared_ptr">12.1.1 shared_ptr</h3>
<h4 id="声明和初始化">声明和初始化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp1</span><span class="p">;</span> <span class="c1">// 指向类型T的空智能指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp2</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="c1">// 参数q为T*类型的内置指针, sp2接管对象的所有权
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp3</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span> <span class="c1">// sp3使用删除器d代替默认删除器delete（删除器d必须接受一个T*类型的参数）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp4</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span> <span class="c1">// 参数sp为shared_ptr&lt;T&gt;，等价于sp4 = sp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp5</span> <span class="o">=</span> <span class="n">sp4</span><span class="p">;</span> <span class="c1">// sp4引用计数递减，sp5引用计数递增
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp6</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">);</span> <span class="c1">// 使用参数args初始化类型为T的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sp7</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="c1">// 参数u为unique_ptr&lt;T&gt;, sp7接管对象的所有权，并将u置为空
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>语法相关：
<ul>
<li>使用内置指针<code>q</code>进行初始化必须使用直接初始化形式（如<code>sp2</code>），不能使用拷贝初始化，因为调用了explicit的转换构造函数</li>
<li>默认内置指针<code>q</code>必须指向动态内存（因为智能指针默认使用<code>delete</code>释放对象），如果将智能指针绑定到指向其他类型资源的指针上，需要使用自定义的删除器代替<code>delete</code></li>
</ul>
</li>
<li>推荐使用<code>sp6</code>的初始化方式<code>make_shared</code>，即<strong>不要混合使用智能指针和内置指针</strong>
<ul>
<li>不推荐<code>sp2</code>方式进行初始化，因为同一个内置指针<code>q</code>不能绑定到多个独立创建的shared_ptr，否则<strong>析构时多次delete</strong></li>
<li>如果使用<code>q</code>创建shared_ptr后（比如<code>sp2</code>），不要再使用<code>q</code>，因为<code>q</code>无法知道对象何时被shared_ptr释放，随时可能变成空悬指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp1</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// shared_ptr&lt;int&gt; sp(p1); // 报错，p1绑定到独立的两个shared_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">add</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">));</span> <span class="c1">// 函数调用完后，智能指针引用计数为0，p2所指向内存被释放，此时p2成为悬空指针，危险！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">sp3</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// 推荐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">add</span><span class="p">(</span><span class="n">sp3</span><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="其他操作">其他操作</h4>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>p.get()</code></td>
<td style="text-align:center">返回<code>p</code>中保存的指针。如果智能指针释放了对象，则get返回一个悬空指针。</td>
</tr>
<tr>
<td style="text-align:center"><code>p.use_count()</code></td>
<td style="text-align:center">返回与<code>p</code>共享对象的智能指针的数量</td>
</tr>
<tr>
<td style="text-align:center"><code>p.unique()</code></td>
<td style="text-align:center">当前对象是否被<code>p</code>独占（或者当<code>p.use_count()==1</code>时返回<code>true</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>p.reset()</code></td>
<td style="text-align:center">如果<code>p</code>时唯一指向其对象的<code>shared_ptr</code>，则释放此对象</td>
</tr>
<tr>
<td style="text-align:center"><code>p.reset(q)</code></td>
<td style="text-align:center">令<code>p</code>指向内置指针<code>q</code></td>
</tr>
<tr>
<td style="text-align:center"><code>p.reset(q, d)</code></td>
<td style="text-align:center">令<code>p</code>指向内置指针<code>q</code>，并调用删除器<code>d</code>（而非默认删除器）来释放<code>q</code></td>
</tr>
</tbody>
</table>
<ul>
<li>智能指针不支持指针算数运算</li>
<li><code>get</code>函数
<ul>
<li>智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象，主要用于向不能使用智能指针的代码传递内置指针。</li>
<li>使用get返回的指针不能用来delete</li>
<li>不要使用get函数初始化另一个智能指针或为智能指针赋值（因为析构时多次delete）</li>
<li>只有在确定代码不会delete指针的情况下，才使用get</li>
</ul>
</li>
<li><code>unique</code>函数通常用与<code>reset</code>一起使用，检查shared_ptr是否独占当前对象，如果不是需要使用<code>reset</code>指向新的元素或拷贝。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=ea61576a-2659-8626-9cab-fee42fcc5b31&amp;page=440&amp;rect=65.520,177.370,433.440,199.210">例子</a>。</li>
</ul>
<h4 id="使用建议">使用建议</h4>
<ul>
<li>不使用相同的内置指针初始化或<code>reset</code>多个智能指针</li>
<li>不<code>delete get()</code>返回的指针。</li>
<li>不使用<code>get()</code>初始化或<code>reset</code>另一个智能指针</li>
<li>如果你使用<code>get()</code>返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。</li>
<li>如果你使用智能指针管理的资源不是<code>new</code>分配的内存，记住传递给它一个删除函数。</li>
</ul>
<h3 id="1212-unique_ptr">12.1.2 unique_ptr</h3>
<h4 id="声明和初始化-1">声明和初始化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">u1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">u1</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="c1">// q为类型T*的内置指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">uniuqe_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">u2</span><span class="p">;</span> <span class="c1">// 定义一个unique_ptr，指向类型T，有一个类型为D的删除器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">u3</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">u4</span> <span class="o">=</span> <span class="n">make_uniuqe</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">);</span> <span class="c1">// C++14
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>unique_ptr将删除器类型放在尖括号中，因为删除器类型也是unique_ptr类型的一部分</li>
<li>同一时刻只能有一个<code>unique_ptr</code>指向一个给定的对象。当unique_ptr被销毁时，它指向的对象也被销毁
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">uniuqe_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 正确，但是u销毁之后p成为空悬指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">uniuqe_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">up</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 推荐写法
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>unique_ptr必须使用内置指针进行直接初始化（圆括号初始化），不支持拷贝或赋值操作（unique的含义，而且其拷贝构造函数是删除的）
<ul>
<li>例外：可以拷贝或赋值一个即将被销毁的unique_ptr（移动构造、移动赋值）</li>
</ul>
</li>
</ul>
<h4 id="其他操作-1">其他操作</h4>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u.get()</code></td>
<td style="text-align:center">返回<code>u</code>中保存的指针。如果智能指针释放了对象，则<code>get</code>返回一个悬空指针。</td>
</tr>
<tr>
<td style="text-align:center"><code>u.release()</code></td>
<td style="text-align:center"><code>u</code>放弃对指针的控制权（但不会释放指向对象的内存），返回内置指针，并将<code>u</code>置空。</td>
</tr>
<tr>
<td style="text-align:center"><code>u.reset()</code></td>
<td style="text-align:center">释放<code>u</code>指向的对象</td>
</tr>
<tr>
<td style="text-align:center"><code>u.reset(q)</code></td>
<td style="text-align:center">令<code>u</code>指向内置指针<code>q</code>指向的对象，<code>u</code>原来指向的对象被释放</td>
</tr>
</tbody>
</table>
<ul>
<li>release返回的指针通常用来初始化另一个智能指针(reset)或给智能指针赋值
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="n">p2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span> <span class="n">p3</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">p1</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">// p1放弃了对象的控制权，对象的内存没有释放，而且对象的指针丢失
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">// 使用p保存对象的指针，但是后续需要使用delete(p)释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">release</span><span class="p">());</span> <span class="c1">// u接管p3
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="1213-weak_ptr">12.1.3 weak_ptr</h3>
<h4 id="声明和初始化-2">声明和初始化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">w1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">w2</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span> <span class="c1">// sp是shared_ptr&lt;T&gt;类型, w2指向一个由shared_ptr管理的对象，但是不改变shared_ptr的引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">w3</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// p可以是shared_ptr或weak_ptr
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针。</li>
</ul>
<h4 id="其他操作-2">其他操作</h4>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>w.reset()</code></td>
<td style="text-align:center">将<code>w</code>置为空。</td>
</tr>
<tr>
<td style="text-align:center"><code>w.use_count()</code></td>
<td style="text-align:center">与<code>w</code>共享对象的<code>shared_ptr</code>的数量。</td>
</tr>
<tr>
<td style="text-align:center"><code>w.expired()</code></td>
<td style="text-align:center">若<code>w.use_count()</code>为0，返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td style="text-align:center"><code>w.lock()</code></td>
<td style="text-align:center">如果<code>expired</code>为<code>true</code>，则返回一个空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code>。</td>
</tr>
</tbody>
</table>
<ul>
<li>weak_ptr不能直接访问对象。因为如果shared_ptr被销毁，即使有weak_ptr指向对象，对象仍然可能被释放</li>
<li>使用weak_ptr访问对象时，必须先调用lock函数，以检查指向的对象是否仍然存在
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="122-动态数组">12.2 动态数组</h2>
<p>C++中提供了两种动态数组的分配方式：</p>
<ul>
<li>new动态数组，将内存分配和对象构造结合在一起，对应的delete将对象析构和内存释放结合在一起</li>
<li>使用allocator类，可以实现内存分配与对象构造的分离，管理内存更灵活</li>
</ul>
<h3 id="1221-动态数组">12.2.1 动态数组</h3>
<h4 id="new和动态数组"><code>new</code>和动态数组</h4>
<ul>
<li><code>new</code>一个动态数组，返回指向第一个对象的指针（返回的指针不是数组类型，而是数组元素类型）
<ul>
<li>由于new分配的内存不是数组类型（比如<code>int[10]</code>），因此不能对动态数组调用begin和end，也不能使用range-for遍历元素</li>
</ul>
</li>
<li>new的数组可以进行值初始化、列表初始化
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">sz</span><span class="p">];</span> <span class="c1">// 没有初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">sz</span><span class="p">]();</span> <span class="c1">// 值初始化为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">sz</span><span class="p">]{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="c1">// 列表初始化  
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>因为值初始化时不能提供参数，所以没有默认构造函数的类是无法动态分配数组的。</li>
<li>动态分配一个空数组是合法的，此时返回一个合法的非空指针，类似于尾后指针</li>
<li>使用<code>delete []</code>释放动态分配的数组，使用<code>delete</code>释放动态分配的对象</li>
</ul>
<h4 id="unique_ptr和动态数组"><code>unique_ptr</code>和动态数组</h4>
<p>可以使用unique_ptr管理new分配的数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]());</span> <span class="c1">// p指向一个包含10个元素的int数组，数组元素使用值初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 指向数组的unique_ptr不支持成员访问运算符（点和箭头），支持下标访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">// 自动用delete[]销毁其指针
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="shared_ptr和动态数组"><code>shared_ptr</code>和动态数组</h4>
<ul>
<li><code>shared_ptr</code>不支持直接管理动态数组，如果想用<code>shared_ptr</code>管理动态数组，必须提供自定义的删除器（否则使用delete释放动态数组，报错）</li>
<li><code>shared_ptr</code>未定义下标运算符，智能指针也不支持指针算数运算。可以通过get函数获取内置指针再进行访问</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">](),</span> <span class="p">[](</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span><span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="1222-allocator类">12.2.2 allocator类</h3>
<ul>
<li>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，帮助我们将内存分配和对象构造分离开。</li>
<li>分配的是原始的、未构造的内存，程序需要再内存中构造对象。（直接使用未构造的内存是未定义的行为）</li>
<li>对象使用完之后，需要对每个构造的元素调用destroy进行销毁</li>
</ul>
<h6 id="标准库allocator类及其方法">标准库allocator类及其方法</h6>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>allocator&lt;T&gt; a</code></td>
<td>定义了一个名为<code>a</code>的<code>allocator</code>对象，它可以为类型为<code>T</code>的对象分配内存</td>
</tr>
<tr>
<td><code>a.allocate(n)</code></td>
<td>分配一段原始的、未构造的内存，保存<code>n</code>个类型为<code>T</code>的对象，返回一个指向类型<code>T</code>的指针</td>
</tr>
<tr>
<td><code>a.deallocate(p, n)</code></td>
<td>释放从<code>T*</code>指针<code>p</code>中地址开始的内存，这块内存保存了<code>n</code>个类型为<code>T</code>的对象；<code>p</code>必须是一个先前由<code>allocate</code>返回的指针。且<code>n</code>必须是<code>p</code>创建时所要求的大小。在调用<code>deallocate</code>之前，用户必须对每个在这块内存中创建的对象调用<code>destroy</code>。</td>
</tr>
<tr>
<td><code>a.construct(p, args)</code></td>
<td><code>p</code>必须是一个类型是<code>T*</code>的指针，指向一块原始内存；<code>args</code>被传递给类型为<code>T</code>的构造函数，用来在<code>p</code>指向的内存中构造一个对象。使用时需要<code>p++</code>移动指针</td>
</tr>
<tr>
<td><code>a.destroy(p)</code></td>
<td><code>p</code>为<code>T*</code>类型的指针，此算法对<code>p</code>指向的对象执行析构函数。</td>
</tr>
</tbody>
</table>
<ul>
<li>construct和destroy一次只能构造或销毁一个对象，使用中可能需要使用指针对每个元素进行遍历</li>
</ul>
<h6 id="allocator伴随算法">allocator伴随算法</h6>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>uninitialized_copy(b, e, b2)</code></td>
<td>从【迭代器<code>b</code>和<code>e</code>给定的输入范围】中拷贝元素到【迭代器<code>b2</code>指定的未构造的原始内存】中。<code>b2</code>指向的内存必须足够大，能够容纳输入序列中元素的拷贝。</td>
</tr>
<tr>
<td><code>uninitialized_copy_n(b, n, b2)</code></td>
<td>从迭代器<code>b</code>指向的元素开始，拷贝<code>n</code>个元素到【<code>b2</code>开始的未构造内存】中。</td>
</tr>
<tr>
<td><code>uninitialized_fill(b, e, t)</code></td>
<td>在【迭代器<code>b</code>和<code>e</code>指向的原始内存范围】中创建对象，对象的值均为<code>t</code>的拷贝。</td>
</tr>
<tr>
<td><code>uninitialized_fill_n(b, n, t)</code></td>
<td>从【迭代器<code>b</code>指向的原始内存地址】开始创建<code>n</code>个对象。<code>b</code>必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。</td>
</tr>
</tbody>
</table>
<ul>
<li>进行拷贝和填充未初始化内存</li>
<li>返回最后一个构造元素的尾后位置</li>
</ul>
<h2 id="123-使用标准库文本查询程序">12.3 使用标准库：文本查询程序</h2>
<p><a href="https://note.youdao.com/ynoteshare/index.html?id=2d14bd20c72c482dc96b195231795ab7&amp;type=note&amp;_time=1695087341648">参考</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch11 关联容器</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 27 Feb 2024 15:57:46 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</guid>
      <description>第十一章 关联容器 关联容器基于关键字访问元素，顺序容器基于位置访问元素 关联容器类型 11.2 关联容器概述 关联容器的初始化可以使用直接初始化（圆括号初始</description>
      <content:encoded><![CDATA[<h1 id="第十一章-关联容器">第十一章 关联容器</h1>
<ul>
<li>关联容器基于关键字访问元素，顺序容器基于位置访问元素</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=16110e06-66cf-a0f0-d524-7a3218cd59e7&amp;page=400&amp;rect=236.880,402.480,290.160,409.920">关联容器类型</a></li>
</ul>
<h2 id="112-关联容器概述">11.2 关联容器概述</h2>
<ul>
<li>关联容器的初始化可以使用直接初始化（圆括号初始化）、列表初始化、拷贝初始化、迭代器范围初始化（会对关键字自动去重）</li>
<li><code>map</code>类型通常被称为关联数组</li>
<li>对于有序容器，关键字类型必须定义元素比较的方法（即<code>&lt;</code>），<strong>严格弱序</strong></li>
<li>pair类型
<ul>
<li>定义在<code>utility</code>头文件</li>
<li>map中的每个元素都是一个pair类型的对象，pair是一个模板类型，保存两个名为first和second的共有数据成员，first保存关键字，second保存值</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pair&lt;T1, T2&gt; p;</code></td>
<td><code>p</code>是一个<code>pair</code>，两个类型分别是<code>T1</code>和<code>T2</code>的成员都进行了值初始化。</td>
</tr>
<tr>
<td><code>pair&lt;T1, T2&gt; p(v1, v2);</code></td>
<td><code>first</code>和<code>second</code>分别用<code>v1</code>和<code>v2</code>进行初始化。</td>
</tr>
<tr>
<td><code>pair&lt;T1, T2&gt;p = {v1, v2};</code></td>
<td>等价于`p(v1, v2)</td>
</tr>
<tr>
<td><code>make_pair(v1, v2);</code></td>
<td><code>pair</code>的类型从<code>v1</code>和<code>v2</code>的类型推断出来。</td>
</tr>
<tr>
<td><code>p.first</code></td>
<td>返回<code>p</code>的名为<code>first</code>的数据成员。</td>
</tr>
<tr>
<td><code>p.second</code></td>
<td>返回<code>p</code>的名为<code>second</code>的数据成员。</td>
</tr>
<tr>
<td><code>p1 relop p2</code></td>
<td>relop(relational operations,&lt;,&gt;,&lt;=,&gt;=)，运算关系符按字典序定义。</td>
</tr>
<tr>
<td><code>p1 == p2</code></td>
<td>必须两对元素两两相等</td>
</tr>
<tr>
<td><code>p1 != p2</code></td>
<td>同上</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 定义一个重载键类型的类，重载()操作符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">MyCmp</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();}</span>    
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">MyCmp</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">{{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;ab&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">}};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();}</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mp2</span><span class="p">({{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">}},</span> <span class="n">cmp</span><span class="p">);</span> <span class="c1">// 模板中传入函数类型，构造函数中传入函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">CMP</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">CMP</span><span class="o">&gt;</span> <span class="n">mp3</span><span class="p">({{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">}},</span> <span class="n">cmp</span><span class="p">);</span> <span class="c1">// 或者模板中传入函数类型的别名，构造函数中同样传入函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">cmp</span><span class="p">)</span><span class="o">*&gt;</span> <span class="n">mp4</span><span class="p">({{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">}},</span> <span class="n">cmp</span><span class="p">);</span> <span class="c1">// 使用decltype获取函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">CMP</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">mp3</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">mp3</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="c1">// 或者使用map&lt;string, int&gt;::iterator iter也可以
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="s">&#34; &#34;</span> <span class="o">&gt;&gt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&gt;&gt;</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="113-关联容器操作">11.3 关联容器操作</h2>
<ul>
<li>关联容器额外的类型别名：</li>
</ul>
<table>
<thead>
<tr>
<th>类型别名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key_type</code></td>
<td>此容器类型的关键字类型</td>
</tr>
<tr>
<td><code>mapped_type</code></td>
<td>每个关键字关联的类型，只适用于<code>map</code>系列</td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>对于<code>map</code>，是<code>pair&lt;const key_type, mapped_type&gt;</code>（注意关键字部分有const）; 对于<code>set</code>，和<code>key_type</code>相同。</td>
</tr>
</tbody>
</table>
<ul>
<li>解引用一个关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的值的引用。
<ul>
<li><code>map</code>而言，value_type是pair类型（<code>pair&lt;const key_type, mapped_type&gt;</code>）</li>
<li><code>set</code>而言，value_type是<code>const key_type</code>，普通迭代器和const迭代器都是只读的，不能修改值</li>
</ul>
</li>
</ul>
<h3 id="添加元素insert">添加元素：<code>insert</code></h3>
<table>
<thead>
<tr>
<th><code>insert</code>操作</th>
<th>关联容器</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.insert(v)</code>  <code>c.emplace(args)</code></td>
<td><code>v</code>是<code>value_type</code>类型的对象；<code>args</code>用来构造一个元素。函数返回一个<code>pair</code>，指向具有指定关键字的元素的迭代器，和一个指示插入是否成功的<code>bool</code>值。</td>
</tr>
<tr>
<td><code>c.insert(b, e)</code> <code>c.insert(il)</code></td>
<td><code>b</code>和<code>e</code>是迭代器，表示一个<code>c::value_type</code>类型值的范围；<code>il</code>是这种值的花括号列表。函数返回<code>void</code>。对于 <code>map</code>和<code>set</code>，只插入关键字不在<code>c</code>中的元素。</td>
</tr>
<tr>
<td><code>c.insert(p, v)</code>  <code>c.emplace(p, args)</code></td>
<td>类似<code>insert(v)</code>，但将迭代器<code>p</code>作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。</td>
</tr>
</tbody>
</table>
<ul>
<li>向<code>map</code>添加元素（在参数列表中构建pair），例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>相对于下标操作，多使用insert（因为有返回值）
<ul>
<li>例子：wordcount
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">word</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">word</span><span class="p">,</span> <span class="mi">0</span><span class="p">}).</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="删除元素erase">删除元素：<code>erase</code></h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.erase(k)</code></td>
<td>从<code>c</code>中删除每个关键字为<code>k</code>的元素。返回一个<code>size_type</code>值，指出删除的元素的数量。（顺序容器没有该操作）</td>
</tr>
<tr>
<td><code>c.erase(p)</code></td>
<td>从<code>c</code>中删除迭代器<code>p</code>指定的元素。<code>p</code>必须指向<code>c</code>中一个真实元素，不能等于<code>c.end()</code>。返回一个指向<code>p</code>之后元素的迭代器。</td>
</tr>
<tr>
<td><code>c.erase(b, e)</code></td>
<td>删除迭代器对<code>b</code>和<code>e</code>所表示范围中的元素。返回<code>e</code>。</td>
</tr>
</tbody>
</table>
<ul>
<li>注意遍历容器删除元素时，map与vector不同</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">){</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="o">++</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">        <span class="n">iter</span><span class="o">++</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">){</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="n">iter</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">        <span class="n">iter</span><span class="o">++</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="下标操作">下标操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c[k]</code></td>
<td>返回关键字为<code>k</code>的元素；如果<code>k</code>不在<code>c</code>中，添加一个关键字为<code>k</code>的元素，对其值初始化。</td>
</tr>
<tr>
<td><code>c.at(k)</code></td>
<td>访问关键字为<code>k</code>的元素，带参数检查；若<code>k</code>不存在在<code>c</code>中，抛出一个<code>out_of_range</code>异常。</td>
</tr>
</tbody>
</table>
<ul>
<li>下标和<code>at</code>操作只适用于非<code>const</code>的<code>map</code>和<code>unordered_map</code>，即使访问操作也不行</li>
<li>map的下标操作只能返回非常量引用，如果map本身是常量，则无法使用下标访问元素，只能使用at函数</li>
</ul>
<h3 id="查找元素">查找元素</h3>
<p><strong>在一个关联容器中查找元素</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.find(k)</code></td>
<td>返回一个迭代器，指向第一个关键字为<code>k</code>的元素，若<code>k</code>不在容器中，则返回尾后迭代器</td>
</tr>
<tr>
<td><code>c.count(k)</code></td>
<td>返回关键字等于<code>k</code>的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1。</td>
</tr>
<tr>
<td><code>c.lower_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>大于等于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.upper_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>大于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.equal_range(k)</code></td>
<td>返回一个迭代器<code>pair</code>，表示关键字等于<code>k</code>的元素的范围。若<code>k</code>不存在，<code>pair</code>的两个成员均等于<code>c.end()</code>。</td>
</tr>
</tbody>
</table>
<ul>
<li><code>lower_bound</code>和<code>upper_bound</code>不适用于无序容器。</li>
<li>如果<code>multimap</code>或<code>multiset</code>中有多个元素有相同关键字，则这些元素在容器中会相邻存储</li>
</ul>
<h2 id="114-无序容器">11.4 无序容器</h2>
<ul>
<li>有序容器使用比较运算符来组织元素；无序容器使用哈希函数和关键字类型的<code>==</code>运算符。</li>
<li>无序容器在存储上组织为一组桶(bucket)，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。无序容器首先计算元素的哈希值，找到应该搜索哪个桶（相同哈希值的元素保存到相同的桶中），再搜索桶。
<strong>无序容器管理操作</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>桶接口</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.bucket_count()</code></td>
<td>正在使用的桶的数目</td>
</tr>
<tr>
<td><code>c.max_bucket_count()</code></td>
<td>容器能容纳的最多的桶的数目</td>
</tr>
<tr>
<td><code>c.bucket_size(n)</code></td>
<td>第<code>n</code>个桶中有多少个元素</td>
</tr>
<tr>
<td><code>c.bucket(k)</code></td>
<td>关键字为<code>k</code>的元素在哪个桶中</td>
</tr>
<tr>
<td><strong>桶迭代</strong></td>
<td></td>
</tr>
<tr>
<td><code>local_iterator</code></td>
<td>可以用来访问桶中元素的迭代器类型</td>
</tr>
<tr>
<td><code>const_local_iterator</code></td>
<td>桶迭代器的<code>const</code>版本</td>
</tr>
<tr>
<td><code>c.begin(n)</code>，<code>c.end(n)</code></td>
<td>桶<code>n</code>的首元素迭代器</td>
</tr>
<tr>
<td><code>c.cbegin(n)</code>，<code>c.cend(n)</code></td>
<td>与前两个函数类似，但返回<code>const_local_iterator</code>。</td>
</tr>
<tr>
<td><strong>哈希策略</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.load_factor()</code></td>
<td>每个桶的平均元素数量，返回<code>float</code>值。</td>
</tr>
<tr>
<td><code>c.max_load_factor()</code></td>
<td><code>c</code>试图维护的平均比桶大小，返回<code>float</code>值。<code>c</code>会在需要时添加新的桶，以使得<code>load_factor&lt;=max_load_factor</code></td>
</tr>
<tr>
<td><code>c.rehash(n)</code></td>
<td>重组存储，使得<code>bucket_count&gt;=n</code>，且<code>bucket_count&gt;size/max_load_factor</code></td>
</tr>
<tr>
<td><code>c.reverse(n)</code></td>
<td>重组存储，使得<code>c</code>可以保存<code>n</code>个元素且不必<code>rehash</code>。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch10 泛型算法</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 27 Feb 2024 15:57:36 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</guid>
      <description>第十章 泛型算法 10.1 泛型算法 泛型算法本身不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作 必要的编程假定：算法（注意是标准库中的算法</description>
      <content:encoded><![CDATA[<h1 id="第十章-泛型算法">第十章 泛型算法</h1>
<h2 id="101-泛型算法">10.1 泛型算法</h2>
<ul>
<li>泛型算法本身不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作</li>
<li>必要的编程假定：算法（注意是标准库中的算法）永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但<strong>不能直接添加或者删除元素</strong>。</li>
</ul>
<h2 id="102-初识泛型算法">10.2 初识泛型算法</h2>
<h3 id="只读算法">只读算法</h3>
<ul>
<li>最好使用<code>cbegin</code>和<code>cend</code>。</li>
<li><code>accumulate</code>函数：计算一个序列的和。序列中的元素必须与第三个元素匹配，或者能转换为第三个参数的类型（accumulate函数是模板函数，类型由第三个参数推导而来，此类型决定了使用哪种加法运算符）</li>
<li><code>find</code>函数：接受一对迭代器范围和目标查找值，如果找到，则返回对应的迭代器，否则返回尾后迭代器</li>
<li><code>find_if</code>函数：接受一对迭代器范围和一个谓词，对范围内的每个元素调用给定谓词进行判断，返回第一个使谓词返回非零的元素，否则返回尾后迭代器。</li>
<li><code>find_first_of</code>，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的<code>end</code>迭代器。</li>
<li><code>equal</code>：确定两个序列是否保存相同的值。（顺序也相同）</li>
</ul>
<h3 id="写容器元素的算法">写容器元素的算法</h3>
<ul>
<li>修改算法
<ul>
<li><code>fill</code>： <code>fill(vec.begin(), vec.end(), 0);</code></li>
<li><code>fill_n</code>： <code>fill_n(vec.begin(), len, 0);</code></li>
<li><code>for_each</code>函数：接受一对迭代器和一个谓词，对范围内的每个元素调用谓词</li>
<li><code>transform</code>函数：接受三个迭代器和一个谓词，前两个迭代器指定一个输入序列的范围，第三个迭代器指定目的位置，它对输入序列中的每个元素调用谓词，并将结果写入到目的位置。</li>
</ul>
</li>
<li>拷贝算法
<ul>
<li><code>copy (src.begin(), src.end(), dst.begin());</code>前两个参数指定输入范围，第三个指向目标序列的起始位置。</li>
<li><code>replace(src.begin(), src.end(), old, new)</code>：将范围内old替换为new</li>
<li><code>replace_copy(src.begin(), src.end(), dst.begin(), old, new)</code>：基本同replace，但是保留原范围不变，将替换后的结果保存到dst位置</li>
<li>很多算法都提供copy版本，不会将新元素放回原序列，而是将结果保存到新序列中</li>
</ul>
</li>
<li>
<h3 id="重排容器元素的算法">重排容器元素的算法</h3>
</li>
<li>排序算法<code>sort</code>：接受两个迭代器，利用元素的<code>&lt;</code>运算符重排元素</li>
<li><code>stable_sort</code></li>
<li>消除重复<code>unique</code>：之前要先调用<code>sort</code>，返回的迭代器指向最后一个不重复元素之后的位置（最后一个不重复元素的尾后位置）；重复的元素在原来容器的后边，并没有真正删除。</li>
</ul>
<h2 id="103-定制操作">10.3 定制操作</h2>
<h3 id="向算法传递函数">向算法传递函数</h3>
<ul>
<li><a href="https://blog.csdn.net/caroline_wendy/article/details/15378055">谓词</a>（<code>predicate</code>）：是一个<strong>可调用的表达式</strong>，返回结果是一个能用作条件的值</li>
<li>接受谓词参数的算法会对输入序列中的元素调用谓词，因此序列的元素类型必须能转换为谓词的参数类型</li>
<li>可以向算法传递四种可调用对象：函数、函数指针、重载了函数调用运算符的类、lambda表达式</li>
</ul>
<h3 id="lambda表达式">lambda表达式</h3>
<ul>
<li>形式：<code>[capture list](parameter list) -&gt; return type {function body}</code>。
<ul>
<li><code>capture list</code>捕获列表是一个由<code>lambda</code>所在函数定义的局部变量的列表（通常为空）。不可忽略。捕获列表只能用于局部非static变量，lambda表达式可以直接使用局部static变量和所在函数之外声明的名字。</li>
<li><code>return type</code>是返回类型。可忽略（省略返回类型时，可以由return返回表达式的类型推断而来，否则返回类型为void），必须使用尾置返回。</li>
<li><code>parameter</code>是参数列表。可忽略（等价于指定空参数列表），不能有默认实参。</li>
<li><code>function body</code>是函数体。不可忽略。</li>
</ul>
</li>
<li>定义一个lambda表达式时，编译器生成一个与lambda对应的未命名的类类型
<ul>
<li>当向函数传递一个lambda时，传递的参数实际上就是这个未命名类的对象。</li>
<li>[[ch14-重载运算与类型转换#<code>lambda</code>是函数对象|lambda是函数对象]]</li>
</ul>
</li>
</ul>
<h3 id="lambda捕获和返回">lambda捕获和返回</h3>
<ul>
<li>捕获：lambda表达式将局部变量包含在捕获列表中，在捕获列表中的参数可以被lambda函数体所使用，<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=882c973c-544f-77c6-5d3d-ae7c1ecb678a&amp;page=378&amp;rect=238.800,400.080,306.010,407.280">lambda 捕获列表</a>
<ul>
<li>值捕获：被值捕获的变量的值是在lambda创建时拷贝，而非调用时拷贝。因此在lambda创建后改变被捕获的变量不会影响lambda中对应的值。</li>
<li>引用捕获：捕获的变量前加<code>&amp;</code>，此时修改局部变量会影响lambda内对应的值，但是必须确保被引用的对象在 lambda 执行时是存在的。</li>
</ul>
</li>
<li>隐式捕获：不显式列出捕获变量，而是编译器进行推断
<ul>
<li><code>&amp;</code>为引用捕获，<code>=</code>为值捕获</li>
</ul>
</li>
<li>混合显式捕获与隐式捕获
<ul>
<li>此时捕获列表第一个元素必须是<code>&amp;</code>或<code>=</code>，指定默认捕获方式，显式捕获的变量必须使用与隐式捕获不同的方式</li>
</ul>
</li>
<li>可变lambda：默认情况下，通过值捕获得到的变量（的拷贝），lambda无法修改其值，如果希望改变，可以在参数列表后加上<code>mutable</code>
<ul>
<li>通过引用捕获的变量，取决于变量是否为const</li>
</ul>
</li>
<li>如果lambda中除了return还有其他语句，此时应该指明返回类型；否则可以省略返回类型</li>
<li>lambda可以作为函数的返回值，此时lambda不能包含引用捕获。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span><span class="n">b</span><span class="o">+=</span><span class="n">c</span><span class="p">;</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;};</span> <span class="c1">// 隐式的值捕获(a),显式的引用捕获(b)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span><span class="n">a</span><span class="o">+=</span><span class="n">c</span><span class="p">;};</span> <span class="c1">// 隐式的引用捕获(a),显式的值捕获(b)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">gg</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span><span class="n">b</span><span class="o">+=</span><span class="n">c</span><span class="p">;</span> <span class="n">a</span><span class="o">+=</span><span class="n">c</span><span class="p">;</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">ff</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span><span class="n">b</span><span class="o">+=</span><span class="n">c</span><span class="p">;</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="参数绑定">参数绑定</h3>
<ul>
<li>例子：找到vector中第一个大于val的元素，即需要将二元谓词包装成一元谓词，可以使用bind绑定第二个参数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isBigger</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">isBigger</span><span class="p">);</span> <span class="c1">// 错误，find_if只能接受一元谓词，但是isBigger是二元谓词，可以使用bind进行参数绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bind</span><span class="p">(</span><span class="n">isBigger</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">val</span><span class="p">;};</span> <span class="c1">// 可以使用lambda表达式
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>标准库<code>bind</code>函数：<code>auto newCallable = bind(callable, arg_list);</code>
<ul>
<li>定义在头文件<code>functional</code>中，接受一个可调用对象和一些实参，生成一个新的可调用对象</li>
<li>我们在调用<code>newCallable</code>的时候，<code>newCallable</code>会调用<code>callable</code>并传递给它<code>arg_list</code>中的参数（将绑定的参数拷贝过去）。</li>
</ul>
</li>
<li>参数绑定和重排：<code>std::placeholder::_n</code>表示将<code>newCallable</code>的第n个参数放在占位符<code>_n</code>的位置</li>
<li>绑定引用参数：
<ul>
<li><code>ref</code>函数接受一个参数，返回一个可以拷贝的对象，该对象含有参数的引用。</li>
<li><code>cref</code>返回const的引用</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">show</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">d</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">e</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">out</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span><span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">d</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">e</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">show</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span> <span class="c1">// 将g的第一个参数放到placeholders::_1的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">show</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">);</span> <span class="c1">// 重排参数顺序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">g</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// 将e放到placeholders::_1的位置，将c放到placeholders::_2的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">h</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// show(a, b, _1, d, _2), 其中_1是e，_2是c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span> <span class="o">=</span> <span class="n">cout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">os</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span> <span class="c1">// 绑定引用参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>    
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="104-再探迭代器">10.4 再探迭代器</h2>
<h3 id="插入迭代器">插入迭代器</h3>
<ul>
<li>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素，定义在头文件iterator中
<ul>
<li><code>back_inserter</code>：创建一个调用<code>push_back</code>操作的迭代器。
<ul>
<li><code>back_inserter</code>是插入器，<code>back_insert_iterator&lt;vector&lt;int&gt;&gt;</code>是插入迭代器类型</li>
</ul>
</li>
<li><code>front_inserter</code>创建一个调用<code>push_front</code>操作的迭代器。</li>
<li><code>inserter</code>创建一个调用<code>insert</code>操作的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被插入到迭代器所指向的元素之前。
<ul>
<li>随着插入过程，inserter永远指向指定的元素，而不是永远指向某个特定的位置</li>
</ul>
</li>
</ul>
</li>
<li>每向插入器赋值一次就相当于调用一次相关操作，<code>*it, ++it, it++</code>等操作虽然存在，但不会有任何作用（仍返回it）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">back_insert_iterator</span><span class="o">&lt;</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">biter</span> <span class="o">=</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// 相当于永远指向尾后位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">front_insert_iterator</span><span class="o">&lt;</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">fiter</span> <span class="o">=</span> <span class="n">front_inserter</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 每赋值一次就相当于调用一次相关操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">biter</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">biter</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">fiter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">fiter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;});</span>  
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="流迭代器">流迭代器</h3>
<ul>
<li>流迭代器将对应的流当作一个特定类型的元素序列来处理
<ul>
<li><code>istream_iterator</code>：读取输入流
<ul>
<li>可以不绑定到流，相当于尾后迭代器</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=636cee62-4cbc-5f60-573a-a6e6aeb138c7&amp;page=386&amp;rect=230.650,377.520,312.490,384.480">istream_iterator 操作</a>：没有赋值操作，解引用操作相当于返回输入流中读取的值，需要递增操作</li>
<li><code>istream_iterator</code>允许使用懒惰求值，即标准库不保证迭代器可以立即从输入流中获取数据，但是保证迭代器第一次解引用操作之前，从流中读取数据的操作已经完成。</li>
</ul>
</li>
<li><code>ostream_iterator</code>：向输出流中写入数据
<ul>
<li><code>ostream_iterator</code>必须绑定到一个指定的流，不允许空的或者尾后位置</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=eccda81b-26b3-f633-d17a-d366513c237b&amp;page=387&amp;rect=216.870,462.809,302.170,472.183">ostream_iterator 操作</a>：赋值操作相当于输出流的输出操作，递增、解引用操作没有意义</li>
<li>向ostream_iterator赋值时，可以省略解引用和递增运算（实际上解引用和递增操作不会对ostream_iterator做任何事情）。但是不推荐省略，可以保持迭代器行为的一致性，便于修改。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_iter</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span> <span class="c1">// 可以将流迭代器绑定到一个流（输入流读取操作 就相当于 从流迭代器中取出值，流迭代器累加），
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_eof</span><span class="p">;</span> <span class="c1">// 默认初始化相当于尾后迭代器或eof
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">out_iter</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">);</span> <span class="c1">// 必须将ostream_iterator绑定到一个指定的流, 每个值后面跟着一个C风格字符串str
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 原始方式，注意输入时Ctrl+Z表示eof
</span></span></span><span class="line"><span class="cl"><span class="c1">// vector&lt;int&gt; v;
</span></span></span><span class="line"><span class="cl"><span class="c1">// for(; int_iter != int_eof; ++int_iter){
</span></span></span><span class="line"><span class="cl"><span class="c1">//     v.push_back(*int_iter);
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">int_iter</span><span class="p">,</span> <span class="n">int_eof</span><span class="p">);</span> <span class="c1">// 等价方式，更能体现流迭代器的特点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// for(int i: v){
</span></span></span><span class="line"><span class="cl"><span class="c1">//     *(out_iter++) = i; // 原始方式（先后置递增，返回旧值，再解引用），但是更推荐
</span></span></span><span class="line"><span class="cl"><span class="c1">//     // out_iter = i; // 等价方式，更简略
</span></span></span><span class="line"><span class="cl"><span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">out_iter</span><span class="p">);</span> <span class="c1">// 最简单的写法，将序列范围直接复制到输出迭代器中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// copy(int_iter, int_eof, out_iter); // 直接将输入进行输出  
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="反向迭代器">反向迭代器</h3>
<ul>
<li>递增会移动到前一个元素</li>
<li>调用反向迭代器的base函数可以获得其对应的正向迭代器
<ul>
<li>rbegin()指向的是最后一个元素，而end()指向的是尾后元素；对应的，【反向迭代器】与【其调用base函数得到的正向迭代器】的关系类似于rbegin()与end()，指向的不是相同元素。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=e161d353-c64d-530c-5ed0-8bbc3f7bbdd0&amp;page=389&amp;rect=76.800,427.920,341.280,435.600">图示</a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="n">riter</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="c1">// 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="c1">// 尾后位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">riter</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="p">(</span><span class="o">--</span><span class="n">iter</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 5 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="p">(</span><span class="o">++</span><span class="n">riter</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">riter</span><span class="p">.</span><span class="n">base</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 4 5  
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="移动迭代器">移动迭代器</h3>
<h2 id="105-泛型算法结构">10.5 泛型算法结构</h2>
<h3 id="5类迭代器">5类迭代器</h3>
<ul>
<li>算法所要求的迭代器操作可以分为 5 类，C++ 标准指明了泛型算法的每个迭代器参数的最小类别。</li>
<li><code>vector&lt;int&gt;::iterator</code>迭代器是随机访问迭代器，<code>list&lt;int&gt;::iteraotr</code>迭代器是双向迭代器</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">迭代器类别</th>
<th style="text-align:center">解释</th>
<th style="text-align:center">支持的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">输入迭代器</td>
<td style="text-align:center">只读，不写；单遍扫描，只能递增</td>
<td style="text-align:center"><code>==</code>,<code>!=</code>,<code>++</code>,<code>*</code>,<code>-&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">输出迭代器</td>
<td style="text-align:center">只写，不读；单遍扫描，只能递增</td>
<td style="text-align:center"><code>++</code>,<code>*</code></td>
</tr>
<tr>
<td style="text-align:center">前向迭代器</td>
<td style="text-align:center">可读写；多遍扫描，只能递增</td>
<td style="text-align:center"><code>==</code>,<code>!=</code>,<code>++</code>,<code>*</code>,<code>-&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">双向迭代器</td>
<td style="text-align:center">可读写；多遍扫描，可递增递减</td>
<td style="text-align:center"><code>==</code>,<code>!=</code>,<code>++</code>,<code>--</code>,<code>*</code>,<code>-&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">随机访问迭代器</td>
<td style="text-align:center">可读写，多遍扫描，支持全部迭代器运算</td>
<td style="text-align:center"><code>==</code>,<code>!=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code>,<code>++</code>,<code>--</code>,<code>+</code>,<code>+=</code>,<code>-</code>,<code>-=</code>,<code>*</code>,<code>-&gt;</code>,<code>iter[n]</code>==<code>*(iter[n])</code></td>
</tr>
</tbody>
</table>
<h3 id="算法的形参模式">算法的形参模式</h3>
<ul>
<li><code>alg(beg, end, other args);</code></li>
<li><code>alg(beg, end, dest, other args);</code></li>
<li><code>alg(beg, end, beg2, other args);</code></li>
<li><code>alg(beg, end, beg2, end2, other args);</code>
其中，<code>alg</code>是算法名称，<code>beg</code>和<code>end</code>表示算法所操作的输入范围。<code>dest</code>表示输出范围或输出流迭代器，<code>beg2</code>、<code>end2</code>表示第二个输入范围</li>
</ul>
<h3 id="算法命名规范">算法命名规范</h3>
<ul>
<li>一些算法使用重载形式传递一个谓词，来代替<code>&lt;</code>或<code>==</code>，比如sort</li>
<li>接受谓词参数的算法都有附加的<code>_if</code>后缀，没有的一般都是接受元素值</li>
<li>将执行结果写入额外目的空间的算法都有<code>_copy</code>后缀（即拷贝版本）</li>
</ul>
<h2 id="106-特定容器算法">10.6 特定容器算法</h2>
<ul>
<li>对于<code>list</code>和<code>forward_list</code>，优先使用【成员函数版本的算法】而不是通用算法。</li>
<li>list和forward_list成员函数版本的算法：</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lst.merge(lst2)</code></td>
<td>将来自<code>lst2</code>的元素合并入<code>lst</code>，二者都必须是有序的，元素将从<code>lst2</code>中删除。</td>
</tr>
<tr>
<td><code>lst.merge(lst2, comp)</code></td>
<td>同上，给定比较操作。</td>
</tr>
<tr>
<td><code>lst.remove(val)</code></td>
<td>调用<code>erase</code>删除掉与给定值相等(<code>==</code>)的每个元素</td>
</tr>
<tr>
<td><code>lst.remove_if(pred)</code></td>
<td>调用<code>erase</code>删除掉令一元谓词为真的每个元素</td>
</tr>
<tr>
<td><code>lst.reverse()</code></td>
<td>反转<code>lst</code>中元素的顺序</td>
</tr>
<tr>
<td><code>lst.sort()</code></td>
<td>使用<code>&lt;</code>排序元素</td>
</tr>
<tr>
<td><code>lst.sort(comp)</code></td>
<td>使用给定比较操作排序元素</td>
</tr>
<tr>
<td><code>lst.unique()</code></td>
<td>调用<code>erase</code>删除同一个值的连续拷贝。使用<code>==</code>。</td>
</tr>
<tr>
<td><code>lst.unique(pred)</code></td>
<td>调用<code>erase</code>删除同一个值的连续拷贝。使用给定的二元谓词。</td>
</tr>
</tbody>
</table>
<ul>
<li>上面的操作都返回<code>void</code></li>
<li>链表特有版本的算法操作会改变底层容器
<ul>
<li>list和forward_list的splice函数可以进行容器合并，使用<code>lst.splice(args)</code>或<code>flst.splice_after(args)</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(p, lst2)</code></td>
<td><code>p</code>是一个指向<code>lst</code>中元素的迭代器，或者一个指向<code>flst</code>首前位置的迭代器。函数将<code>lst2</code>中的所有元素移动到<code>lst</code>中<code>p</code>之前的位置或是<code>flst</code>中<code>p</code>之后的位置。将元素从<code>lst2</code>中删除。<code>lst2</code>的类型必须和<code>lst</code>相同，而且不能是同一个链表。</td>
</tr>
<tr>
<td><code>(p, lst2, p2)</code></td>
<td>同上，<code>p2</code>是一个指向<code>lst2</code>中位置的有效的迭代器，将<code>p2</code>指向的元素移动到<code>lst</code>中，或将<code>p2</code>之后的元素移动到<code>flst</code>中。<code>lst2</code>可以是与<code>lst</code>或<code>flst</code>相同的链表。</td>
</tr>
<tr>
<td><code>(p, lst2, b, e)</code></td>
<td><code>b</code>和<code>e</code>表示<code>lst2</code>中的合法范围。将给定范围中的元素从<code>lst2</code>移动到<code>lst</code>或<code>first</code>中。<code>lst2</code>与<code>lst</code>可以使相同的链表，但<code>p</code>不能指向给定范围中的元素。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch09 顺序容器</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 27 Feb 2024 15:57:27 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</guid>
      <description>第九章 顺序容器 9.1 顺序容器概述 顺序容器（sequential container）：元素顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</description>
      <content:encoded><![CDATA[<h1 id="第九章-顺序容器">第九章 顺序容器</h1>
<h2 id="91-顺序容器概述">9.1 顺序容器概述</h2>
<ul>
<li><strong>顺序容器</strong>（sequential container）：元素顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</li>
</ul>
<h3 id="顺序容器类型">顺序容器类型</h3>
<table>
<thead>
<tr>
<th>容器类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vector</code></td>
<td>随机访问，尾部插入/删除快</td>
</tr>
<tr>
<td><code>deque</code></td>
<td>随机访问，头尾插入/删除快</td>
</tr>
<tr>
<td><code>list</code></td>
<td>双向链表。只支持双向顺序访问，任何位置插入/删除都快</td>
</tr>
<tr>
<td><code>forward_list</code></td>
<td>单向链表。只支持单向顺序访问。任何位置插入/删除都快</td>
</tr>
<tr>
<td><code>array</code></td>
<td>固定大小数组，随机访问。不能添加或者删除元素。</td>
</tr>
<tr>
<td><code>string</code></td>
<td>随机访问，尾部插入/删除速度快。</td>
</tr>
</tbody>
</table>
<ul>
<li>list 的额外内存开销相比其他大很多。</li>
<li>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。
<ul>
<li>如果不需要向中间插入数据，则先向vector中添加，再sort</li>
<li>如果一定要向中间插入数据，则先使用list，输入完成后再拷贝到vector中</li>
</ul>
</li>
</ul>
<h2 id="92-容器库概览">9.2 容器库概览</h2>
<h3 id="类型">类型</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iterator</code></td>
<td>此容器类型的迭代器类型</td>
</tr>
<tr>
<td><code>const_iterator</code></td>
<td>可以读取元素但不能修改元素的迭代器类型</td>
</tr>
<tr>
<td><code>size_type</code></td>
<td>无符号整数类型，足够保存此种容器类型最大可能的大小</td>
</tr>
<tr>
<td><code>difference_type</code></td>
<td>带符号整数类型，足够保存两个迭代器之间的距离</td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>元素类型</td>
</tr>
<tr>
<td><code>reference</code></td>
<td>元素的左值类型；和<code>value_type &amp;</code>含义相同</td>
</tr>
<tr>
<td><code>const_reference</code></td>
<td>元素的<code>const</code>左值类型，即<code>const value_type &amp;</code></td>
</tr>
</tbody>
</table>
<ul>
<li>迭代器范围begin和end，其中end是指向尾后地址，左闭右开</li>
<li>当不需要修改时，尽量使用const iterator</li>
</ul>
<h3 id="构造函数">构造函数</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C c;</code></td>
<td>默认构造函数，构造空容器</td>
</tr>
<tr>
<td><code>C c1(c2);</code>或<code>C c1 = c2;</code></td>
<td>构造<code>c2</code>的拷贝<code>c1</code></td>
</tr>
<tr>
<td><code>C c(b, e)</code></td>
<td>构造<code>c</code>，将<strong>迭代器</strong><code>b</code>和<code>e</code>指定范围内的所有元素拷贝到<code>c</code></td>
</tr>
<tr>
<td><code>C c{a, b, c...}</code></td>
<td>列表初始化<code>c</code></td>
</tr>
<tr>
<td><code>C c(n)</code></td>
<td>只支持顺序容器，且不包括<code>array</code>，包含<code>n</code>个元素，这些元素进行了值初始化</td>
</tr>
<tr>
<td><code>C c(n, t)</code></td>
<td>包含<code>n</code>个初始值为<code>t</code>的元素</td>
</tr>
</tbody>
</table>
<ul>
<li>三种构造方式：
<ul>
<li>直接拷贝：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。</li>
<li>迭代器范围构造：不要求容器类型相同，容器内的元素类型也可以不同，但是要能进行类型转换</li>
<li>列表初始化</li>
</ul>
</li>
<li>array初始化
<ul>
<li>定义array需要同时指定元素类型和大小，默认初始化为0</li>
<li>array只能默认初始化或列表初始化，如果定义的数组很大并且需要初始化，可以先默认初始化然后用 fill 函数填充值。</li>
</ul>
</li>
</ul>
<h3 id="赋值和swap">赋值和<code>swap</code></h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c1 = c2;</code></td>
<td>将<code>c1</code>中的元素替换成<code>c2</code>中的元素</td>
</tr>
<tr>
<td><code>c1 = {a, b, c...}</code></td>
<td>将<code>c1</code>中的元素替换成列表中的元素（不适用于<code>array</code>）</td>
</tr>
<tr>
<td><code>c1.swap(c2)</code></td>
<td>交换<code>c1</code>和<code>c2</code>的元素</td>
</tr>
<tr>
<td><code>swap(c1, c2)</code></td>
<td>等价于<code>c1.swap(c2)</code></td>
</tr>
<tr>
<td><code>c.assign(b, e)</code></td>
<td>将<code>c</code>中的元素替换成迭代器<code>b</code>和<code>e</code>表示范围中的元素，<code>b</code>和<code>e</code>不能指向<code>c</code>中的元素，可以用不同但相容的类型赋值，或者用容器的子序列赋值</td>
</tr>
<tr>
<td><code>c.assign(il)</code></td>
<td>将<code>c</code>中的元素替换成初始化列表<code>il</code>中的元素</td>
</tr>
<tr>
<td><code>c.assign(n, r)</code></td>
<td>将<code>c</code>中的元素替换为<code>n</code>个值是<code>t</code>的元素</td>
</tr>
</tbody>
</table>
<ul>
<li>swap：
<ul>
<li>对于array，swap会真正交换它们的元素；对于其他元素，swap不交换元素，只交换数据结构，因此很快</li>
<li>对于 string，swap 后，指针、引用和迭代器会失效。对于其他容器，交换后指针指向了另一个容器的相同位置。</li>
<li>建议统一使用<code>swap(a,b)</code></li>
</ul>
</li>
<li>assign赋值：
<ul>
<li><code>assign</code>操作不适用于关联容器和<code>array</code></li>
<li><code>=</code>赋值要求两边类型相同，assign只要求可以转换即可</li>
</ul>
</li>
<li>array赋值：
<ul>
<li>不能对内置数组拷贝或赋值，但是 array 可以。</li>
<li>使用一个 array 对另一个 array 赋值，需要两个array 元素类型与大小都相同。</li>
<li>不能用花括号列表对 array 赋值（只可以初始化）</li>
</ul>
</li>
</ul>
<h3 id="大小">大小</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.size()</code></td>
<td><code>c</code>中元素的数目（不支持<code>forward_list</code>）</td>
</tr>
<tr>
<td><code>c.max_size()</code></td>
<td><code>c</code>中可保存的最大元素数目</td>
</tr>
<tr>
<td><code>c.empty()</code></td>
<td>若<code>c</code>中存储了元素，返回<code>false</code>，否则返回<code>true</code></td>
</tr>
</tbody>
</table>
<ul>
<li>forward_list支持max_size和empty，但是不支持size</li>
</ul>
<h2 id="93-顺序容器操作">9.3 顺序容器操作</h2>
<h3 id="添加元素">添加元素</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.push_back(t)</code></td>
<td>在<code>c</code>尾部创建一个值为<code>t</code>的元素，返回<code>void</code></td>
</tr>
<tr>
<td><code>c.emplace_back(args)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>c.push_front(t)</code></td>
<td>在<code>c</code>头部创建一个值为<code>t</code>的元素，返回<code>void</code></td>
</tr>
<tr>
<td><code>c.emplace_front(args)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>c.insert(p, t)</code></td>
<td>在迭代器<code>p</code>指向的元素之前创建一个值是<code>t</code>的元素，返回指向新元素的迭代器</td>
</tr>
<tr>
<td><code>c.emplace(p, args)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>c.insert(p, n, t)</code></td>
<td>在迭代器<code>p</code>指向的元素之前插入<code>n</code>个值为<code>t</code>的元素，返回指向第一个新元素的迭代器</td>
</tr>
<tr>
<td><code>c.insert(p, b, e)</code></td>
<td>将迭代器<code>b</code>和<code>e</code>范围内的元素，插入到<code>p</code>指向的元素之前</td>
</tr>
<tr>
<td><code>c.insert(p, il)</code></td>
<td><code>il</code>是一个花括号包围中的元素值列表，将其插入到<code>p</code>指向的元素之前</td>
</tr>
</tbody>
</table>
<ul>
<li>向vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。</li>
<li>头尾添加返回void，中间添加返回指向新添加元素的迭代器</li>
<li>push和insert传递的是元素类型的对象，emplace则将参数传递给元素类型的构造对象
<ul>
<li>传递给emplace的参数必须和元素类型的构造函数相匹配。</li>
</ul>
</li>
<li>insert 返回值是指向添加的元素中第一个元素的迭代器</li>
<li>添加的都是元素的拷贝，不是元素本身。</li>
</ul>
<h3 id="访问元素">访问元素</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.back()</code></td>
<td>返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><code>c.front()</code></td>
<td>返回<code>c</code>中头元素的引用。若<code>c</code>为空，函数行为未定义</td>
</tr>
<tr>
<td><code>c[n]</code></td>
<td>返回<code>c</code>中下标是<code>n</code>的元素的引用，<code>n</code>时候一个无符号整数。若<code>n&gt;=c.size()</code>，则函数行为未定义</td>
</tr>
<tr>
<td><code>c.at(n)</code></td>
<td>返回下标为<code>n</code>的元素引用。如果下标越界，则抛出<code>out_of_range</code>异常</td>
</tr>
</tbody>
</table>
<ul>
<li>访问成员函数返回的是引用。</li>
</ul>
<h3 id="删除元素">删除元素</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.pop_back()</code></td>
<td>删除<code>c</code>中尾元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td>
</tr>
<tr>
<td><code>c.pop_front()</code></td>
<td>删除<code>c</code>中首元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td>
</tr>
<tr>
<td><code>c.erase(p)</code></td>
<td>删除迭代器<code>p</code>指向的元素，返回一个指向被删除元素之后的元素的迭代器，若<code>p</code>本身是尾后迭代器，则函数行为未定义</td>
</tr>
<tr>
<td><code>c.erase(b, e)</code></td>
<td>删除迭代器<code>[b,e)</code>内的元素，返回指向最后一个被删元素之后元素的迭代器，若<code>e</code>本身就是尾后迭代器，则返回尾后迭代器</td>
</tr>
<tr>
<td><code>c.clear()</code></td>
<td>删除<code>c</code>中所有元素，返回<code>void</code></td>
</tr>
</tbody>
</table>
<ul>
<li>头尾删除返回void，特定位置删除，返回被删除元素之后元素的迭代器</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=dd002dda-960e-9445-3aa0-2abd00fd6c03&amp;page=341&amp;rect=98.640,543.263,241.920,556.097">添加、删除操作可能使迭代器失效</a></li>
</ul>
<h3 id="特殊的forward_list操作">特殊的forward_list操作</h3>
<ul>
<li>forward_list 是单向链表，添加和删除操作都会同时改变前驱和后继结点</li>
<li><code>forward_list</code>定义了<code>before_begin()</code>，即【首前（off-the-beginning）迭代器】，允许我们再在首元素之前添加或删除元素。</li>
<li>前面的insert都是在当前元素之前插入，insert_after插入到当前元素之后</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lst.before_begin()</code></td>
<td>返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。</td>
</tr>
<tr>
<td><code>lst.cbefore_begin()</code></td>
<td>同上，但是返回的是常量迭代器。</td>
</tr>
<tr>
<td><code>lst.insert_after(p, t)</code></td>
<td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象</td>
</tr>
<tr>
<td><code>lst.insert_after(p, n, t)</code></td>
<td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象，<code>n</code>是数量。若<code>n</code>是0则函数行为未定义</td>
</tr>
<tr>
<td><code>lst.insert_after(p, b, e)</code></td>
<td>在迭代器<code>p</code>之后插入元素。由迭代器<code>b</code>和<code>e</code>指定范围。</td>
</tr>
<tr>
<td><code>lst.insert_after(p, il)</code></td>
<td>在迭代器<code>p</code>之后插入元素。由<code>il</code>指定初始化列表。</td>
</tr>
<tr>
<td><code>lst.emplace_after(p, args)</code></td>
<td>使用<code>args</code>在<code>p</code>之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若<code>p</code>为尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td><code>lst.erase_after(p)</code></td>
<td>删除<code>p</code>指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若<code>p</code>指向<code>lst</code>的尾元素或者是一个尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td><code>lst.erase_after(b, e)</code></td>
<td>类似上面，删除对象换成从<code>(b,e)</code>指定的范围。</td>
</tr>
</tbody>
</table>
<h3 id="改变容器大小">改变容器大小</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.resize(n)</code></td>
<td>调整<code>c</code>的大小为<code>n</code>个元素，若<code>n&lt;c.size()</code>，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</td>
</tr>
<tr>
<td><code>c.resize(n, t)</code></td>
<td>调整<code>c</code>的大小为<code>n</code>个元素，任何新添加的元素都初始化为值<code>t</code></td>
</tr>
</tbody>
</table>
<h3 id="迭代器">迭代器</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.begin()</code>, <code>c.end()</code></td>
<td>返回指向<code>c</code>的首元素和尾元素之后位置的迭代器</td>
</tr>
<tr>
<td><code>c.cbegin()</code>, <code>c.cend()</code></td>
<td>返回<code>const_iterator</code></td>
</tr>
<tr>
<td><code>c.rbegin()</code>, <code>c.rend()</code></td>
<td>返回指向<code>c</code>的尾元素和首元素之前位置的迭代器</td>
</tr>
<tr>
<td><code>c.crbegin()</code>, <code>c.crend()</code></td>
<td>返回<code>const_reverse_iterator</code></td>
</tr>
</tbody>
</table>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=dd002dda-960e-9445-3aa0-2abd00fd6c03&amp;page=341&amp;rect=98.640,543.263,241.920,556.097">添加、删除操作可能使迭代器失效</a>
<ul>
<li>在向容器添加元素后：
<ul>
<li>如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。</li>
<li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。</li>
<li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器、指针和引用依然有效。</li>
</ul>
</li>
<li>在从一个容器中删除元素后：尾后迭代器总是会失效
<ul>
<li>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器、引用和指针仍然有效。</li>
<li>对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除<code>deque</code>的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是<code>deque</code>的头元素，这些也不会受影响。</li>
<li>对于<code>vector</code>和<code>string</code>，指向被删元素之前的迭代器、引用、指针仍然有效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="94-vector对象是如何增长的">9.4 vector对象是如何增长的</h2>
<p><code>vector</code>和<code>string</code>在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。</p>
<h3 id="管理容量的成员函数">管理容量的成员函数</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.shrink_to_fit()</code></td>
<td>将<code>capacity()</code>减少到和<code>size()</code>相同大小</td>
</tr>
<tr>
<td><code>c.capacity()</code></td>
<td>不重新分配内存空间的话，<code>c</code>可以保存多少个元素</td>
</tr>
<tr>
<td><code>c.reverse(n)</code></td>
<td>分配至少能容纳<code>n</code>个元素的内存空间(预分配，而且如果需求容量小于当前容量，什么都不做)</td>
</tr>
</tbody>
</table>
<ul>
<li><code>shrink_to_fit</code>只适用于<code>vector</code>、<code>string</code>和<code>deque</code></li>
<li><code>capacity</code>和<code>reverse</code>只适用于<code>vector</code>和<code>string</code>。</li>
</ul>
<h2 id="95-额外的string操作">9.5 额外的string操作</h2>
<h3 id="构造string的其他方法">构造string的其他方法</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string s(cp, n)</code></td>
<td><code>s</code>是<code>cp</code>指向的数组中前<code>n</code>个字符的拷贝，此数组至少有n个字符</td>
</tr>
<tr>
<td><code>string s(s2, pos2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符到末尾的拷贝。若<code>pos2 &gt; s2.size()</code>，则构造函数的行为未定义。</td>
</tr>
<tr>
<td><code>string s(s2, pos2, len2)</code></td>
<td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的<code>len2</code>个字符的拷贝。</td>
</tr>
</tbody>
</table>
<ul>
<li>最初的构造函数：直接初始化（圆括号初始化）、迭代器范围初始化、列表初始化</li>
</ul>
<h3 id="substr操作">substr操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.substr(pos, n)</code></td>
<td>返回一个<code>string</code>，包含<code>s</code>中从<code>pos</code>开始的<code>n</code>个字符的拷贝。</td>
</tr>
</tbody>
</table>
<h3 id="改变string的其他方法">改变string的其他方法</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.insert(pos, args)</code></td>
<td>在<code>pos</code>之前插入<code>args</code>指定的字符。<code>pos</code>可以使是下标或者迭代器。接受下标的版本返回指向<code>s</code>的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td>
</tr>
<tr>
<td><code>s.erase(pos, len)</code></td>
<td>删除从<code>pos</code>开始的<code>len</code>个字符，如果<code>len</code>被省略，则删除后面所有字符，返回指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.assign(args)</code></td>
<td>将<code>s</code>中的字符替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。（args不变）</td>
</tr>
<tr>
<td><code>s.append(args)</code></td>
<td>将<code>args</code>指定的字符追加到<code>s</code>，返回一个指向<code>s</code>的引用。</td>
</tr>
<tr>
<td><code>s.replace(range, args)</code></td>
<td>删除<code>s</code>中范围<code>range</code>中的字符，替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td>
</tr>
</tbody>
</table>
<h3 id="string搜索操作">string搜索操作</h3>
<ul>
<li><code>string</code>类提供了6个不同的搜索函数，每个函数都有4个重载版本。</li>
<li>每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。如果搜索失败则返回一个名为<code>string::npos</code>的<code>static</code>成员（类型是<code>string::size_type</code>，初始化值是-1，也就是<code>string</code>最大的可能大小）。</li>
</ul>
<table>
<thead>
<tr>
<th>搜索操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.find(args)</code></td>
<td>查找<code>s</code>中<code>args</code>第一次出现的位置</td>
</tr>
<tr>
<td><code>s.rfind(args)</code></td>
<td>查找<code>s</code>中<code>args</code>最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_of(args)</code></td>
<td>在<code>s</code>中查找<code>args</code>中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_last_of(args)</code></td>
<td>在<code>s</code>中查找<code>args</code>中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>在<code>s</code>中查找第一个不在<code>args</code>中的字符</td>
</tr>
<tr>
<td><code>s.find_first_not_of(args)</code></td>
<td>在<code>s</code>中查找最后一个不在<code>args</code>中的字符</td>
</tr>
</tbody>
</table>
<p>args必须是一下的形式之一：</p>
<table>
<thead>
<tr>
<th><code>args</code>形式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c, pos</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找字符<code>c</code>。<code>pos</code>默认是0</td>
</tr>
<tr>
<td><code>s2, pos</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找字符串<code>s2</code>。<code>pos</code>默认是0</td>
</tr>
<tr>
<td><code>cp, pos</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的以空字符结尾的C风格字符串。<code>pos</code>默认是0</td>
</tr>
<tr>
<td><code>cp, pos, n</code></td>
<td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的前<code>n</code>个字符。<code>pos</code>和<code>n</code>无默认值。</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 使用pos循环查找所有str包含的字符的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">((</span><span class="n">pos</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span> <span class="o">!=</span> <span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">pos</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="scompare的几种参数形式">s.compare的几种参数形式</h3>
<p>逻辑类似于C标准库的<code>strcmp</code>函数，根据<code>s</code>是等于、大于还是小于参数指定的字符串，<code>s.compare</code>返回0、正数或负数。</p>
<table>
<thead>
<tr>
<th>参数形式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s2</code></td>
<td>比较<code>s</code>和<code>s2</code></td>
</tr>
<tr>
<td><code>pos1, n1, s2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td>
</tr>
<tr>
<td><code>pos1, n1, s2, pos2, n2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code>从pos2开始的n2个字符</td>
</tr>
<tr>
<td><code>cp</code></td>
<td>比较<code>s</code>和<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td><code>pos1, n1, cp</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td><code>pos1, n1, cp, n2</code></td>
<td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的地址开始<code>n2</code>个字符</td>
</tr>
</tbody>
</table>
<h3 id="string和数值转换">string和数值转换</h3>
<table>
<thead>
<tr>
<th>转换</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>to_string(val)</code></td>
<td>一组重载函数，返回数值<code>val</code>的<code>string</code>表示</td>
</tr>
<tr>
<td><code>stoi(s, p, b)</code></td>
<td>返回<code>s</code>起始子串（表示整数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0，<code>b</code>是转换所用的基数。返回<code>int</code></td>
</tr>
</tbody>
</table>
<h2 id="96-容器适配器adapter">9.6 容器适配器（adapter）</h2>
<ul>
<li><strong>适配器</strong>是使一事物的行为看起来像另一事物的行为的一种机制，例如<code>stack</code>可以使任何一种顺序容器以栈的方式工作。</li>
<li>默认情况下，stack和queue是基于deque实现的，priority_queue是基于vector实现的，基础容器不能是array和forward_list
<ul>
<li>因此可以直接使用一个deque来初始化stack和queue，使用一个有序vector初始化priority_queue</li>
<li>也可以指定实现的顺序容器： <code>stack&lt;string, vector&lt;string&gt; &gt; str_stk;</code></li>
</ul>
</li>
</ul>
<h3 id="适配器的通用操作和类型">适配器的通用操作和类型</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size_type</code></td>
<td>一种类型，须以保存当前类型的最大对象的大小</td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>元素类型</td>
</tr>
<tr>
<td><code>container_type</code></td>
<td>实现适配器的底层容器类型</td>
</tr>
<tr>
<td><code>A a;</code></td>
<td>创建一个名为<code>a</code>的空适配器</td>
</tr>
<tr>
<td><code>A a(c)</code></td>
<td>创建一个名为<code>a</code>的适配器，带有容器<code>c</code>的一个拷贝</td>
</tr>
<tr>
<td>关系运算符</td>
<td>每个适配器都支持所有关系运算符：<code>==</code>、<code>!=</code>、<code>&lt;</code>、 <code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>这些运算符返回底层容器的比较结果</td>
</tr>
<tr>
<td><code>a.empty()</code></td>
<td>若<code>a</code>包含任何元素，返回<code>false</code>;否则返回<code>true</code></td>
</tr>
<tr>
<td><code>a.size()</code></td>
<td>返回<code>a</code>中的元素数目</td>
</tr>
<tr>
<td><code>swap(a, b)</code></td>
<td>交换<code>a</code>和<code>b</code>的内容，<code>a</code>和<code>b</code>必须有相同类型，包括底层容器类型也必须相同</td>
</tr>
<tr>
<td><code>a.swap(b)</code></td>
<td>同上</td>
</tr>
</tbody>
</table>
<h3 id="stack">stack</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.pop()</code></td>
<td>删除栈顶元素，不返回。</td>
</tr>
<tr>
<td><code>s.push(item)</code></td>
<td>创建一个新元素，压入栈顶，该元素通过拷贝或移动<code>item</code>而来</td>
</tr>
<tr>
<td><code>s.emplace(args)</code></td>
<td>同上，但元素由<code>args</code>来构造。</td>
</tr>
<tr>
<td><code>s.top()</code></td>
<td>返回栈顶元素，不删除。</td>
</tr>
</tbody>
</table>
<ul>
<li>定义在<code>stack</code>头文件中。</li>
<li>stack可以基于deque（默认）、list、vector实现</li>
</ul>
<h3 id="queue和priority_queue">queue和priority_queue</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>q.pop()</code></td>
<td>删除队首元素，但不返回。</td>
</tr>
<tr>
<td><code>q.front()</code></td>
<td>返回队首元素的值，不删除。</td>
</tr>
<tr>
<td><code>q.back()</code></td>
<td>返回队尾元素的值，不删除。只适用于<code>queue</code></td>
</tr>
<tr>
<td><code>q.top()</code></td>
<td>返回具有最高优先级的元素值，不删除。</td>
</tr>
<tr>
<td><code>q.push(item)</code></td>
<td>在队尾压入一个新元素。</td>
</tr>
<tr>
<td><code>q.emplace(args)</code></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>定义在<code>queue</code>头文件中。</li>
<li>queue可以基于deque（默认）、list、vector实现，priority_queue可以基于deque（默认）、vector实现</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch08 IO库</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch08-io%E5%BA%93/</link>
      <pubDate>Tue, 27 Feb 2024 15:57:17 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch08-io%E5%BA%93/</guid>
      <description>第八章 IO库 前面章节已经在用的IO库设施 istream：输入流类型，提供输入操作。 ostream：输出流类型，提供输出操作 cin：一个ist</description>
      <content:encoded><![CDATA[<h1 id="第八章-io库">第八章 IO库</h1>
<h2 id="前面章节已经在用的io库设施">前面章节已经在用的IO库设施</h2>
<ul>
<li><strong>istream</strong>：输入流类型，提供输入操作。</li>
<li><strong>ostream</strong>：输出流类型，提供输出操作</li>
<li><strong>cin</strong>：一个<code>istream</code>对象，从标准输入读取数据。</li>
<li><strong>cout</strong>：一个<code>ostream</code>对象，向标准输出写入数据。</li>
<li><strong>cerr</strong>：一个<code>ostream</code>对象，向标准错误写入消息。</li>
<li><strong>&raquo;运算符</strong>：用来从一个<code>istream</code>对象中读取输入数据。</li>
<li><strong>&laquo;运算符</strong>：用来向一个<code>ostream</code>对象中写入输出数据。</li>
<li><strong>getline函数</strong>：从一个给定的<code>istream</code>对象中读取一行数据，存入到一个给定的<code>string</code>对象中。</li>
</ul>
<h2 id="81-io类">8.1 IO类</h2>
<h3 id="标准库定义的io类型">标准库定义的IO类型</h3>
<ul>
<li><code>iostream</code>头文件：从标准流中读写数据，<code>istream</code>、<code>ostream</code>等。</li>
<li><code>fstream</code>头文件：从文件中读写数据，<code>ifstream</code>、<code>ofstream</code>等。</li>
<li><code>sstream</code>头文件：从内存string中读写数据，<code>istringstream</code>、<code>ostringstream</code></li>
</ul>
<h3 id="io对象不可复制或赋值">IO对象不可复制或赋值</h3>
<ul>
<li>不能拷贝或赋值IO对象，因此形参和返回类型也不能是流类型，一般是流的<strong>引用</strong>。</li>
<li>读写一个IO对象会改变其状态，因此引用不能是<code>const</code>的。</li>
</ul>
<h3 id="条件状态">条件状态</h3>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>strm:iostate</code></td>
<td>是一种机器无关的<strong>类型</strong>，提供了表达条件状态的完整功能</td>
</tr>
<tr>
<td><code>strm:badbit</code></td>
<td>用来指出流已经崩溃（不可恢复的读写错误，此时流无法使用）</td>
</tr>
<tr>
<td><code>strm:failbit</code></td>
<td>用来指出一个IO操作失败了（可恢复的错误）</td>
</tr>
<tr>
<td><code>strm:eofbit</code></td>
<td>用来指出流到达了文件结束</td>
</tr>
<tr>
<td><code>strm:goodbit</code></td>
<td>用来指出流未处于错误状态，此值保证为零</td>
</tr>
<tr>
<td><code>s.eof()</code></td>
<td>若流<code>s</code>的<code>eofbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.fail()</code></td>
<td>若流<code>s</code>的<code>failbit</code>置位或<code>badbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.bad()</code></td>
<td>若流<code>s</code>的<code>badbit</code>置位，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.good()</code></td>
<td>若流<code>s</code>处于有效状态，则返回<code>true</code></td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>将流<code>s</code>中所有条件状态位复位，将流的状态设置成有效，返回<code>void</code></td>
</tr>
<tr>
<td><code>s.clear(flags)</code></td>
<td>将流<code>s</code>中指定的条件状态位复位（覆盖原始流状态），返回<code>void</code></td>
</tr>
<tr>
<td><code>s.setstate(flags)</code></td>
<td>根据给定的标志位，将流<code>s</code>中对应的条件状态位置位（叠加原始流状态），返回<code>void</code></td>
</tr>
<tr>
<td><code>s.rdstate()</code></td>
<td>返回流<code>s</code>的当前条件状态，返回值类型为<code>strm::iostate</code></td>
</tr>
</tbody>
</table>
<ul>
<li>其中<code>strm</code>是一种IO类型比如<code>istream</code>， <code>s</code>是一个流对象。</li>
<li>到达文件结束位置，eofbit和failbit都会置位</li>
<li>如果badbit、failbit、eofbit任何一个被置位，检测流状态的条件都会失败</li>
<li>检查流的状态：<code>while(cin &gt;&gt; word); // cin&gt;&gt;word 表达式返回流的状态</code></li>
<li>设置某个标志位：<code>cin.clear(cin.rdstate() &amp; ~cin.failbit); // 将failbit复位</code></li>
</ul>
<h3 id="管理输出缓冲">管理输出缓冲</h3>
<ul>
<li>每个输出流都管理一个缓冲区，输出可能立即打印或是暂存在缓冲区中</li>
<li>IO操纵符（显式刷新缓冲区）：
<ul>
<li><code>endl</code>：输出一个换行符并刷新缓冲区。</li>
<li><code>flush</code>：刷新流，单不添加任何字符。</li>
<li><code>ends</code>：在缓冲区插入空字符<code>null</code>，然后刷新。</li>
<li><code>unitbuf</code>：告诉流接下来每次操作之后都要进行一次<code>flush</code>操作，默认情况对cerr是设置unitbuf的</li>
<li><code>nounitbuf</code>：重置流，回到正常的缓冲方式</li>
</ul>
</li>
<li>程序异常终止时，输出缓冲区不会被刷新</li>
<li>关联输入和输出流
<ul>
<li>当一个输入流关联到一个输出流，每次从该输入流读取数据前都会先刷新关联的输出流。</li>
<li>标准库将cout和cin关联在一起</li>
<li>输入流的成员函数<code>tie</code>，（无参数时）可以返回关联的输出流的指针，（有参数时）可以设定关联到某个输出流</li>
<li>每个输入流同时最多关联一个输出流，但是多个输入流可以同时关联同一个输出流</li>
</ul>
</li>
</ul>
<h2 id="82-文件输入输出">8.2 文件输入输出</h2>
<ul>
<li>头文件<code>fstream</code>定义了三个类型来支持文件IO：
<ul>
<li><code>ifstream</code>从一个给定文件读取数据。</li>
<li><code>ofstream</code>向一个给定文件写入数据。</li>
<li><code>fstream</code>可以读写给定文件。</li>
</ul>
</li>
<li>当要读写一个文件时，创建一个文件流对象并将之绑定到该文件。</li>
</ul>
<h3 id="fstream特有的操作">fstream特有的操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fstream fstrm;</code></td>
<td>创建一个未绑定的文件流。</td>
</tr>
<tr>
<td><code>fstream fstrm(s);</code></td>
<td>创建一个文件流，并打开名为<code>s</code>的文件，<code>s</code>可以是<code>string</code>也可以是<code>char</code>指针，自动调用open</td>
</tr>
<tr>
<td><code>fstream fstrm(s, mode);</code></td>
<td>与前一个构造函数类似，但按指定<code>mode</code>打开文件</td>
</tr>
<tr>
<td><code>fstrm.open(s)</code></td>
<td>打开名为<code>s</code>的文件，并和<code>fstrm</code>绑定；如果 open 失败，failebit 会被置位</td>
</tr>
<tr>
<td><code>fstrm.close()</code></td>
<td>关闭和<code>fstrm</code>绑定的文件，注意close并不会重置流的条件状态，需要使用clear重置。当一个 fstream 对象被销毁时，close 函数会自动被调用。</td>
</tr>
<tr>
<td><code>fstrm.is_open()</code></td>
<td>返回一个<code>bool</code>值，指出与<code>fstrm</code>关联的文件是否成功打开且尚未关闭</td>
</tr>
</tbody>
</table>
<h3 id="文件模式">文件模式</h3>
<table>
<thead>
<tr>
<th>文件模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>in</code></td>
<td>以<strong>读</strong>的方式打开，与ifstream对象关联的文件默认以in模式打开</td>
</tr>
<tr>
<td><code>out</code></td>
<td>以<strong>写</strong>的方式打开，与ofstream对象关联的文件默认以out模式打开</td>
</tr>
<tr>
<td><code>app</code></td>
<td>每次写操作前均定位到文件末尾。设置了trunc就不能再设置app模式；在app模式下，即使没有设定out模式，文件也是以输出方式打开</td>
</tr>
<tr>
<td><code>ate</code></td>
<td>打开文件后立即定位到文件末尾</td>
</tr>
<tr>
<td><code>trunc</code></td>
<td>截断文件，只有设置了 out 才能设置trunc模式，只设置out模式会默认也设置trunc模式</td>
</tr>
<tr>
<td><code>binary</code></td>
<td>以二进制方式进行IO操作。</td>
</tr>
</tbody>
</table>
<ul>
<li>与fstream对象关联的文件默认以in和out模式打开</li>
<li>默认情况下以 out 模式打开文件会使文件内容被清空，如果要保留文件内容
<ul>
<li>需要同时指定app模式：数据追加到末尾</li>
<li>或是同时指定in模式：同时进行读写操作</li>
</ul>
</li>
</ul>
<h2 id="83-string流">8.3 string流</h2>
<ul>
<li>头文件<code>sstream</code>定义了三个类型来支持读写string：
<ul>
<li><code>istringstream</code>从<code>string</code>读取数据。</li>
<li><code>ostringstream</code>向<code>string</code>写入数据。</li>
<li><code>stringstream</code>可以读写给定<code>string</code>。</li>
</ul>
</li>
</ul>
<h3 id="stringstream特有的操作">stringstream特有的操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sstream strm</code></td>
<td>定义一个未绑定的<code>stringstream</code>对象</td>
</tr>
<tr>
<td><code>sstream strm(s)</code></td>
<td>用<code>s</code>初始化对象</td>
</tr>
<tr>
<td><code>strm.str()</code></td>
<td>返回<code>strm</code>所保存的<code>string</code>的拷贝</td>
</tr>
<tr>
<td><code>strm.str(s)</code></td>
<td>将<code>s</code>拷贝到<code>strm</code>中，返回<code>void</code></td>
</tr>
</tbody>
</table>
<ul>
<li>上表中<code>sstream</code>是头文件<code>sstream</code>中任意一个类型。<code>s</code>是一个<code>string</code>。</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=dc0a09be-f4e4-9da7-0d9a-eccec71bb7f4&amp;page=314&amp;rect=87.840,397.200,204.000,405.600">使用例子</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch07 类</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch07-%E7%B1%BB/</link>
      <pubDate>Tue, 27 Feb 2024 15:57:08 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch07-%E7%B1%BB/</guid>
      <description>第七章 类 7.1 定义抽象数据类型 类成员 必须在类的内部声明，不能在其他地方增加成员。 成员可以是数据，函数，类型别名。 类的const成员函数不会修改类</description>
      <content:encoded><![CDATA[<h1 id="第七章-类">第七章 类</h1>
<h2 id="71-定义抽象数据类型">7.1 定义抽象数据类型</h2>
<h3 id="类成员">类成员</h3>
<ul>
<li>必须在类的内部声明，不能在其他地方增加成员。</li>
<li>成员可以是数据，函数，类型别名。</li>
<li><strong>类的const成员函数</strong>不会修改类的数据成员：<code>void func() const;</code>
<ul>
<li>const成员函数的声明和定义处都要加const</li>
<li>const成员函数不能调用本类的非const成员函数</li>
</ul>
</li>
<li><strong>内联函数</strong>
<ul>
<li>定义在类内部的函数是隐式inline函数</li>
<li>inline成员函数应该与类定义同一个头文件中</li>
</ul>
</li>
<li><strong>可变数据成员</strong> （mutable data member）：表示数据成员永远可变
<ul>
<li><code>mutable int cnt;</code>，这样即使在const成员函数中也可以修改cnt的值</li>
</ul>
</li>
<li><strong>[[ch07-类#返回<code>this</code>的成员函数|返回this的成员函数]]</strong></li>
<li><strong>构造函数</strong>
<ul>
<li>构造函数初始值列表：<code>Sales_item(): units_sold(0), revenue(0.0) { }</code> ^742596
<ul>
<li>但是类内初始值必须使用等号或者花括号进行初始化</li>
</ul>
</li>
<li>当一个类没有定义任何构造函数时，编译器才会生成一个默认构造函数（也称合成的默认构造函数），使用<code>=default</code>要求编译器使用合成的默认的构造函数。 ^15282e</li>
</ul>
</li>
</ul>
<h3 id="非成员函数">非成员函数</h3>
<ul>
<li>和类相关的非成员函数，定义和声明都应该在类的外部。</li>
</ul>
<h2 id="72-访问控制与封装">7.2 访问控制与封装</h2>
<ul>
<li>访问说明符（access specifiers）：<code>public</code>、<code>private</code>、<code>protected</code></li>
<li><code>class</code>与<code>struct</code>都可以被用于定义一个类，唯一的却别在于默认访问权限：
<ul>
<li><code>class</code>：默认成员是 <code>priavte</code>的。</li>
<li><code>struct</code>：默认成员是 <code>public</code>的。</li>
</ul>
</li>
</ul>
<h3 id="友元">友元</h3>
<ul>
<li>在类A中设置友元B（函数或类），即允许B访问A中的非共有成员</li>
<li>语法相关：
<ul>
<li>通常将友元声明成组地放在类定义的开始或者结尾，但友元不是类的成员，不受public/private的约束</li>
<li>如果类想把一组重载函数声明为友元，需要对这组函数中的每一个分别声明。</li>
<li>友元关系不存在传递性。</li>
<li>把其他类的成员函数声明为友元时，必须明确指定该函数所属的类名。</li>
<li>友元函数可以直接定义在类的内部（隐式内联），但是必须在类外部提供相应声明，并且要在调用之前进行声明
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">X</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">fir</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* do something */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">pub</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">pri</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">X</span><span class="o">::</span><span class="n">pub</span><span class="p">()</span> <span class="p">{</span> <span class="n">fir</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// 错误：友元函数fri在类外必须进行声明且需要在调用之前进行声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">fir</span><span class="p">();</span> <span class="c1">// 类X的友元函数fri，在类外进行声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">X</span><span class="o">::</span><span class="n">h</span><span class="p">()</span> <span class="p">{</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span>     
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="73-类的其他特性">7.3 类的其他特性</h2>
<h3 id="this"><code>this</code></h3>
<ul>
<li>每个成员函数都有一个额外的、隐含的形参<code>this</code>，<code>this</code>总是指向调用该成员函数的对象
<ul>
<li>在普通成员函数中，this是一个<code>T *const</code>类型的指针</li>
<li>在const成员函数中，this是一个<code>const T *const</code>类型的指针（因此数据成员无法修改）</li>
<li>静态函数中不能使用this指针</li>
</ul>
</li>
<li>const对象或是const对象的指针/引用，只能调用const成员函数；否则均可</li>
<li><code>return *this;</code>可以让成员函数<strong>连续调用</strong>。</li>
</ul>
<h3 id="类类型">类类型</h3>
<ul>
<li>可以声明一个类而暂时不定义它，称为<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=6fbd93d1-81be-2584-6f7d-5147c71be3ad&amp;page=276&amp;rect=148.810,525.840,185.290,534.000">前向声明</a>，用于引入类的名字；在前向声明之后、定义之前是一个不完全类型</li>
<li>可以定义指向不完全类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或返回值类型的函数</li>
</ul>
<h3 id="ch07-类友元友元">[[ch07-类#友元|友元]]</h3>
<h2 id="74-类的作用域">7.4 类的作用域</h2>
<p>类型别名如果在类外已经定义过，不能在类内再次定义。</p>
<h2 id="75-构造函数再探">7.5 构造函数再探</h2>
<ul>
<li>使用初始值列表进行初始化才是真正的初始化，在构造函数体中进行“初始化”只是赋值
<ul>
<li>如果是const成员或是引用类型，则必须在<strong>构造函数初始值列表</strong>中将其初始化（圆括号初始化）<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=e5af4ab3-b656-c156-52ca-a970eb1e7843&amp;page=284&amp;rect=251.230,38.650,397.440,46.810">例子</a></li>
</ul>
</li>
</ul>
<h3 id="委托构造函数-delegating-constructor">委托构造函数 （delegating constructor）</h3>
<p>委托构造函数通过其他构造函数来执行自己的初始化过程
- <code>Sale_data(): Sale_data(&quot;&quot;, 0, 0) {}</code></p>
<h3 id="隐式的类型转换">隐式的类型转换</h3>
<ul>
<li><strong>转换构造函数</strong>：如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的<strong>隐式转换机制</strong>，因此可以叫做转换构造函数。</li>
<li>编译器只会自动进行<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=b361b56d-3b61-5fee-5d3f-33c8af531492&amp;page=290&amp;rect=69.360,424.320,173.280,432.720">一步的隐式类型转换</a></li>
<li>将转换构造函数声明为<code>explicit</code>从而抑制隐式类型转换
<ul>
<li>explicit关键字只对接受一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，因此也无须将其指定为explicit</li>
<li>只在类内声明构造函数时使用explicit，在类外部定义时不应重复</li>
<li><code>explicit</code>构造函数只能用于直接初始化（圆括号初始化），不能用于拷贝赋值初始化（<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=3ce3ab3e-72e2-25d6-75ab-fe76a0f0014e&amp;page=291&amp;rect=52.560,293.290,222.961,301.930">例子</a>）</li>
</ul>
</li>
</ul>
<h3 id="聚合类obsidianbooknotetypeannotationbookcpp_primer-e99885e8afbbe7ac94e8aeb0primer20ce7acac5e78988pdfid2b69f080-2a9d-5995-2c7e-1e0b9bfa85ebpage292rect95760180960123120190080"><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=2b69f080-2a9d-5995-2c7e-1e0b9bfa85eb&amp;page=292&amp;rect=95.760,180.960,123.120,190.080">聚合类</a></h3>
<h3 id="字面值常量类">字面值常量类</h3>
<ul>
<li><code>constexpr</code>函数的参数和返回值必须是字面值。</li>
<li><strong>字面值类型</strong>：算数类型，引用，指针，聚合类</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=bb154d0b-92ba-c46f-65db-80fd7cd1e67b&amp;page=293&amp;rect=54.720,75.840,144,84.480">constexpr 构造函数</a></li>
</ul>
<h2 id="76-类的静态成员">7.6 类的静态成员</h2>
<ul>
<li>语法相关：
<ul>
<li>静态成员可以是public或是private的</li>
<li>静态成员可以是常量、指针、引用、类</li>
<li>静态成员函数不包含this指针，不能声明为const成员函数</li>
<li>定义和初始化
<ul>
<li>在类内声明，类外定义并初始化。</li>
<li>在类外定义时，不能重复 static 关键字，static 只出现在类内的声明中。</li>
<li>只有<code>constexpr</code>类型的静态数据成员可以在类内定义。</li>
</ul>
</li>
</ul>
</li>
<li>使用：
<ul>
<li>使用作用域运算符<code>::</code>直接访问静态成员:<code>r = Account::rate();</code></li>
<li>也可以使用类的对象访问：<code>r = ac.rate();</code></li>
</ul>
</li>
<li>特殊场景：<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=8c7bfe7a-bc18-a299-2930-8fb9548b9898&amp;page=297&amp;rect=61.920,395.040,260.640,403.680">例子</a>
<ul>
<li>静态数据成员的类型可以是不完全类型，比如可以是它所属的类类型，而普通变量不能（只能声明为所属类类型的指针或引用）</li>
<li>可以使用静态成员变量作为函数的默认实参</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch06 函数</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch06-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 27 Feb 2024 15:56:57 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch06-%E5%87%BD%E6%95%B0/</guid>
      <description>第六章 函数 6.1 函数基础 调用运算符：一对圆括号 ()，作用于函数指针 函数调用过程： 主调函数（calling function）的执行被中断，使用实参</description>
      <content:encoded><![CDATA[<h1 id="第六章-函数">第六章 函数</h1>
<h2 id="61-函数基础">6.1 函数基础</h2>
<ul>
<li>调用运算符：一对圆括号 <code>()</code>，作用于函数指针</li>
<li>函数调用过程：
<ul>
<li>主调函数（calling function）的执行被中断，使用实参初始化对应的形参</li>
<li>控制权移交给被调函数，被调函数（called function）开始执行。</li>
</ul>
</li>
<li>函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。</li>
</ul>
<h3 id="局部对象">局部对象</h3>
<ul>
<li><strong>生命周期</strong>：对象的生命周期是程序执行过程中该对象存在的一段时间。</li>
<li><strong>局部静态对象</strong>： <code>static</code>类型的局部变量，在程序执行路径第一次经过对象定义语句时进行初始化，直到程序终止才被销毁</li>
</ul>
<h3 id="函数声明">函数声明</h3>
<ul>
<li>函数声明不需要形参的名字</li>
<li>函数三要素：返回类型，函数名，形参类型</li>
</ul>
<h2 id="62-参数传递">6.2 参数传递</h2>
<ul>
<li>形参初始化的机理和变量初始化一样
<ul>
<li>形参的顶层<code>const</code>被忽略：<code>void func(const int i)</code>与<code>void func(int i)</code>具有相同的函数签名 ^f06638
<ul>
<li>原因：引用没有顶层const；如果传值，传递的是实参的副本，不会改变实参的值</li>
<li>但是前面这个函数体中i是const的，连副本也无法修改</li>
</ul>
</li>
</ul>
</li>
<li>两种传参方式：
<ul>
<li>传值参数（值传递，传值调用）</li>
<li>传引用参数（引用传递，传引用调用）
<ul>
<li>如果无需改变引用形参的值，最好将其声明为常量引用。</li>
<li>不能将const对象、字面值或需要类型转换的对象传递给普通引用形参，但是可以传递给常量引用形参</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数组形参">数组形参</h3>
<ul>
<li>数组有两个特殊性质：不允许拷贝数组、使用数组时通常会将其转换为指针</li>
<li>数组形参：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 以下几种方式形参等价，编译器只会检查传参类型是否为const int*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">[])</span> <span class="c1">// 可以看出函数意图是传递数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="c1">// 可以提示数组长度
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针，因此也要传入数组长度</li>
</ul>
</li>
<li>数组引用形参：形参是数组引用，实参要传递相同类型及大小的数组
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)[</span><span class="mi">5</span><span class="p">]){}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>传递多维数组：数组第二维（及更多维）的大小都是数组类型的一部分，不能省略
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">matrix</span><span class="p">)[</span><span class="mi">10</span><span class="p">],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">){}</span> <span class="c1">// matrix是一个指针，指向int[10]类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">matrix</span><span class="p">[][</span><span class="mi">10</span><span class="p">],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">){}</span> <span class="c1">// 等价定义
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="main处理命令行选项">main处理命令行选项</h3>
<ul>
<li><code>int main(int argc, char *argv[]) {}</code>
<ul>
<li>argc代表参数的个数；argv是一个数组，数组元素是char*（或者说char数组），第一个元素是程序的名字或一个空字符串，</li>
</ul>
</li>
</ul>
<h3 id="可变形参">可变形参</h3>
<ul>
<li>处理不同数量实参的函数
<ul>
<li>如果所有实参类型相同，可以传递一个<code>initializer_list</code>标准库类型</li>
<li>如果实参类型不同，可以定义可变参数模板</li>
<li>省略符形参：<code>void func(param_list, ...)</code>
<ul>
<li>一般只用于与C函数交互的接口程序，便于CPP访问某些C代码</li>
<li>大多数类类型的对象在传递给省略符形参时都无法正确拷贝</li>
<li>省略符形参对应的实参无须类型检查</li>
</ul>
</li>
</ul>
</li>
<li><code>initializer_list</code>：定义在同名头文件中的模板类型
<ul>
<li><code>initializer_list</code>与vector类似，但是它元素永远是常量</li>
<li><code>initializer_list</code>只能使用列表初始化</li>
<li>含有<code>initializer_list</code>形参的函数也可以有其他形参</li>
<li>其他容器使用列表初始化本质上都是采用了<code>initializer_list</code>形参的构造函数进行初始化的</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=67eed969-0ae3-b578-5007-a926384feff5&amp;page=224&amp;rect=218.650,632.400,316.320,640.080">initializer_list 提供的操作</a>：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span><span class="p">;</span><span class="c1">//默认初始化:空列表 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">initlst</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span><span class="c1">//initlast 的元素数量与初始值一样多
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">lst1</span><span class="p">(</span><span class="n">initlst</span><span class="p">);</span> <span class="c1">// 直接初始化，lst1与initlst共享元素（不会复制）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">lst2</span><span class="p">(</span><span class="n">initlst</span><span class="p">);</span> <span class="c1">// 赋值初始化，lst2与initlst共享元素（不会复制）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">lst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">});</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h2 id="63-返回类型和return语句">6.3 返回类型和return语句</h2>
<ul>
<li>不要返回局部对象的引用或指针</li>
<li><strong>引用返回左值</strong>：调用一个返回引用的函数得到左值，其他返回类型得到右值。</li>
<li>列表初始化返回值：函数可以返回花括号包围的值的列表，并对函数返回的临时量进行初始化。
<ul>
<li><code>vector&lt;int&gt; func() { return {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; }</code></li>
<li>这样可以减少一次拷贝？
<ul>
<li>相关：RVO</li>
<li>参考：《程序员的自我修养》P305（声明狼藉的C++返回对象）</li>
</ul>
</li>
</ul>
</li>
<li>main的返回值：cstdlib头文件定义了两种预处理变量来表示成功（<code>EXIT_FAILURE</code>）与失败（<code>EXIT_SUCCESS</code>）</li>
</ul>
<h3 id="返回数组指针">返回数组指针</h3>
<ul>
<li>取别名比较方便</li>
<li>可以使用尾置返回类型</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// int ( *p )[10]; // 数组指针：指向数组的指针
</span></span></span><span class="line"><span class="cl"><span class="c1">// int ( *func(params) )[10]; // 返回数组指针：函数参数是params，返回指向int[10]的数组指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 形式： Type (*function (parameter_list))[dimension]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="p">(</span> <span class="o">*</span><span class="n">func1</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="mi">5</span><span class="p">])</span> <span class="p">)[</span><span class="mi">5</span><span class="p">]{</span> <span class="c1">// 传入数组指针，返回数组指针, int (*arr)[5]是传入的数组指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">),</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ed</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用类型别名进行简化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">arrT</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// typedef int arrT[10]; // 感觉没有using直观
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">arrT</span><span class="o">*</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arrT</span><span class="o">*</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span> <span class="c1">// 使用别名，传入数组指针，返回数组指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 数组指针解引用得到数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用尾置返回类型，简化函数的声明和定义（尤其当返回值比较复杂时）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 在形参列表后面跟一个-&gt;，表示真正的返回值类型跟在形参列表之后，开头返回值用auto代替
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">func3</span><span class="p">(</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">5</span><span class="p">]{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">),</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ed</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 还可以使用 `decltype`，见P206
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// p是指向数组的指针， p的内容是数组首地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">arrT</span><span class="o">*</span> <span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// pp同样是数组的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">func1</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">),</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ed</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">it</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">func2</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">),</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ed</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">it</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">a3</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">func3</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">a3</span><span class="p">),</span> <span class="o">*</span><span class="n">ed</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">a3</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">ed</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">it</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="64-函数重载">6.4 函数重载</h2>
<ul>
<li>语法相关：
<ul>
<li>不允许两个函数除了返回类型以外的其他所有要素都相同，或者说返回值与重载无关</li>
<li>因为[[ch06-函数#^f06638|形参的顶层const被忽略]]，所以在重载函数中，一个有顶层const形参，另一个重载函数相应参数是普通形参，相当于重复声明，但是可以区分底层const。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=4f33a9d7-1eec-b511-c252-e9aeb4459a80&amp;page=234&amp;rect=115.200,519.130,429.360,526.810">例子</a></li>
</ul>
</li>
<li>使用：
<ul>
<li>一个函数的形参可能有常量引用和非常量引用两种版本，可以使用const_cast进行类型的转换
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* do something*/</span><span class="p">}</span> <span class="c1">// 底层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">func</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>重载和作用域：因为C++中名字查找发生在类型检查之间，所以编译器一旦在当前作用域内找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。
<ul>
<li>因此，不同的重载版本要定义在同一作用域中，一般是全局作用域</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="65-特殊用途语言特性">6.5 特殊用途语言特性</h2>
<h3 id="默认实参">默认实参</h3>
<ul>
<li>形参顺序：普通形参，不怎么使用默认值的形参，经常使用默认值的形参
<ul>
<li>设置默认值的形参必须放在没有默认值的形参之后</li>
<li>一旦某个形参被赋予（或使用）默认值，那么它之后的形参都必须要有默认值</li>
</ul>
</li>
<li>虽然多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">screen</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="o">=</span><span class="sc">&#39; &#39;</span><span class="p">);</span> <span class="c1">// 第一次声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">screen</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// 第二次声明，添加了默认实参
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>默认实参只能出现在函数声明和定义其中一处，通常应该在头文件中的函数声明中指定默认实参。</li>
<li>局部变量不能作为函数的默认实参，全局变量和字面值都可以</li>
</ul>
<h3 id="内联inline函数">内联（inline）函数</h3>
<ul>
<li>在函数声明和定义中都能使用关键字inline，但是建议只在函数定义时使用。</li>
<li>一般来说，内联机制适用于优化规模较小、流程直接、调用频繁的函数。内联函数中不允许有循环语句和switch语句，否则函数会被编译为普通函数。</li>
</ul>
<h3 id="constexpr-函数obsidianbooknotetypeannotationbookcpp_primer-e99885e8afbbe7ac94e8aeb0primer20ce7acac5e78988pdfid08ac9451-c1bd-d611-0716-98d876b07c54page240rect62650382800131280391200"><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=08ac9451-c1bd-d611-0716-98d876b07c54&amp;page=240&amp;rect=62.650,382.800,131.280,391.200">constexpr 函数</a></h3>
<p>不是很理解，个人理解是在编译器就能确定返回值的函数</p>
<ul>
<li>内联函数和constexpr函数通常定义在头文件中。</li>
</ul>
<h3 id="调试帮助">调试帮助</h3>
<p>调试帮助：用类似头文件保护的方式，有选择的执行调试代码。即在开发过程中，程序可以包含一些用于调试的代码，当程序发布时，需要先屏蔽掉调试代码。调试帮助通常包含两种预处理功能：<code>assert</code>和<code>DNEBUG</code></p>
<ul>
<li><code>assert</code>是一种预处理宏（preprocessor macro）：<code>assert(expr);</code>
<ul>
<li>当表达式为假时，assert输出信息并终止程序；如果真，assert什么都不做</li>
<li>常用来检查不能发生的条件</li>
</ul>
</li>
<li><code>NDEBUG</code>预处理变量：关闭调试状态
<ul>
<li>可以使用<code>#define NDEBUG</code>来定义<code>NDEBUG</code>，但很多编译器都提供了命令行选项<code>-D NDEBUG</code></li>
<li>如果定义了<code>NDEBUG</code>，则assert什么都不做；默认情况下没有定义<code>NDEBUG</code></li>
<li>几个用于调试的变量名称：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">变量名称</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__func__</code></td>
<td style="text-align:center">当前函数名称</td>
</tr>
<tr>
<td style="text-align:center"><code>__FILE__</code></td>
<td style="text-align:center">当前文件名称</td>
</tr>
<tr>
<td style="text-align:center"><code>__LINE__</code></td>
<td style="text-align:center">当前行号</td>
</tr>
<tr>
<td style="text-align:center"><code>__TIME__</code></td>
<td style="text-align:center">文件编译时间</td>
</tr>
<tr>
<td style="text-align:center"><code>__DATE__</code></td>
<td style="text-align:center">文件编译日期</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#ifndef NDEBUG </span><span class="c1">// 默认情况下没有定义NDEBUG，可以在这里编写自己的调试代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果定义了NDEBUG，则跳过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">__func__</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="66-函数匹配">6.6 函数匹配</h2>
<p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=ff2868c8-59a4-9b72-c42c-92a021d43cec&amp;page=235&amp;rect=350.170,216.730,389.050,225.850">函数匹配</a>（或称为重载确定）</p>
<ul>
<li>重载函数匹配的三个步骤：
<ul>
<li>找候选函数：同名函数</li>
<li>选可行函数：形参实参数量相等，类型匹配或者能进行转换</li>
<li>寻找最佳匹配：实参类型和形参类型越接近，它们匹配越好
<ul>
<li>精确匹配、从数组类型或函数类型转换为对应的指针类型、添加/删除顶层const</li>
<li>const转换</li>
<li>类型提升</li>
<li>算数类型转换、指针转换</li>
<li>类类型转换</li>
</ul>
</li>
<li>如果有若干个匹配，但没有一个最佳匹配时，编译器可能报告二义性调用的信息</li>
</ul>
</li>
</ul>
<h2 id="67-函数指针">6.7 函数指针</h2>
<ul>
<li>对于重载函数，函数指针类型必须与重载函数中某一个精确匹配
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">Func</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="kt">int</span> <span class="nf">Func2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数类型，等价于Func
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">using</span> <span class="n">FuncP</span> <span class="o">=</span>  <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数指针类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">FuncP2</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数指针类型，等价于FuncP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="nf">add</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">op1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">op2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">Func</span><span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);}</span> <span class="c1">// 函数不能做形参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">op3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">FuncP</span> <span class="n">fp</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">1</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="n">FuncT</span><span class="p">;</span> <span class="c1">// 函数类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">FuncTP</span><span class="p">);</span> <span class="c1">// 函数指针类型，decltype返回函数类型，需要在别名类型前加上*表示函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">      <span class="n">Func</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">FuncP</span> <span class="n">g</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">op1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">add</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">op2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">op3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">g</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>函数指针可以作为形参
<ul>
<li>形参类型可能为函数类型，传入的也可能是函数名，但是最终都是转换为函数指针</li>
</ul>
</li>
<li>函数指针可以作为返回值，函数类型不可以作为返回值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Func</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">FuncP</span> <span class="o">=</span>  <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 函数指针类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret_func1</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 一个名为ret_func1的函数，其参数为params，返回一个int(*)(int, int)类型的函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">ret_func2</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 尾置返回类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Func</span><span class="o">*</span> <span class="nf">ret_func3</span><span class="p">(</span><span class="n">params</span><span class="p">);</span> <span class="c1">// 使用别名，返回指向函数类型的指针，不能返回Func
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">FuncP</span> <span class="nf">ret_func4</span><span class="p">(</span><span class="n">params</span><span class="p">);</span> <span class="c1">// 使用别名，返回函数指针
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>复杂例子：假设函数指针类型是<code>int(*)(int, int)</code>，数组指针类型是<code>int (*)[5]</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">FuncP</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Arr</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>返回值是函数指针，函数形参是数组指针
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span> <span class="o">*</span><span class="n">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">5</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">FuncP</span> <span class="nf">f</span><span class="p">(</span><span class="n">Arr</span><span class="o">*</span> <span class="n">arr</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>返回值是函数指针，函数形参是函数指针
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">))</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">FuncP</span> <span class="nf">f</span><span class="p">(</span><span class="n">FuncP</span> <span class="n">fp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>返回值是数组指针，函数形参是函数指针
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span> <span class="o">*</span><span class="n">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="p">)[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">Arr</span><span class="o">*</span> <span class="nf">f</span><span class="p">(</span><span class="n">FuncP</span> <span class="n">fp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>返回值是数组指针，函数形参是数组指针
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="p">))[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">Arr</span><span class="o">*</span> <span class="nf">f</span><span class="p">(</span><span class="n">Arr</span><span class="o">*</span> <span class="n">arr</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch05 语句</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch05-%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Tue, 27 Feb 2024 15:56:48 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch05-%E8%AF%AD%E5%8F%A5/</guid>
      <description>第五章 语句 简单语句 表达式语句：一个表达式末尾加上分号，就变成了表达式语句。 空语句：有时语法上需要一个语句，但是逻辑上不需要，可以直接写一个分</description>
      <content:encoded><![CDATA[<h1 id="第五章-语句">第五章 语句</h1>
<h2 id="简单语句">简单语句</h2>
<ul>
<li><strong>表达式语句</strong>：一个表达式末尾加上分号，就变成了表达式语句。</li>
<li><strong>空语句</strong>：有时语法上需要一个语句，但是逻辑上不需要，可以直接写一个分号。</li>
<li><strong>复合语句（块）</strong>：用花括号 <code>{}</code>包裹起来的语句和声明的序列。一个块就是一个作用域。空块等价于空语句。</li>
</ul>
<h2 id="条件语句">条件语句</h2>
<ul>
<li><strong>悬垂else</strong>（dangling else）：用来描述在嵌套的<code>if else</code>语句中，如果<code>if</code>比<code>else</code>多时如何处理的问题。C++使用的方法是<code>else</code>匹配最近没有配对的<code>if</code>。</li>
</ul>
<h2 id="迭代语句">迭代语句</h2>
<ul>
<li>range-for中不能改变序列的元素数量，因为预存了end()的值，改变预存的值失效</li>
</ul>
<h2 id="try语句块和异常处理">try语句块和异常处理</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="nf">runtime_error</span><span class="p">(</span><span class="s">&#34;Data must be same as size&#34;</span><span class="p">);</span> <span class="c1">// throw抛出使用字符串初始化的异常类型的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">catch</span><span class="p">(</span><span class="n">runtime_error</span> <span class="n">err</span><span class="p">)</span><span class="c1">//异常类型对象的声明（也称异常声明）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// catch子句也称为异常处理代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">err</span><span class="p">.</span><span class="n">what</span><span class="p">();</span><span class="c1">//每个标准异常类都有一个what成员函数，返回初始化对象时使用的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">catch</span><span class="p">(...){</span> <span class="cm">/* 捕获所有异常*/</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=92e04fc5-9bef-d3e3-c183-01b5c1524a37&amp;page=202&amp;rect=104.160,508.320,151.680,518.160">标准异常</a>及其继承关系：
<img src="https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-09-14-15:34:43.png" alt="image.png" style="zoom:50%;" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch04 表达式</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 27 Feb 2024 15:56:40 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch04-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>第四章 表达式 4.1 表达式基础 左值和右值： 一个对象被用作左值时，使用的是对象的身份（在内存中的地址，左值可以按名访问，而且其地址可以被赋值） 一个对</description>
      <content:encoded><![CDATA[<h1 id="第四章-表达式">第四章 表达式</h1>
<h2 id="41-表达式基础">4.1 表达式基础</h2>
<ul>
<li><strong>左值和右值</strong>：
<ul>
<li>一个对象被用作左值时，使用的是对象的身份（在内存中的地址，左值可以按名访问，而且其地址可以被赋值）</li>
<li>一个对象被用作右值时，使用的是对象的值（内容）
<ul>
<li>（自己的理解）即使一个对象可以按名访问，但如果该对象的内容在只读数据段，该对象也是右值</li>
</ul>
</li>
<li>需要右值的地方可以使用左值代替，但是反过来不行</li>
<li><code>decltype</code>作用于表达式（注意不是变量），推导出来是左值还是右值，与表达式返回值是左值还是右值相同</li>
</ul>
</li>
<li><strong>求值顺序</strong>：
<ul>
<li>如果改变了某个运算对象的值，在同一表达式中不要再使用该运算对象，<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=b7e91651-45ab-3457-d6fd-6d7d5772b8d8&amp;page=149&amp;rect=100.800,520.213,148.320,533.047">参考</a></li>
<li>只有四种运算符明确规定了求值顺序：<code>&amp;&amp;</code>、<code>||</code>、<code>?:</code>、<code>,</code></li>
</ul>
</li>
</ul>
<h2 id="42-算术运算符">4.2 算术运算符</h2>
<ul>
<li>整数除法的结果向0舍入</li>
<li>取余运算m%n，结果符号与被除数m相同</li>
</ul>
<h2 id="43-逻辑和关系运算符">4.3 逻辑和关系运算符</h2>
<ul>
<li>短路求值</li>
</ul>
<h2 id="44-赋值运算符">4.4 赋值运算符</h2>
<ul>
<li>C++11允许使用花括号括起来的初始值列表作为右侧运算对象，初始化列表为空时进行值初始化</li>
<li>赋值运算的<strong>返回结果是它的左侧运算对象</strong>，是一个左值</li>
<li>赋值运算符满足<strong>右结合律</strong>，这点和其他二元运算符不一样。
<ul>
<li>比如：<code>ival = jval = 0;</code>等价于<code>jval = 0; ival = jval;</code></li>
</ul>
</li>
<li>复合赋值运算符只求值一次，而普通运算符需要两次。
<ul>
<li>比如：a=a+1 要先求一次 a+1，再将结果赋值给 a</li>
</ul>
</li>
</ul>
<h2 id="45-递增和递减运算符">4.5 递增和递减运算符</h2>
<ul>
<li>前置版本<code>j = ++i</code>，先i加一，后给j赋值，优先使用</li>
<li>后置版本<code>j = i++</code>，先给j赋值，后i加一</li>
</ul>
<ul>
<li>混用解引用和递增运算符：<code>*p++</code> 等价于 <code>*(p++)</code>
<ul>
<li>首先进行自加，p指向下一个位置，返回原来对象的副本</li>
<li>将原来对象的副本进行解引用
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">!=</span><span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">iter</span><span class="o">++&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>    <span class="c1">// 输出当前值，指针向前移1
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h2 id="46-成员访问运算符">4.6 成员访问运算符</h2>
<p><code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code></p>
<h2 id="47-条件运算符">4.7 条件运算符</h2>
<ul>
<li>条件运算符（<code>?:</code>）：<code>cond? expr1: expr2</code></li>
<li>可以嵌套使用，右结合律，从右向左顺序组合</li>
</ul>
<h2 id="48-位运算符">4.8 位运算符</h2>
<ul>
<li>位运算符是作用于整数类型的运算对象。</li>
<li>向左移（<code>&lt;&lt;</code>），向右移（<code>&gt;&gt;</code>），位取反（<code>~</code>）（逐位求反）、与（<code>&amp;</code>）、或（<code>|</code>）、异或（<code>^</code>）</li>
<li>有符号数负值可能移位后变号，所以强烈建议位运算符仅用于无符号数。</li>
</ul>
<h2 id="49-sizeof运算符">4.9 sizeof运算符</h2>
<ul>
<li>语法：
<ul>
<li><code>sizeof (type)</code>：返回类型的大小</li>
<li><code>sizeof expr</code>：返回表达式结果类型的大小</li>
<li>返回类型是 <code>size_t</code>的常量表达式</li>
</ul>
</li>
<li><code>sizeof</code>并不实际计算其运算对象的值。</li>
<li>对数组执行<code>sizeof</code>运算得到整个数组所占空间的大小。</li>
<li>对<code>string</code>或<code>vector</code>对象执行<code>sizeof</code>运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。</li>
</ul>
<h2 id="410-逗号运算符">4.10 逗号运算符</h2>
<p>从左向右依次求值，左侧求值结果丢弃，返回结果是右侧表达式的值。</p>
<h2 id="411-类型转换">4.11 类型转换</h2>
<p>C++不会直接将两个不同类型的值相加，会先通过类型转换将运算对象的类型统一之后再求值</p>
<h3 id="隐式类型转换">隐式类型转换</h3>
<ul>
<li>整型提升</li>
<li>数组转换成指针：大多数情况下，数组名字自动转换成指向数组首元素的指针
<ul>
<li>decltype关键词参数、取地址符、sizeof、typeid不会发生这种转换</li>
</ul>
</li>
<li>指针的转换：
<ul>
<li>常量整数值0或字面值nullptr能转换成任意指针类型</li>
<li>指向任意非常量的指针能转换成void*</li>
<li>指向任意对象的指针能转换成const void*</li>
<li>指向派生类的指针自动转换为指向基类的指针</li>
</ul>
</li>
<li>转换成布尔类型</li>
<li>转换成常量：指向非常量类型的指针能转换成指向相应的常量类型的指针
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">i</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="c1">// 可以通过i修改变量的值，但是不能通过p和r修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">r</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>类类型的转换</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">);</span> <span class="c1">//将cin转换为bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;value&#34;</span><span class="p">;</span> <span class="c1">// 将字符数组转换为string
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="显式类型转换即强制类型转换">显式类型转换（即强制类型转换）</h3>
<ul>
<li>形式：<code>cast_name&lt;type&gt;(expression);</code>
<ul>
<li>type: 转换的目标类型，如果type是引用类型，则结果是左值</li>
<li>cast_name: static_case, dynamic_cast, const_cast, reinterpret_cast中的一种</li>
</ul>
</li>
<li><strong>static_cast</strong>：任何明确定义的类型转换，只要不包含底层const，都可以使用
<ul>
<li>把一个较大的算数类型赋值给较小的类型（可能有精度损失）</li>
<li>找回<code>void*</code>中的值</li>
</ul>
</li>
<li><strong>const_cast</strong>：只能改变运算对象的底层const，一般用于去除const属性
<ul>
<li>只有const_cast可以改变表达式的const属性（顶层const或底层const都可以）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// i是底层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">j</span><span class="p">;</span> <span class="c1">// 3 3 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// i是底层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">j</span><span class="p">;</span> <span class="c1">// 2 3 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// i是顶层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">j</span><span class="p">;</span> <span class="c1">// 4 4 4
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>const_cast常用于有函数重载的上下文中</li>
</ul>
</li>
</ul>
</li>
<li><strong>reinterpret_cast</strong>：通常为运算对象的位模式提供低层次上的重新解释，慎重使用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 但是c所指的真实对象是一个int而非char
</span></span></span><span class="line"><span class="cl"><span class="c1">// char *c = (char*) i; // 旧式的强制类型转换，等价
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>[[ch19-特殊工具与技术#<code>dynamic_cast</code>运算符|dynamic_cast]]</strong>：在运行时，将基类类型转换为派生类类型</li>
<li>旧式的强制类型转换本质上采用了static_cast, const_cast, reinterpret_cast中的一种，但是旧式的强制类型转化不够清晰，出了问题难以追踪</li>
</ul>
<h2 id="412-运算符优先级表">4.12 运算符优先级表</h2>
<p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=e8f768ae-b715-ec24-f9b5-63dc8a39ede3&amp;page=173&amp;rect=233.760,379.680,286.800,387.120">运算符优先级表</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch03 字符串、向量和数组</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch03-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 27 Feb 2024 15:56:30 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch03-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</guid>
      <description>第三章 字符串、向量和数组 3.1 using声明 可以对单个名字进行独立的using声明，比如using std::cin 头文件中不应该包含using声明。 3.2 string 初始化</description>
      <content:encoded><![CDATA[<h1 id="第三章-字符串向量和数组">第三章 字符串、向量和数组</h1>
<h2 id="31-using声明">3.1 using声明</h2>
<ul>
<li>可以对单个名字进行独立的using声明，比如<code>using std::cin</code></li>
<li>头文件中不应该包含<code>using</code>声明。</li>
</ul>
<h2 id="32-string">3.2 string</h2>
<p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=467e5bc5-4466-39dd-367f-26093fa90577&amp;page=102&amp;rect=221.040,426.480,318.960,433.680">初始化 string 对象的方式</a></p>
<ul>
<li>拷贝初始化（copy initialization）：<code>=</code></li>
<li>直接初始化（direct initialization）：<code>()</code>
<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=b66ffae2-0b25-c3f7-5000-10c3e96afd8b&amp;page=103&amp;rect=238.800,502.080,289.440,509.520">string 的操作</a></li>
<li><strong>字符串字面值和string是不同的类型</strong>（为了与C兼容）
<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=50978ba0-9d42-3196-6cdc-1a1b534f55e0&amp;page=108&amp;rect=219.600,570.720,310.560,577.920">cctype头文件中定义了一组标准库函数来处理string的字符</a></li>
</ul>
<h2 id="33-vector">3.3 vector</h2>
<p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=bcbb23e1-52b0-4bb1-9a3a-020d5bb6db24&amp;page=113&amp;rect=220.320,136.320,320.890,143.760">初始化 vector 对象的方法</a></p>
<ul>
<li>列表初始化： <code>vector&lt;string&gt; v{&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};</code> （C++11）</li>
<li>拷贝初始化：<code>=</code></li>
<li>直接初始化：<code>()</code></li>
<li>数组初始化：<code>vector&lt;int&gt; v(arr.begin(), arr.end());</code><br>
<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=3d543f80-e7cb-0287-ab58-cf692b1ef0c3&amp;page=117&amp;rect=229.930,167.290,301.210,174.730">vector 支持的操作</a></li>
<li>范围<code>for</code>语句内不应该改变其遍历序列的大小。</li>
<li><code>vector</code>对象（以及<code>string</code>对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。</li>
</ul>
<h2 id="34-迭代器iterator">3.4 迭代器iterator</h2>
<h3 id="使用迭代器">使用迭代器</h3>
<ul>
<li>养成使用迭代器和<code>!=</code>的习惯（泛型编程），循环判断中少使用<code>&lt;</code>（因为所有标准库迭代器都定义了<code>==</code>和<code>!=</code>，但是只有很少一部分定义了<code>&lt;</code>）。</li>
<li>但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</li>
</ul>
<h2 id="35-数组">3.5 数组</h2>
<h3 id="定义和初始化内置数组">定义和初始化内置数组</h3>
<ul>
<li>初始化：列表初始化
<ul>
<li>字符数组可以用字符串字面值进行初始化，结尾<code>\0</code>也拷贝到字符数组中</li>
</ul>
</li>
<li>数组不允许直接拷贝或赋值给另一个数组。
<ul>
<li>想复制可以使用<code>memcpy(void *dst, void *src, size_t size)</code></li>
</ul>
</li>
<li>复杂的数组声明，<strong>指向数组的指针</strong>，<strong>绑定到数组的引用</strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span> <span class="p">};</span> <span class="c1">// arr是int[10]类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pa</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// pa是指向arr(int[10]类型)的指针，右边当然要取地址（虽然arr==&amp;arr）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="p">(</span> <span class="p">(</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span> <span class="c1">// *pa是数组指针解引用，即得到arr（即为数组名）;剩下部分即为通常的指针访问数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// cout&lt;&lt; (*pa)[i] &lt;&lt; &#34; &#34;;  // 或者这样访问元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ra</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="c1">// ra是绑定到arr(int[10]类型)的引用，右边即为对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="p">(</span><span class="n">ra</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// cout&lt;&lt; ra[i] &lt;&lt;&#34; &#34;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">},{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">},{</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// 左边是指向int[5]类型的指针，右边是&amp;m[0]（即为m）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="c1">// p+i表示指向哪一个int[5]类型，解引用即为者5个int数组的数组名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 等价写法：p[i][j], *(p[i] + j), *(*(p+i) + j)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">[</span><span class="mi">10</span><span class="p">])[</span><span class="mi">5</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 首先pp与[10]结合，表明这是一个数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 剩下的部分就是数组元素的类型：int (*)[5]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 即每个数组元素是一个指针，指向int[5]类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><a href="https://blog.csdn.net/stephen_999/article/details/128381419?spm=1001.2014.3001.5502">各类指针的详细介绍</a></li>
</ul>
<h3 id="数组与指针">数组与指针</h3>
<ul>
<li>很多情况下，编译器会将数组名自动替换为指向数组首元素的指针（相当于顶层const指针）</li>
<li>数组的类型推断
<ul>
<li>当auto变量基于数组名进行类型推断时，得到的是对应类型的指针</li>
<li>当使用decltype进行类型推断时，返回数组类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">ptr</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>  <span class="c1">//ptr是int*类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="n">arr2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span> <span class="c1">// 相当于arr2的类型是int[3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">i</span><span class="p">:</span> <span class="n">arr2</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>  <span class="c1">// 输出是4 5 0而非4 5 3
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>数组名不是指针
<ul>
<li>证据一：sizeof(数组名) = 整个数组所占内存大小，如果数组名是指针，则为4或8</li>
<li>证据二：<strong>对数组名取地址得到的是整个数组的地址</strong>，如果数组名是指针，则对数组名取地址是另外一个地址（指针的地址）
<ul>
<li><code>arr</code>（数组首个元素的地址）与<code>&amp;arr</code>（数组地址）在值上是相等的，但是意义不同
<img src="https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-09-14-10:36:07.png" alt="image.png" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-09-14-10:53:38.png" alt="image.png" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
</li>
<li>函数传参和接受参数时，传递的都是指针，即使形参是<code>int arr[]</code>这样表示整个数组（可能情形是，外面传入的实参是数组名，但是形参实例化时自动转换为指针）
<ul>
<li>否则需要进行数组的拷贝，效率低</li>
<li><code>int arr[x]</code>中即使带数组容量，也会被忽略，x随便取都无所谓</li>
</ul>
</li>
<li>参考
<ul>
<li>好文章：<a href="https://blog.csdn.net/stephen_999/article/details/128404620?spm=1001.2014.3001.5502"># 指针与数组的联系与区别【一万六千字超详解】</a></li>
</ul>
</li>
</ul>
<h3 id="c风格字符串">C风格字符串</h3>
<ul>
<li>C风格字符串：以空字符<code>\0</code>结束的char数组</li>
<li>相互使用：
<ul>
<li>可以直接将char字符数组赋值给string字符串</li>
<li>字符串到字符数组：<code>const char *arr = str.c_str();</code>
<ul>
<li><code>str, arr</code>使用的是同一块数据</li>
</ul>
</li>
</ul>
</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=0936f168-007c-c836-4956-d0006aed1236&amp;page=135&amp;rect=234,416.890,313.930,424.330">C 风格字符串的函数</a>：<code>strlen, strcmp, strcat, strcpy</code>
<ul>
<li>传入参数必须是字符数组，注意列表初始化字符数组时必须最后带<code>\0</code></li>
</ul>
</li>
<li>字符串与字符数组：
<ul>
<li>字符串：使用字符指针指向只读数据段的一片区域</li>
<li>字符数组：放在栈中或者数据段</li>
<li><a href="https://blog.csdn.net/stephen_999/article/details/128381419?spm=1001.2014.3001.5502#t6">参考</a></li>
</ul>
</li>
</ul>
<h2 id="36多维数组">3.6多维数组</h2>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=8fe9e178-9a57-074e-9b52-6af58f495f7f&amp;page=138&amp;rect=69.120,174.960,437.760,196.330">多维数组阅读顺序由内向外</a></li>
<li>多维数组的初始化
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ib</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化部分元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">ic</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span> <span class="mi">0</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">4</span> <span class="p">}};</span> <span class="c1">// 初始化第一列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">id</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span> <span class="c1">// 初始化第一行
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>使用range-for语句时，除了最内层的循环外，外层循环的控制变量都应该是<strong>引用</strong>类型。
<ul>
<li>否则编译器自动将数组名转换为指针，无法使用range-for语法</li>
</ul>
</li>
<li>遍历：<code>int ia[2][4] = { {0, 1, 2, 3}, {4, 5, 6, 7} };</code>
<ul>
<li>range-for：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// row为int[4]类型，如果row不是引用类型（不加&amp;），编译器会自动将row从int[4]类型转变为指针，无法遍历指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">row</span><span class="p">:</span> <span class="n">ia</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">item</span><span class="p">:</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">item</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 不使用auto，写出变量类型：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">row</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span><span class="o">:</span> <span class="n">ia</span><span class="p">)</span> <span class="c1">// 理解山相当于：int[4] &amp;row
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">item</span><span class="p">:</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">item</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>使用i，j下标进行访问</li>
<li>使用指针访问
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">ia</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">q</span><span class="o">!=</span> <span class="o">*</span><span class="n">p</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">q</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 不使用auto：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">ia</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">q</span> <span class="o">!=</span> <span class="o">*</span><span class="n">p</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">q</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用类型别名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">arr</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// typedef int arr[4]; // 看起来比较奇怪
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="n">arr</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">ia</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">q</span> <span class="o">!=</span> <span class="o">*</span><span class="n">p</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">q</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h2 id="其他">其他</h2>
<h3 id="const指针和引用多维数组">const、指针和引用、多维数组</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r_m</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// r_m是一个绑定到int[4]数组的引用，
</span></span></span><span class="line"><span class="cl"><span class="c1">// int* (&amp;rr_m)[3] = m; // rr_m是一个绑定到(int*)[3]数组的引用，即绑定到大小为3的指针数组；但是m[0], m[1], m[2]各自都是一个int[4]数组的引用，m的类型是int[3][4]，类型都不匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rr_m</span><span class="p">)[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// rr_m是一个绑定到int[3][4]的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// p是一个指向int[4]数组的指针（即每个元素是int[4]数组，即m）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">pp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]};</span> <span class="c1">// m[0], m[1], m[2]每个是一维数组的数组名，只是编译器将数组名转换为指针，{m[0], m[1], m[2]}就变成了一个指针数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// int* (&amp;r)[3] = {m[0], m[1], m[2]}; // 报错，因为{m[0], m[1], m[2]}是右值，尝试将右值赋值给引用
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>也进行顶层const和底层const的区分</li>
</ul>
<h3 id="动态数组">动态数组</h3>
<ul>
<li>使用 <code>new</code>和 <code>delete</code>表达和c中<code>malloc</code>和<code>free</code>类似的功能，即在堆中分配存储空间。</li>
<li>定义： <code>int *pia = new int[n];</code></li>
<li>释放： <code>delete [] pia;</code>，注意不要忘记<code>[]</code>。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch02 变量和基本类型</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch02-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 27 Feb 2024 15:56:20 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch02-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</guid>
      <description>第二章 变量和基本类型 2.1 基本内置类型 1 2 sizeof(int) = 4; sizeof(long int) = 8; sizeof(long long int) = 8; sizeof(float) = 4; sizeof(double) = 8; sizeof(long double) = 16; 字面值常量（literal） 分多行书写字符串：C++ 允许在</description>
      <content:encoded><![CDATA[<h1 id="第二章-变量和基本类型">第二章 变量和基本类型</h1>
<h2 id="21-基本内置类型">2.1 基本内置类型</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="字面值常量literal">字面值常量（literal）</h3>
<blockquote>
<p>分多行书写字符串：C++ 允许在一条语句中自动连接多个双引号字符串（连接处无空格）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="nl">std</span><span class="p">:</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;wow, a really, really long string&#34;</span>
</span></span><span class="line"><span class="cl">       <span class="s">&#34;literal that spans two lines&#34;</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<h2 id="22-变量">2.2 变量</h2>
<h3 id="声明和定义">声明和定义</h3>
<ul>
<li>初始化（initialize）：初始化不是赋值
<ul>
<li>初始化 = 创建变量 + 赋予初始值</li>
<li>赋值 = 擦除对象的当前值 + 用新值代替</li>
</ul>
</li>
<li>变量的声明（declaration）和定义（define）
<ul>
<li>声明使得名字为程序所知；定义负责创建与名字关联的实体（分配内存）。</li>
<li>extern：表示符号的定义在模块外部，但如果包含了初始值，就变成了定义</li>
<li>C和C++关于声明和定义、强符号和弱符号、变量在ELF节中的位置规定似乎不同
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// a.c（或a.cpp）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// b.c（或b.cpp）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><code>gcc a.c b.c -o test1</code>：编译链接并运行，正常
<code>gcc a.cpp b.cpp -o test2</code>：链接出错：x多重符号定义</li>
</ul>
</li>
</ul>
<h3 id="作用域">作用域</h3>
<ul>
<li>同时存在同名的全局和局部变量时，在内层作用域中可以使用<code>::reused</code>显式访问全局变量reused。</li>
</ul>
<h2 id="23-复合类型">2.3 复合类型</h2>
<p>复合类型的含义：比如int型是基本类型，但是引用和指针（即&amp;、*称为<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=dab1f6ae-b5a8-1f74-69e0-5435b1e6c1d0&amp;page=77&amp;rect=262.413,167.040,307.736,175.680">类型修饰符</a>）可以再作为声明符的一部分（类型修饰符+变量标识符），构成复合类型</p>
<ul>
<li>类型修饰符是声明符的一部分，因此<code>int *a, b, &amp;c;</code>中只有a是指针，c是引用</li>
<li>但是理解上类型修饰符可以看作是类型的一部分，比如<code>int *&amp;pa=a;</code>中pa是对int*类型（指向int的指针）的引用</li>
<li>判断类型是从右向左读，最靠近变量名的类型修饰符说明这是一个什么复合类型，其余符号和基本类型共同说明指向/引用何种（复合）类型</li>
</ul>
<h3 id="左值引用">(左值)引用</h3>
<ul>
<li>引用必须初始化。</li>
<li>引用和它的初始值是绑定在一起的，而<strong>不是拷贝</strong>。一旦定义就不能更改绑定为其他的对象</li>
<li>引用只能绑定到对象上，不能与字面值或某个表达式的计算结果绑定</li>
<li>引用不是对象</li>
</ul>
<h3 id="指针">指针</h3>
<ul>
<li><code>void*</code>指针可以存放任意对象的地址。因无类型，仅操作内存空间，对所存对象无法访问（不能直接操作void*指向的对象）。</li>
<li>指针的类型要与所指向的对象严格匹配，两个例外：
<ul>
<li>可以使用指向常量的指针指向非常量</li>
<li>可以使用基类的指针指向派生类</li>
</ul>
</li>
<li>注意不能直接给指针赋值一串地址，给指针赋值应该是另一个指针或是变量取地址
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>    <span class="c1">// a是int型, p是int型的指针(int *)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>     <span class="c1">// q也是int型的指针, 将p赋值给q
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>  <span class="c1">// pp是指向int*类型变量的指针
</span></span></span><span class="line"><span class="cl"><span class="c1">// 不能是 int *pp = &amp;p, 即犯了直接把内存地址赋值给指针的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">**</span> <span class="o">*</span><span class="n">ppp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pp</span><span class="p">;</span> <span class="c1">// ppp是指向int**类型的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">***</span> <span class="o">&amp;</span><span class="n">r_ppp</span> <span class="o">=</span> <span class="n">ppp</span><span class="p">;</span>    <span class="c1">// r_ppp是指向int***类型的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;*</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;**</span><span class="n">pp</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;***</span><span class="n">ppp</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;***</span><span class="n">r_ppp</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><a href="https://blog.csdn.net/stephen_999/article/details/128381419?spm=1001.2014.3001.5502"># 各类指针的详细介绍</a></li>
</ul>
<h3 id="指针与引用">指针与引用</h3>
<ul>
<li>不同
<ul>
<li>指针存储一个变量地址，是一个对象；而引用只是变量的一个别名</li>
<li>引用在定义时必须要进行初始化，而指针不用</li>
<li>指针可以在任意时候改变指向，引用在初始化时绑定对象后就无法改变绑定的对象</li>
<li>sizeof(引用)=引用类型的大小，sizeof(指针)=4或8（地址空间所占字节数）</li>
<li>自加效果不同</li>
<li>有多级指针，但是没有多级引用</li>
<li>存在指向指针的指针，无引用的引用，不能定义指向引用的指针，可以定义指向指针的引用。</li>
</ul>
</li>
<li>编译器实际上是将对引用的操作翻译成对指针的操作
<ul>
<li>[# 简谈 C++ 中指针与引用的底层实现](# 简谈 C++ 中指针与引用的底层实现)</li>
</ul>
</li>
</ul>
<h2 id="24-const限定符">2.4 const限定符</h2>
<h3 id="初始化和const">初始化和const</h3>
<ul>
<li>const表示<strong>编译器限制</strong>该变量只能是只读的，修改变量时编译器会报错，因此const对象必须在一开始声明时进行赋值
<ul>
<li>在C中，可以使用指针指向const对象，进行修改（不要这样写）</li>
<li>在CPP中，使用非const指针指向const对象会报错（但是可以将const指针强转为普通指针进而修改，不要这样写）</li>
</ul>
</li>
<li>const变量默认不能被其他文件访问（作用域在本模块中）
<ul>
<li>如果非要共享const对象，不管是声明还是定义，都要加上extern关键字（因此C++中const变量从内部变量转变为extern const的外部变量，如果再初始化就变成强符号）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">-</th>
<th style="text-align:center">const</th>
<th style="text-align:center">extern const</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">global</td>
<td style="text-align:center">global</td>
<td style="text-align:center">global</td>
</tr>
<tr>
<td style="text-align:center">C++</td>
<td style="text-align:center">global</td>
<td style="text-align:center"><strong>local</strong></td>
<td style="text-align:center">global</td>
</tr>
</tbody>
</table>
<p><a href="https://blog.csdn.net/audio_algorithm/article/details/79420067">两个例子</a></p>
<ul>
<li>参考
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/55984950">const关键字到底该怎么用</a></li>
<li><a href="https://blog.csdn.net/hyb612/article/details/102868198">C++和C中的const关键字有何区别？</a></li>
<li>好文章：<a href="https://blog.csdn.net/bendanfly/article/details/95492816">const在C语言和C++中的区别</a></li>
</ul>
</li>
</ul>
<h3 id="引用和const">引用和const</h3>
<ul>
<li><strong>reference to const</strong>（对常量的引用，简称为常量引用）：指向const对象的引用
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span> <span class="c1">// 常量引用，指向常量的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span> <span class="c1">// 错误：非常量引用绑定一个常量对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>引用的类型必须与所引用对象的类型一致
<ul>
<li>例外：在初始化常量引用时允许用任意表达式作为初始值</li>
<li>因此，对const的引用（常量引用）可能引用一个非const的对象
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 可以修改a的值,但是不能通过引用r来修改值
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>原理：如果不一致，则中间使用临时量进行类型转换，引用指向这个临时量
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">dval</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span> <span class="c1">// 常量引用r1的类型int与所引用对象dval的类型double不同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/* 相当于：
</span></span></span><span class="line"><span class="cl"><span class="cm">const int tmp = dval; // 临时未命名对象（临时量）
</span></span></span><span class="line"><span class="cl"><span class="cm">const int &amp;r1 = tmp; // 因此修改dval的值，不会影响r1
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 除了初始化常量引用时，普通引用的类型必须与所引用对象的类型一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span> <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/* 相当于：
</span></span></span><span class="line"><span class="cl"><span class="cm">int tmp = dval;
</span></span></span><span class="line"><span class="cl"><span class="cm">int &amp;r2 = tmp; // 引用绑定的是一个临时量，C++规定非法
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">int变量</th>
<th style="text-align:center">const int常量</th>
<th style="text-align:center">double变量</th>
<th style="text-align:center">const double变量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int&amp;普通引用</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">const int&amp;常量引用</td>
<td style="text-align:center">√<br/>（可以修改int的值，但是不能通过引用来修改）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">warning<br/>（见<code>dval</code>）</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<h3 id="指针和const">指针和const</h3>
<ul>
<li><strong>pointer to const</strong>（指向常量的指针）：<code>const int i = 0; const int *p = &amp;i;</code>
<ul>
<li>变量p的类型是指针<code>*</code>，指向的类型是<code>const int</code></li>
<li>指向常量的指针可以指向一个非常量对象，但是不允许通过指针修改变量的值</li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=1cb755a7-24e7-fbf3-704b-36dfb03ca19f&amp;page=83&amp;rect=275.760,153.540,324.970,163.210">底层 const</a>属性
<ul>
<li>底层const属性对元素赋值有影响：等号两边需要有相同的底层const资格，或者非常量转换为常量</li>
</ul>
</li>
</ul>
</li>
<li><strong>const pointer</strong>（常量指针）：<code>int i = 0; int *const ptr = &amp;i;</code>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=1a81ddb3-2c02-e84b-1d72-bcb87c8a7093&amp;page=83&amp;rect=378.240,168.730,430.800,179.770">顶层const</a>属性：这个类型的变量是只读的
<ul>
<li>对于常量指针而言，指针本身是常量（即指针固定指向某个地址）</li>
<li>顶层const属性对指向元素的拷贝无影响</li>
</ul>
</li>
<li>变量ptr的类型是常量指针<code>*const</code>，指向的类型是<code>int</code></li>
</ul>
</li>
</ul>
<h3 id="constexpr和常量表达式">constexpr和常量表达式</h3>
<ul>
<li>常量表达式：值不会改变，且在编译过程中就能得到计算结果的表达式。</li>
<li><code>constexpr</code>
<ul>
<li>背景：有时很难判断一个初始值是否为常量表达式（因为有的const对象的值直到运行时才能知道）</li>
<li>使用：<code>C++11</code>规定，将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量的表达式，constexpr对象的值必须在编译期间确定。
<ul>
<li>定义在函数体内部的变量，地址在编译器无法确定，无法用来初始化constexpr指针</li>
<li>定义在函数体外部的变量，地址固定，可以用来初始化constexpr指针</li>
</ul>
</li>
<li>constexpr指针相当于顶层const</li>
</ul>
</li>
<li>constexpr表示真正的常量，const表示只读</li>
</ul>
<h2 id="25-处理类型">2.5 处理类型</h2>
<h3 id="类型别名">类型别名</h3>
<ul>
<li>传统别名：使用typedef来定义类型的同义词：<code>typedef int* ptr</code></li>
<li>C++11 <strong>别名声明</strong>（alias declaration）： <code>using ptr=int*;</code></li>
<li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=b55f6917-ca80-3c5f-978c-4dbac344e382&amp;page=87&amp;rect=61.690,460.800,430.330,482.400">不能将类型别名像宏一样代回进行理解</a>，类型别名本身就表示一种类型</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">ptr</span> <span class="n">p_a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// p_a是const ptr类型的对象，即指向int的常量指针（顶层const）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// p是指向const int的指针（底层const）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">ptr</span><span class="o">*</span> <span class="n">pp_a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p_a</span><span class="p">;</span> <span class="c1">// pp_a是指向const ptr的指针，即指向int的常量指针的指针（底层const）
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="auto类型说明符">auto类型说明符</h3>
<ul>
<li>一条声明语句中只能有一个基本数据类型，但可以有复合类型（比如指针和引用）</li>
<li>复合类型自动推导
<ul>
<li>auto会忽略引用类型：
<ul>
<li><code>int i = 0, &amp;r = i; auto a = r;</code> 推断<code>a</code>的类型是<code>int</code>而非<code>int&amp;</code></li>
<li>用 auto 定义引用时，必须用&amp;指明要定义的是引用</li>
</ul>
</li>
<li>auto会忽略顶层const，但保留底层const：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">pi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">// 底层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span> <span class="c1">// *pi类型是const int，推断a的类型是int，auto忽略顶层const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span> <span class="c1">// 如果希望是顶层const需要自己加const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pi</span><span class="p">;</span> <span class="c1">// 推断p的类型是const int*，auto保留底层const
</span></span></span><span class="line"><span class="cl"><span class="c1">// *p = 2; // 报错
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h3 id="decltype类型指示符">decltype类型指示符</h3>
<ul>
<li>背景：希望获得表达式的类型但是不需要值（编译器分析类型但是不求值）</li>
<li>使用
<ul>
<li>不会忽略顶层const和引用</li>
<li>当获得的类型是引用时，必须进行初始化</li>
<li>如果表达式不是一个变量，返回表达式结果对应的类型，比如<code>b</code></li>
<li>一些表达式比如【指针解引用、变量加括号、赋值操作】的结果均为引用类型</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="n">r_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// r_a是int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// b是int型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="n">r_a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// r_a2是int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">((</span><span class="n">a</span><span class="p">))</span> <span class="n">r_a3</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// r_a3是int&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">)</span> <span class="n">r_a4</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//r_a4是int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="26-自定义数据结构">2.6 自定义数据结构</h2>
<h3 id="struct">struct</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 复杂写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">student</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">student</span> <span class="n">xiaoli</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 简单写法：使用typedef取别名，不用写struct student，而是直接写stu
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">student</span> <span class="p">{}</span> <span class="n">stu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">stu</span> <span class="n">xiaozhang</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="编写自己的ch01-开始头文件头文件">编写自己的[[ch01-开始#头文件|头文件]]</h3>
<h2 id="其他">其他</h2>
<h3 id="各种符">各种“符”</h3>
<ul>
<li>声明符（declarator）：类型修饰符（可有可无）+变量名（也称标识符）</li>
<li>类型修饰符：*，&amp;</li>
<li>标识符（identifier）：变量名</li>
<li>类型说明符（type specifier）：int，char，void等</li>
<li><a href="https://www.runoob.com/cplusplus/cpp-modifier-types.html">数据类型修饰符</a>：unsigned等</li>
<li><a href="https://www.runoob.com/cplusplus/cpp-modifier-types.html">类型限定符（qualifier）</a>：const，static等</li>
<li>访问限定符：public, private, protected</li>
</ul>
<h3 id="const和指针引用的组合">const和指针、引用的组合</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">ca</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>常量指针（const pointer）：<code>int *const p = &amp;a</code>，是顶层const</li>
<li>指向常量的指针（pointer to const）：<code>const int *p = &amp;a;*</code>，是底层const</li>
<li>对常量的引用（reference to const）：<code>const int &amp;r = a;</code></li>
<li>常量引用（const reference）：不存在</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Ch01 开始</title>
      <link>https://qinganzhang.github.io/posts/cpp-primer/ch01-%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Tue, 27 Feb 2024 15:55:43 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/cpp-primer/ch01-%E5%BC%80%E5%A7%8B/</guid>
      <description>第一章 开始 查看程序运行状态：echo $? 返回上一个命令的状态 程序正常运行，返回0，表示没有错误 返回值-1，打印255；返回值3，打印3；返回值</description>
      <content:encoded><![CDATA[<h1 id="第一章-开始">第一章 开始</h1>
<ul>
<li>
<p>查看程序运行状态：<code>echo $?</code> 返回上一个命令的状态</p>
<ul>
<li>
<p>程序正常运行，返回0，表示没有错误</p>
</li>
<li>
<p>返回值-1，打印255；返回值3，打印3；返回值-3，打印打印253</p>
</li>
</ul>
</li>
<li>
<p>endl：这是一个被称为操纵符（manipulator）的特殊值，效果是结束当前行，并将设备关联的缓冲区（buffer）中的内容刷到设备中。</p>
</li>
<li>
<p>UNIX和Mac下键盘输入文件结束符：<code>ctrl+d</code>，Windows下：<code>ctrl+z</code></p>
</li>
<li>
<p>库文件：</p>
<ul>
<li>库文件包含了一系列库函数，一般以二进制文件（链接库）的形式存放</li>
<li>源代码进行预处理编译汇编生成可重定位目标文件后，与库文件进行链接</li>
</ul>
</li>
</ul>
<h2 id="头文件">头文件</h2>
<ul>
<li>背景：不同代码写在不同模块中分别编译，链接时变量或函数需要“有且仅有一次定义，但可以多次声明”，头文件为使用模块的用户提供接口
<ul>
<li>extern进行外部变量的声明（如果对extern变量进行显式初始化则相当于进行了变量的定义）</li>
<li>使用头文件相当于将头文件中每个变量和函数的声明复制到源文件中</li>
<li>不同.cpp将可以include相同的头文件，如果.cpp编译汇编出来的目标文件进行链接，相当于进行多次声明</li>
</ul>
</li>
<li>使用：
<ul>
<li>可以将<strong>函数原型，#define预编译指令，const定义，结构声明，类声明，模板声明，内联函数</strong>放在头文件中，其定义放在对应.cpp文件中</li>
<li>头文件不会参与编译</li>
<li>使用时进行include，就相当于预处理器将extern声明插入到源代码</li>
<li>一般情况下，头文件不能放变量或函数的定义（因为可能被多个.cpp文件包含，进而链接时产生多重定义），特殊情况有：
<ul>
<li>可以定义const变量：const修饰的全局变量作用域只在当前文件中，因此不同文件中的同名const变量是不相同的两个变量，同时const保证了变量值都是常量（static变量虽然作用域只在当前文件中，但是变量值不是常量）</li>
<li>可以定义static变量和static函数</li>
<li>可以定义内联函数：编译器将内联函数进行展开，因此编译期就需要得到内联函数的完整定义</li>
<li>头文件可以定义类（否则编译器无法知道类的成员和偏移，也无法分配内存大小），而且建议头文件名字和类名一致：
<ul>
<li>对于数据成员，需要等到具体的对象创建时才被定义（分配空间）</li>
<li>对于函数成员，定义类时即被创建：可以将函数成员的实现放在类定义中，此时编译器视这个函数为内联的（不确定）；也可以将函数成员的实现单独放在一个.cpp文件中</li>
</ul>
</li>
</ul>
</li>
<li>头文件中的模板：<a href="https://zhuanlan.zhihu.com/p/387773355">模板实现为会放到头文件中</a></li>
</ul>
</li>
<li><a href="https://blog.csdn.net/weixin_43354152/article/details/128651270">两种加载头文件的方式</a>：搜索顺序不同，先找到哪个就使用哪个
<ul>
<li>标准库的头文件使用<code>&lt;&gt;</code>：编译时指定的头文件目录（<code>-I</code>参数指定）、系统环境变量<code>CPLUS_INCLUDE_PATH</code>（C++）或<code>C_INCLUDE_PATH</code>（C）指定的目录、gcc默认目录
<ul>
<li>标准库的头文件、操作系统相关头文件、安装的特定库的头文件</li>
</ul>
</li>
<li>非标准库的头文件使用<code>&quot;&quot;</code>：源文件所在目录、<code>&lt;&gt;</code>头文件搜索目录</li>
</ul>
</li>
<li>防止重复包含
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef HEADFILE_H_ </span><span class="c1">// 判断是否定义过预处理变量HEADFILE_H_（即没有include该头文件）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define HEADFILE_H_ </span><span class="c1">// 将一个名字设定为预处理变量（即定义HEADFILE_H_变量）；预处理变量的名称需要唯一（无视作用域的规则），且保持全部大写。
</span></span></span><span class="line"><span class="cl"><span class="c1">// Definition of Sales_itemclass and related functions goes here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif </span><span class="c1">// 一旦检查预处理变量的结果为真，则执行后续操作，直到遇到#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>高级IDE中可以使用<code>#pragma once</code>来防止头文件的重复包含</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/369949041">C++头文件源文件详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346839633">C++理论梳理3——深刻理解头文件的作用</a></li>
<li>好文章：<a href="https://zhuanlan.zhihu.com/p/387773355">细说C++头文件</a></li>
</ul>
</li>
<li>more reading
<ul>
<li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/">C++风格指南-头文件</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/345399752">【C语言精华】头文件组织与包含原则！纯干货，这是一篇有价值的文章！</a></li>
<li><a href="https://blog.csdn.net/fengcq126/article/details/103016917">C语言中头文件包含的处理原则</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch08 微调</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch08-%E5%BE%AE%E8%B0%83/</link>
      <pubDate>Thu, 01 Feb 2024 21:56:31 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch08-%E5%BE%AE%E8%B0%83/</guid>
      <description>41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递 一般C++传参方式有三种： 对左值引用和右值引用分别重载，需要实</description>
      <content:encoded><![CDATA[<h1 id="41针对可复制的形参在移动成本低并且一定会被复制的前提下考虑将其按值传递">41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递</h1>
<ul>
<li>一般C++传参方式有三种：
<ul>
<li>对左值引用和右值引用分别重载，需要实现两个版本</li>
<li>使用万能引用，使用时可能会实例化出多个版本，传参报错可读性差</li>
<li>传值：</li>
</ul>
</li>
<li>可以考虑参数使用按值传递的情况：
<ul>
<li>构造（拷贝构造或移动构造）：对于可拷贝的，移动开销低的，并且总是会被拷贝的形参而言，按值传递和按引用传递的效率很接近，而且按值传递更容易实现，还可能会生成更少的目标代码，只是略微引入了一点性能开销
<ul>
<li>按值传递的前提是移动操作的成本足够低廉，因为按值传递比按引用传递多一次移动操作</li>
<li>只有当形参一定会被拷贝时，才考虑按值传递；比如有时函数开始先进行if检查，即使没有满足if条件而跳出函数，也会产生形参传值构造和析构的开销</li>
</ul>
</li>
<li>赋值（拷贝赋值或移动赋值）
<ul>
<li>有时移动操作可能比直接拷贝开销更大：因为移动操作会涉及到原来对象的析构、新对象的构造，如果新对象比原来对象小，拷贝可以直接在原对象的位置上进行（具体见参考中的密码例子，如果新密码的长度比旧密码短，则新密码直接拷贝到旧密码的位置）</li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/127054642">https://blog.csdn.net/Dong_HFUT/article/details/127054642</a></li>
</ul>
</li>
</ul>
<h1 id="42考虑置入而非插入">42：考虑置入而非插入</h1>
<ul>
<li>
<p>push_back可能会创建中间临时对象，但是emplace_back使用完美转发（直接将参数匹配到构造函数），不会创建临时对象</p>
</li>
<li>
<p>多数场景下使用emplace_back比push_back高效</p>
<ul>
<li>要插入的值是通过构造函数插入容器，而非赋值
<ul>
<li>赋值：比如emplace到容器begin，此时需要构造临时对象，然后将其移动到begin，此时emplace没有优势</li>
</ul>
</li>
<li>传入参数的类型和容器元素的类型不同
<ul>
<li>如果传参类型和容器元素类型相同，也就不需要产生临时对象，emplace与push相同</li>
</ul>
</li>
<li>如果某个元素值添加重复，会使用新创建的元素值替换为原来旧的元素值</li>
</ul>
</li>
<li>
<p>使用注意：</p>
<ul>
<li>资源管理
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="n">ptrs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ptrs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">myDeleter</span><span class="p">));</span> <span class="c1">// ok，不会发生内存泄露
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ptrs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">myDeleter</span><span class="p">);</span> <span class="c1">// 如果emplace_back内部、调用构造函数之前发生异常，则会发生内存泄露
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>原因是延迟了资源管理对象的创建</li>
<li>因此要么使用<code>make_shared</code>创建智能指针，要么先创建一个临时对象然后move到emplace中</li>
</ul>
</li>
<li>与显式构造函数的交互</li>
</ul>
</li>
<li>
<p>参考</p>
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/127073175">https://blog.csdn.net/Dong_HFUT/article/details/127073175</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch07 并发API</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch07-%E5%B9%B6%E5%8F%91api/</link>
      <pubDate>Thu, 01 Feb 2024 21:56:20 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch07-%E5%B9%B6%E5%8F%91api/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    <item>
      <title>Effective Modern Cpp Reading Notes</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/effective-modern-cpp-reading-notes/</link>
      <pubDate>Thu, 01 Feb 2024 21:53:53 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/effective-modern-cpp-reading-notes/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch06 Lambda表达式</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch06-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Thu, 01 Feb 2024 21:48:40 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch06-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>31：避免默认捕获模式 闭包：lambda所创建的运行期对象 默认捕获可能导致引用悬挂 默认传引用可能导致引用悬挂 显式传引用也可能导致引用悬挂，但</description>
      <content:encoded><![CDATA[<h1 id="31避免默认捕获模式">31：避免默认捕获模式</h1>
<ul>
<li>闭包：lambda所创建的运行期对象</li>
<li>默认捕获可能导致引用悬挂
<ul>
<li>默认传引用可能导致引用悬挂
<ul>
<li>显式传引用也可能导致引用悬挂，但是可以更容易发现此处可能有引用悬挂</li>
</ul>
</li>
<li>默认传值捕获也可能导致引用悬挂</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">filters</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="c1">//    void addFilter() const{
</span></span></span><span class="line"><span class="cl"><span class="c1">//        filters.emplace_back(
</span></span></span><span class="line"><span class="cl"><span class="c1">//            [=](int value) {return value % divisor == 0;} 
</span></span></span><span class="line"><span class="cl"><span class="c1">//        ); // 看似是传值捕获，不会有引用悬挂；但是lambda只能捕获作用域中的非静态局部变量，此处的divisor其实是this-&gt;divisor，容易产生引用悬挂
</span></span></span><span class="line"><span class="cl"><span class="c1">//    }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 解决方法：使用一个局部变量复制成员变量，然后使用显式的值捕获
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">divisorCopy</span> <span class="o">=</span> <span class="n">divisor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="p">[</span><span class="n">divisorCopy</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisorCopy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">divisor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>lambda只能捕获作用域中的非静态局部变量，无法捕获静态或全局变量
<ul>
<li>捕获表示将值拷贝到闭包类中，而lambda中使用静态或全局变量，相当于是对外部的引用，因此此时lambda不是独立的</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/125037605">https://blog.csdn.net/Dong_HFUT/article/details/125037605</a></li>
</ul>
</li>
</ul>
<h1 id="32使用初始化捕获将对象移入闭包">32：使用初始化捕获将对象移入闭包</h1>
<ul>
<li>C++14使用<strong>初始化捕获模式</strong>（也称广义lambda捕获）来实现移动捕获</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">isValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">()]</span> <span class="c1">// 左边是lambda闭包内成员名称，右边是初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">{</span><span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">();}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>C++11使用<code>std::bind</code>间接实现移动捕获</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">isValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">pw</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">();},</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/125111586">https://blog.csdn.net/Dong_HFUT/article/details/125111586</a></li>
</ul>
</li>
</ul>
<h1 id="33泛型lambda的完美转发版本">33：泛型lambda的完美转发版本</h1>
<blockquote>
<p>对<code>auto&amp;&amp;</code>类型的形参使用<code>decltype</code>，以<code>std::forward</code>之</p>
</blockquote>
<ul>
<li>泛型lambda（C++14）：可以使用auto声明形参（即闭包类中的<code>operator()</code>可以使用模板实现）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 闭包类中的operator()的大致实现：auto形参实际上是模板类型推导
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">SomeCompilerGeneratedClassName</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>泛型lambda的完美转发版本：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nf">func</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">);}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 闭包类中的operator()的大致实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">SomeCompilerGeneratedClassName</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">func</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">fs</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nf">func</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...</span> <span class="p">);}</span> <span class="c1">// 变长参数版本
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/125116613">https://blog.csdn.net/Dong_HFUT/article/details/125116613</a></li>
</ul>
</li>
</ul>
<h1 id="34优先选用lambda表达式而非stdbind">34：优先选用lambda表达式，而非<code>std::bind</code></h1>
<blockquote>
<p>对于C++11，除了个别边缘case，lambda比<code>std::bind</code>更有优势；C++14，lambda完全可以替代<code>std::bind</code></p>
</blockquote>
<ul>
<li>lambda可读性更强，更容易理解
<ul>
<li>使用<code>std::bind</code>需要保持参数位置，同时需要了解其实现机制
<ul>
<li><code>std::bind</code>需要保持参数位置，因此使用时需要查看原来函数的声明，才能知道占位符对应的参数类型和参数含义；但是lambda形参列表很明确</li>
<li><code>std::bind</code>默认将参数拷贝到绑定对象内部（可以使用<code>std::ref</code>指定传引用），但是lambda可以明确指出值捕获还是引用捕获</li>
<li><code>std::bind</code>绑定对象的函数调用使用了完美转发机制，但是lambda可以从形参列表中清晰看出传值还是传引用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">Logger</span> <span class="n">logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">logger</span><span class="p">]</span> <span class="p">(</span><span class="n">CompressLevel</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">compress</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">logger</span><span class="p">);</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 捕获对象：w值捕获，logger引用捕获；形参：level传值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">compress</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">logger</span><span class="p">));</span> <span class="c1">// 需要对应参数顺序
</span></span></span><span class="line"><span class="cl"><span class="c1">// 绑定对象：w值绑定（复制），logger引用绑定；形参：level使用完美转发机制
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>std::bind</code>参数绑定和对象调用不是一个时间，因此可能出现逻辑错误（见参考）</li>
</ul>
</li>
<li>lambda灵活性更强
<ul>
<li>如果<code>std::bind</code>绑定的函数存在重载版本，则编译器无法确定使用哪个版本的重载函数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">func</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">funcType</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">bnd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">funcType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>lambda可以内联
<ul>
<li>因为<code>std::bind</code>中绑定的是函数指针，需要在运行时才能确定；但是lambda中包含函数体，可以进行内联</li>
</ul>
</li>
<li>使用<code>std::bind</code>的两个场景：在C++11中
<ul>
<li>使用<code>std::bind</code>间接实现移动捕获（[[ch06-lambda表达式#32：使用初始化捕获将对象移入闭包|C++14支持移动捕获]]）</li>
<li>使用<code>std::bind</code>绑定参数的完美转发机制，间接多态函数对象（[[ch06-lambda表达式#33：泛型lambda的完美转发版本|C++14支持泛型lambda]]）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">callableObject</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span> <span class="n">callableObject</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CallableObject</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">CallableObject</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span> <span class="c1">// 将占位符参数完美转发到可调用对象的调用运算符中
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/125130410">https://blog.csdn.net/Dong_HFUT/article/details/125130410</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch05 右值引用、移动语句和完美转发</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch05-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Thu, 01 Feb 2024 21:48:16 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch05-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</guid>
      <description>23：理解std::move和std::forward std::move：返回变量的右值引用 对const对象的移动操作会被转换为拷贝操作 因为</description>
      <content:encoded><![CDATA[<h1 id="23理解stdmove和stdforward">23：理解<code>std::move</code>和<code>std::forward</code></h1>
<ul>
<li><code>std::move</code>：返回变量的右值引用
<ul>
<li>对const对象的移动操作会被转换为拷贝操作
<ul>
<li>因为const对象经过<code>std::move</code>会返回一个const右值引用，而一般函数重载的移动版本形参都是非const的右值引用，无法匹配</li>
</ul>
</li>
<li><code>std::move</code>不移动对象，而且也不保证对象一定被移动，仅仅返回对象的右值引用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>             <span class="c1">// C++14
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>std::forward</code>：实现完美转发（保持对象的左值性或右值性）
<ul>
<li>通常情况下，形参总是左值，即使其类型是右值引用</li>
</ul>
</li>
<li><code>std::move</code>和<code>std::forward</code>只是进行类型转换，在运行时不做任何事</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123765869">https://blog.csdn.net/Dong_HFUT/article/details/123765869</a></li>
</ul>
</li>
</ul>
<h1 id="24区分万能引用和右值引用">24：区分万能引用和右值引用</h1>
<blockquote>
<p>万能引用和右值引用只是形式上类似，但这是两个概念</p>
</blockquote>
<ul>
<li>万能引用：形式为<code>T&amp;&amp;</code>或<code>auto&amp;&amp;</code>，并且存在类型推导
<ul>
<li>函数模板参数：<code>template &lt;typename T&gt; void func(T&amp;&amp; param);</code></li>
<li>auto类型推导：<code>auto&amp;&amp; val = myVal;</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">myFunc</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* do something */</span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>右值引用
<ul>
<li>带const（不是纯粹的<code>T&amp;&amp;</code>形式）：<code>template &lt;typename T&gt; void func(const T&amp;&amp; param);</code></li>
<li>形式是<code>T&amp;&amp;</code>，但是不存在类型推导：比如vector的<code>push_back</code>，但是<code>emplace_back</code>中参数是万能引用
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">vector</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// 调用push_back时，类型T已知
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span> <span class="c1">// 参数包args的类型Args独立于T，存在类型推导，这里是万能引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123773321">https://blog.csdn.net/Dong_HFUT/article/details/123773321</a></li>
</ul>
</li>
</ul>
<h1 id="25针对右值引用实施stdmove针对万能引用实施stdforward">25：针对右值引用实施<code>std::move</code>，针对万能引用实施<code>std::forward</code></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span> <span class="c1">// 以例子来说明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">name</span><span class="p">)),</span> <span class="n">sp</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">sp</span><span class="p">))</span> <span class="p">{}</span> <span class="c1">// 形参为右值引用，将形参（左值）进行移动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">newName</span><span class="p">){</span> <span class="c1">// 形参为万能引用，保持形参的左值性或右值性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;set new name:&#34;</span><span class="o">&lt;&lt;</span><span class="n">newName</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="n">name</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newName</span><span class="p">);</span> <span class="c1">// 在函数中使用move或forward时，使用的位置应该是该参数最后一次使用的时候
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">lhs</span><span class="p">.</span><span class="n">name</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">doNothing</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>    
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">sp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>重载<code>setName</code>不是一个好的设计
<ul>
<li>可能效率低：如果传入字面量，即使匹配到右值版本的函数，形参仍然会作为临时对象</li>
<li>如果有多个参数，需要重载$2^N$种，如果使用参数包，则无法实现</li>
</ul>
</li>
<li>在函数中使用move或forward时，使用的位置应该是该参数最后一次使用的时候</li>
<li>如果函数中将形参进行处理，然后返回
<ul>
<li>传值返回：如果形参是右值引用（比如<code>Widget operator+</code>成员函数），使用move返回；如果形参是万能引用（比如<code>doNothing</code>成员函数），使用forward返回</li>
<li>如果返回值是函数中的局部变量，则编译器有特定的优化：<a href="https://blog.csdn.net/Dong_HFUT/article/details/123911978">RVO</a></li>
</ul>
</li>
<li>返回值优化RVO（Return Value Optimization）：减少函数返回时产生临时对象，进而消除部分拷贝或移动操作
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 原来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Widget</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// 有一次默认构造，一次拷贝构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span> <span class="c1">// 再加上一次拷贝构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用RVO优化，上面过程相当于：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span> <span class="n">w</span><span class="p">.</span><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// Widget w在外面分配空间，直接传入func中进行构造，因此只需要一次（默认）构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// NRVO(Named Return Value Optimization)原理类似
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">w</span><span class="p">;</span> <span class="c1">// 返回对象已经具名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>使用前提：局部对象的类型和返回值类型相同，而且局部对象就是返回值</li>
<li>限制场景：
<ul>
<li>返回<code>std::move()</code>：默认构造+移动构造</li>
<li>进行赋值而非初始化<code>Widget w; w = func();</code>：默认构造+func中的默认构造和拷贝构造</li>
<li>不同的分支条件下，返回不同的局部对象</li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123946594">https://blog.csdn.net/Dong_HFUT/article/details/123946594</a></li>
</ul>
</li>
</ul>
<h1 id="26避免依万能引用类型进行重载">26：避免依万能引用类型进行重载</h1>
<ul>
<li>原因：函数匹配规则
<ul>
<li>如果模板实例化出的函数和普通重载函数都精确匹配，则优先选择普通重载函数，其次选择模板函数实例化出来的精确版本</li>
</ul>
</li>
<li>例子</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>        
</span></span><span class="line"><span class="cl">        <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// 对Person(int)的重载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">short</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Person</span> <span class="nf">p1</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">// 会调用模板实例化的版本，而非进行类型转换调用普通版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">Person</span> <span class="nf">p2</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 这个情况极其容易混淆，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Person</span> <span class="nf">q2</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span> <span class="c1">// 会调用生成的拷贝构造函数（因为其实参为const Person&amp;）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Person</span> <span class="nf">q1</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span> <span class="c1">// 会调用模板实例化的版本，而非调用生成的拷贝构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 尤其当Person作为基类，派生类在构造函数中初始化基类部分时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">SpecialPerson</span><span class="o">:</span> <span class="k">public</span> <span class="n">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpecialPerson</span><span class="p">(</span><span class="k">const</span> <span class="n">SpecialPerson</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="o">:</span> <span class="n">Person</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="n">SpecialPerson</span><span class="p">(</span><span class="n">SpecialPerson</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="o">:</span> <span class="n">Person</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这两个构造函数均使用基类Person构造函数的完美转发版本，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 对万能引用参数的函数进行重载，不是一个好的设计
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="27熟悉依万能引用类型进行重载的替代方案">27：熟悉依万能引用类型进行重载的替代方案</h1>
<ul>
<li>
<p>放弃重载，使用不同的函数名</p>
<ul>
<li>但是对于构造函数就无能为力</li>
</ul>
</li>
<li>
<p>普通函数形参为<code>const type&amp;</code>类型</p>
<ul>
<li>因此传入const实参，会优先使用原来的普通版本，而非重载的万能引用版本</li>
</ul>
</li>
<li>
<p>将形参从引用类型换成值类型：当知道肯定要复制形参时，考虑按值传递</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span><span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>使用Tag分发：使用Tag对参数进行区分，进而分发到不同的函数实现</p>
<ul>
<li>背景：如果想使用完美转发，就必须要使用万能引用</li>
<li>例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 两个函数实现的版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">logAndAddImpl</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">logAndAddImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用Tag对参数进行区分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">logAndAdd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">logAndAddImpl</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span> <span class="c1">// 或者C++14：std::is_integral&lt;typename std::remove_reference_t&lt;T&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果传入true or false，到运行时才能决定</li>
<li>在编译阶段进行模板匹配，<code>std::is_integral</code>在编译阶段就可以判断类型是否为整型</li>
</ul>
</li>
</ul>
</li>
<li>
<p>约束接受万能引用的模板：<code>std::enable_if</code>判断</p>
<ul>
<li>背景：构造函数无法使用Tag分发</li>
<li>例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">nameFromIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of_v</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> 
</span></span><span class="line"><span class="cl">                <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>                    
</span></span><span class="line"><span class="cl">            <span class="o">&gt;</span>            
</span></span><span class="line"><span class="cl">    <span class="o">&gt;</span> <span class="c1">// 当类型T不为Person或者其派生类，抑或T不为int型时，才会选择这个的重载版本，使用万能引用进行重载并实现完美转发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">static_assert</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">::</span><span class="n">value</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="s">&#34;Parameter name can&#39;t be used to construct a std::string&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span> <span class="c1">// 验证类型为std::string的对象能否被类型为T的对象构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>std::enable_if&lt;condition&gt;::type</code>：只有满足条件的模板才会使用（C++14<code>std::enable_if_t</code>）</li>
<li><code>std::is_same&lt;T1, T2&gt;::value</code>（C++17<code>std::is_same_v</code>）</li>
<li><code>std::is_base_of&lt;T1, T2&gt;::value</code>：如果T2继承于T1，则为true；且<code>std::is_base_of&lt;T, T&gt;::value==true</code>（C++17<code>std::is_base_of_v</code>）</li>
<li><code>std::decay&lt;T&gt;::type</code>的类型与T的类型相同，忽略了引用、const、volatile（C++14<code>std::decay_t</code>）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>权衡</p>
<ul>
<li>前三种方案都需要对需要调用的函数形参逐一指定其类型，后两种方案使用万能引用实现了完美转发</li>
<li>虽然完美转发效率更高（避免创建临时对象），但是某些对象无法实现完美转发，并且使用完美转发并编译报错时，报错信息的可读性很差
<ul>
<li><code>std::is_constructible</code>可以在编译期测试一个类型的对象能否被另一个不同类型的对象（或者多个不同类型的多个对象）构造，因此可以用来验证转发函数的万能引用参数是否合法</li>
</ul>
</li>
</ul>
</li>
<li>
<p>参考</p>
<ul>
<li>SFINAE技术</li>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/124227488">https://blog.csdn.net/Dong_HFUT/article/details/124227488</a></li>
</ul>
</li>
</ul>
<h1 id="28理解引用折叠">28：理解引用折叠</h1>
<ul>
<li>几种引用折叠的应用场景：
<ul>
<li>万能引用的实例化：在模板类型推导时，可能出现“引用的引用”的情况，此时需要用到引用折叠</li>
<li><code>std::forward</code>完美转发：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>auto类型推导，decltype类型推导</li>
<li>typedef类型别名</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/124517043">https://blog.csdn.net/Dong_HFUT/article/details/124517043</a></li>
</ul>
</li>
</ul>
<h1 id="29假定移动操作不存在成本高未使用">29：假定移动操作不存在、成本高、未使用</h1>
<ul>
<li>几种移动语义不可用、不高效的情况：
<ul>
<li>没有移动操作：编译器只有在没有用户自定义拷贝操作和析构函数时，才自动生成移动操作</li>
<li>移动未能更快：
<ul>
<li><code>std:array</code>
<ul>
<li>一般STL中容器的对象都分配在堆上，对象中有指向堆上内存的指针，因此移动操作只需要进行指针的更新、源对象的指针置空即可</li>
<li>但是<code>std::array</code>中内容分配在栈上（栈上的数组），移动操作等于复制操作</li>
</ul>
</li>
<li><code>std::string</code>
<ul>
<li><code>std::string</code>针对小对象有一个优化SSO（Small String Optimization），小对象直接存储在栈上而非堆上，省去动态内存分配</li>
</ul>
</li>
</ul>
</li>
<li>移动不可用：移动操作没有标记为<code>noexcept</code>
<ul>
<li>如果移动操作没有标记为<code>noexcept</code>，即使是适合使用移动操作的场景，编译器也会使用复制操作替代</li>
</ul>
</li>
<li>源对象是左值：只有右值可以作为移动操作的源（左值可以用，但是很容易造成空悬问题）</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/124577258">https://blog.csdn.net/Dong_HFUT/article/details/124577258</a></li>
</ul>
</li>
</ul>
<h1 id="30熟悉完美转发的失败情形">30：熟悉完美转发的失败情形</h1>
<ul>
<li>完美转发的含义：不仅转发对象，而且转发其特征（左值、右值、const、volatile）</li>
<li>完美转发的失败情形
<ul>
<li>列表初始化
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">fwd</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fwd</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span> <span class="c1">// 编译报错：无法推断出T的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">il</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">fwd</span><span class="p">(</span><span class="n">il</span><span class="p">);</span> <span class="c1">// T=initializer_list&lt;int&gt;
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>0或NULL作为空指针
<ul>
<li>0或NULL会被推导为int型而非空指针类型，因此完美转发后得到的类型是int，但是形参是指针类型</li>
</ul>
</li>
<li>仅仅声明整型的静态常量数据成员
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">cosnt</span> <span class="kt">int</span> <span class="n">cnst</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// 声明而非定义，不会分配实际的存储空间，而是常量传播（直接将用到cnst的地方替换为12）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">fwd</span><span class="p">(</span><span class="n">Widget</span><span class="o">::</span><span class="n">cnst</span><span class="p">);</span> <span class="c1">// 编译报错：找不到cnst的定义
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>只声明不会分配空间，因此无法取地址，也无法使用引用，不能使用完美转发</li>
<li>解决方法：在类外或是对应.cpp文件中添加定义：<code>const int cnst = 12;</code></li>
</ul>
</li>
<li>函数重载和函数模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="kt">int</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">func</span><span class="p">);</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fwd</span><span class="p">(</span><span class="n">func</span><span class="p">);</span> <span class="c1">// 模板类型推导失败：无法确定是哪个重载版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 解决方法：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">FuncType</span> <span class="o">=</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">fwd</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">FuncType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 但是万能引用和完美转发一般是针对任意类型的，这里限定了类型，语义与实现矛盾
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>位域：位域只是int类型的一部分，没有一个确切地址，也就无法引用</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/124787082">https://blog.csdn.net/Dong_HFUT/article/details/124787082</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch04 智能指针</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch04-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 01 Feb 2024 21:47:58 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch04-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>18：使用std::unique_ptr管理具备专属所有权的资源 std::unique_ptr表示独占所有权，因此无法拷贝（拷贝构造、拷贝赋</description>
      <content:encoded><![CDATA[<h1 id="18使用stdunique_ptr管理具备专属所有权的资源">18：使用<code>std::unique_ptr</code>管理具备专属所有权的资源</h1>
<ul>
<li><code>std::unique_ptr</code>表示独占所有权，因此无法拷贝（拷贝构造、拷贝赋值是delete的），只能进行移动操作从而转移资源控制权
<ul>
<li>例外：可以从函数返回一个<code>std::unique_ptr</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">delInt</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;My deleter&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">delInt</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">pInt</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">delInt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pInt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>删除器是<code>std::unique_ptr</code>类型的一部分
<ul>
<li>在不定义删除器的情况下，<code>std::unique_ptr</code>内存占用和原始指针相同</li>
<li>如果自定义删除器，则<code>std::unique_ptr</code>内存占用会变大</li>
</ul>
</li>
<li><code>std::unique_ptr</code>可以指向数组，默认删除器为<code>delete[]</code>：<code>std::unique_ptr&lt;int[]&gt; p(new int[5]{1,2,3,4,5});</code>
<ul>
<li>但是数组形式用到的场合很少，尽量使用STL</li>
</ul>
</li>
<li><code>std::unique_ptr</code>可以直接隐式转换为<code>std::shared_ptr</code></li>
<li>典型应用：针对继承体系，作为工厂函数的返回值类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cat</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">makeAnimal</span><span class="p">(</span><span class="n">AnimalType</span> <span class="n">type</span><span class="p">,</span> <span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">AnimalInfo</span><span class="p">){</span> <span class="c1">// C++14中函数返回值可以写为auto，因此unique_ptr的删除器可以放在函数内部，否则显式写出返回类型时需要知道删除器类型，因此删除器只能写在函数外部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">delAnimal</span> <span class="o">=</span> <span class="p">[](</span><span class="n">AnimalType</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span> <span class="n">makeMyLog</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">delAnimal</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">up</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">delAnimal</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">Dog</span><span class="p">)</span> <span class="n">up</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Dog</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AnimalInfo</span><span class="p">)...));</span> <span class="c1">// 参数是万能引用，这里进行完美转发
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">Cat</span><span class="p">)</span> <span class="n">up</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AnimalInfo</span><span class="p">)...));</span> <span class="c1">// 使用reset使得指针独占资源的所有权，不能直接将原始指针赋值给智能指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">up</span><span class="p">;</span> <span class="c1">// 返回unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123465058">https://blog.csdn.net/Dong_HFUT/article/details/123465058</a></li>
</ul>
</li>
</ul>
<h1 id="19使用stdshared_ptr管理具备共享所有权的资源">19：使用<code>std::shared_ptr</code>管理具备共享所有权的资源</h1>
<ul>
<li><code>std::shared_ptr</code>可以拷贝，通过引用计数来管理资源的生命周期</li>
<li><code>std::shared_ptr</code>内存模型
<ul>
<li>一个<code>std::shared_ptr</code>大小通常为普通指针的两倍：一个指针指向资源，另一个指针指向控制块</li>
<li>控制块中通过原子操作维护引用计数，保存deleter（因此deleter不属于<code>std::shared_ptr</code>类型的一部分），保存弱计数等</li>
</ul>
</li>
<li><code>std::shared_ptr</code>的使用：
<ul>
<li>使用<code>std::make_shared</code>、<code>std::unique_ptr</code>、原始指针创建<code>std::shared_ptr</code>，会为资源创建一个控制块
<ul>
<li>如果资源有多个控制块，就会被多次析构，因此尽量避免使用原始指针构造<code>std::shared_ptr</code></li>
</ul>
</li>
<li>使用<code>std::shared_ptr</code>或<code>std::weak_ptr</code>创建一个<code>std::shared_ptr</code>，不会创建一个新的控制块</li>
<li><code>this</code>的陷阱：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;&gt;</span> <span class="n">eatList</span><span class="p">;</span> <span class="c1">// 追踪哪些Animal调用了eat方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Animal</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">eatList</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// eatList.push_back(shared_ptr&lt;Animal&gt;(this));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cat</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Dog</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animai</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">myCat</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">myCat</span><span class="o">-&gt;</span><span class="n">eat</span><span class="p">();</span> <span class="c1">// 针对同一个对象创建了两个控制块
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>解决方法一：使类继承自<code>std::enable_shared_from_this</code>，类内部使用<code>shared_from_this</code>方法，搜索当前对象的控制块，如果有就不用创建控制块了，如果没有则抛出异常，因此适合于当前对象已经创建过控制块的情况
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;&gt;</span> <span class="n">eatList</span><span class="p">;</span> <span class="c1">// 追踪哪些Animal调用了eat方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Animal</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">eatList</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span> <span class="c1">// eatList.push_back(shared_ptr&lt;Animal&gt;(shared_from_this()));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cat</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Dog</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animai</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">myCat</span><span class="p">(</span><span class="k">new</span> <span class="n">Cat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">myCat</span><span class="o">-&gt;</span><span class="n">eat</span><span class="p">();</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>解决方法二：见127页，代码是自己实现的，有误
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;&gt;</span> <span class="n">eatList</span><span class="p">;</span> <span class="c1">// 追踪哪些Animal调用了eat方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Animal</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Animal</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">foward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...));</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">            <span class="n">eatList</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span> <span class="c1">// eatList.push_back(shared_ptr&lt;Animal&gt;(shared_from_this()));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">Animal</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cat</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Dog</span><span class="o">:</span> <span class="k">public</span> <span class="n">Animai</span><span class="p">{};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123599599">https://blog.csdn.net/Dong_HFUT/article/details/123599599</a></li>
</ul>
</li>
</ul>
<h1 id="20对于类似stdshared_ptr但是可能空悬的指针使用stdweak_ptr">20：对于类似<code>std::shared_ptr</code>但是可能空悬的指针使用<code>std::weak_ptr</code></h1>
<ul>
<li><code>std::weak_ptr</code>通常视为<code>std::shared_ptr</code>的辅助工具，通过<code>std::shared_ptr</code>构造<code>std::weak_ptr</code>
<ul>
<li><code>std::weak_ptr</code>不会影响对象的引用计数</li>
<li>但是<code>std::weak_ptr</code>没有解引用操作，必须调用<code>lock</code>转换为<code>std::shared_ptr</code>来访问对象
<ul>
<li>例子：<code>if(shared_ptr&lt;int&gt; p = wp.lock()&gt; cout&lt;&lt;*p&lt;&lt;endl;</code></li>
</ul>
</li>
</ul>
</li>
<li>典型应用：
<ul>
<li>避免<code>shared_ptr</code>循环引用：将其中一个<code>shared_ptr</code>改为<code>weak_ptr</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">pb</span><span class="p">;</span> <span class="c1">// std::weak_ptr&lt;B&gt; pb;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">B</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">pa</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">pa</span><span class="o">-&gt;</span><span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span><span class="p">;</span> <span class="c1">// pb和pa-&gt;pb同时指向同一个对象B，引用计数为2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pb</span><span class="o">-&gt;</span><span class="n">pa</span> <span class="o">=</span> <span class="n">pa</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>带缓存的工厂方法
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">fastLoadWidget</span><span class="p">(</span><span class="n">WidgetID</span> <span class="n">id</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">WidgetID</span><span class="p">,</span> <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&gt;&gt;</span>  <span class="n">cache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&gt;</span> <span class="n">widgetPtr</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">widgetPtr</span><span class="p">){</span> <span class="c1">// 缓存中没有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">widgetPtr</span> <span class="o">=</span> <span class="n">loadWidget</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">// 调用原始工厂方法创建，并加入到缓存中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cache</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">widgetPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">widgetPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>观察者设计模式：多个观察者（observer）对象同时监听一个主题（subject）对象，主题对象会在其发生状态改变时发出通知。主题对象不会控制其观察者的生存期，但需要确认当一个观察者对象被析构后，主题对象不会再访问它。一种合理的设计就是让每个主题对象持有指向其观察者对象的<code>std::weak_ptr</code>，以便在使用之前确认它是否空悬。</li>
</ul>
</li>
<li>参考：
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123612236">https://blog.csdn.net/Dong_HFUT/article/details/123612236</a></li>
</ul>
</li>
</ul>
<h1 id="21优先选用stdmake_unqiue和stdmake_shared而非直接使用new">21：优先选用<code>std::make_unqiue</code>和<code>std::make_shared</code>，而非直接使用new</h1>
<ul>
<li>make函数可以传入任意集合的参数，然后完美转发给构造函数，并动态创建一个对象，返回智能指针
<ul>
<li>支持auto</li>
<li>避免异常：将[[ch03-资源管理#17：以独立语句将new的对象置入智能指针| effective C++ item17：以独立语句将new的对象置入智能指针]]改进为使用make函数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">),</span> <span class="n">priority</span><span class="p">);</span> <span class="c1">// 可能由于异常导致内存泄露
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">priority</span><span class="p">);</span> <span class="c1">// 不会由于异常导致内存泄露
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果需要自定义删除器，并且又可以避免异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">myDeleter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sp</span><span class="p">),</span> <span class="n">priority</span><span class="p">);</span> <span class="c1">// 直接传递一个右值，避免了修改引用计数
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>效率更高：make函数只需要申请一次内存（同时存储对象和控制块），但是使用<code>shared_ptr&lt;Widget&gt;(new Widget)</code>需要申请两次内存（一次对象，一次控制块）</li>
<li>make函数的缺点：
<ul>
<li>无法自定义deleter</li>
<li>语义歧义：比如使用<code>()</code>和<code>{}</code>初始化vector代表不同的方式，make函数可以完美转发<code>()</code>，不支持完美转发<code>{}</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">sp1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// {3,3};
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">sp2</span><span class="p">(</span><span class="k">new</span> <span class="n">vector</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">initList</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">sp3</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">initList</span><span class="p">);</span> <span class="c1">// 不支持：make_shared&lt;vector&lt;int&gt;&gt;({1,2,3,4,5});
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>不建议对自定义内存管理方式的类使用 make 函数：通常情况下，类自定义的<code>operator new</code>和<code>operator delete</code>被设计成用来分配和释放能精确容纳该类大小的内存块，但<code>std::allocate_shared</code>所要求的内存大小并不等于动态分配对象的大小，而是在其基础上加上控制块的大小。</li>
<li>若存在非常大的对象和比相应的<code>std::shared_ptr</code>生存期更久的<code>std::weak_ptr</code>，不建议使用 make 函数，会导致对象的析构和内存的释放之间产生延迟
<ul>
<li>如果只申请一块内存（make函数），如果后来<code>shared_ptr</code>的引用计数为0，但是<code>weak_ptr</code>的引用计数不为0时，对象销毁会被延长，只有当<code>weak_ptr</code>的引用计数为0时，控制块才被释放</li>
<li>如果使用new的话，可以立即销毁对象</li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123622543">https://blog.csdn.net/Dong_HFUT/article/details/123622543</a></li>
</ul>
</li>
</ul>
<h1 id="22使用pimpl习惯用法时将特殊成员函数的定义放到实现文件中">22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h1>
<ul>
<li>PImpl技术（Pointer to Implementation，编译防火墙）：将类的实现放在另一个单独的类中，并通过不透明的指针进行访问。因此可以有效减少编译依赖。
<ul>
<li>原理：一个只声明但是不定义的类型是不完整类型，声明指向它的指针是可以通过编译的</li>
</ul>
</li>
<li>常见错误：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// in &#34;widget.h&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>                 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//==================================================================================//
</span></span></span><span class="line"><span class="cl"><span class="c1">// in &#34;widget.cpp&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">  
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">()</span><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">()){}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//==================================================================================//
</span></span></span><span class="line"><span class="cl"><span class="c1">// in &#34;main.cpp&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span> <span class="c1">// 报错：/usr/include/c++/9/bits/unique_ptr.h:79:16: error: invalid application of ‘sizeof’ to incomplete type ‘Widget::Impl’
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>报错原因：在析构<code>Widget w</code>时，此时看到的<code>Impl</code>是不完整类型
<ul>
<li>在编译<code>widget.cpp</code>时没有问题：<code>g++ -c widget.cpp -o widget.o</code></li>
<li>在编译<code>main.cpp</code>时出问题：<code>g++ -c main.cpp -o main.o</code>
<ul>
<li>没有定义<code>Widget</code>的析构函数，因此使用自动生成的析构函数（默认是<code>inline</code>的）</li>
<li>本来如果声明了<code>Widget</code>的析构函数，编译时无法进行处理，后面链接时链接到定义，运行时才能析构<code>pImpl</code>（因为经过链接，此时也知道<code>Impl</code>是完整类型）</li>
<li>但是正因为自动生成的析构函数是<code>inline</code>的，编译时就可以展开，此时析构<code>pImpl</code>当然看到的<code>Impl</code>是不完整类型（还没有链接到<code>widget.o</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>使用说明
<ul>
<li>考虑到如上报错和[[ch03-转向现代C++#17：理解特殊成员函数的生成机制|item17：理解特殊成员函数的生成机制]]，因此最好将拷贝控制成员和析构函数自定义，且声明与实现分离（防止进行内联）</li>
<li>为了实现PImpl技术，使用<code>unique_ptr</code>是最合适的，因为<code>pImpl</code>指针独享<code>Impl</code>的所有权，如果使用<code>shared_ptr</code>则上述报错不会出现（因为删除器不属于类型的一部分，属于控制块，不会包含删除器的代码）</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123704824">https://blog.csdn.net/Dong_HFUT/article/details/123704824</a></li>
<li><a href="https://github.com/liuzengh/CppIdioms/blob/main/code/pimpl/person.cpp">https://github.com/liuzengh/CppIdioms/blob/main/code/pimpl/person.cpp</a></li>
</ul>
</li>
<li>实例
<ul>
<li><code>widget.h</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Widget</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// std::string _name;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>widget.cpp</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="o">::</span><span class="n">Impl</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">_name</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::~</span><span class="n">Widget</span><span class="p">()</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="o">:</span> <span class="n">pImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">Widget</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pImpl</span> <span class="o">=</span> <span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pImpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">Widget</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span><span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Widget</span><span class="o">::</span><span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pImpl</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">();}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>main.cpp</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;widget.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;iostream&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span> <span class="n">w</span><span class="p">(</span><span class="s">&#34;zhang&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">w</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch03 转向现代C&#43;&#43;</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch03-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c&#43;&#43;/</link>
      <pubDate>Thu, 01 Feb 2024 21:47:37 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch03-%E8%BD%AC%E5%90%91%E7%8E%B0%E4%BB%A3c&#43;&#43;/</guid>
      <description>07：在创建对象时注意区分()和{} 初始化方式 1 2 3 4 int x1(1); int x2 = 2; int x3{3}; // 统一初始化（列表初始化） int x4 = {4}; // 和第三种方式相同 ()和=初始化的限</description>
      <content:encoded><![CDATA[<h1 id="07在创建对象时注意区分和">07：在创建对象时注意区分<code>()</code>和<code>{}</code></h1>
<ul>
<li>初始化方式
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">x1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x3</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// 统一初始化（列表初始化）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">x4</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">};</span> <span class="c1">// 和第三种方式相同
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>()</code>和<code>=</code>初始化的限制
<ul>
<li><code>()</code>不能用于non-static成员的初始化</li>
<li>不能拷贝的对象不能使用<code>()</code>初始化</li>
</ul>
</li>
<li><code>{}</code>初始化的优点
<ul>
<li>禁止基本类型之间的隐式窄化类型转换：比如不能使用double初始化int型变量</li>
<li>避免了C++复杂的语法分析：<a href="https://blog.csdn.net/Dong_HFUT/article/details/126435993">C++&rsquo;s most vexing parse</a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Widget</span> <span class="nf">w1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 传入一个实参，构造出一个对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w2</span><span class="p">();</span> <span class="c1">// 本来想调用无形参的构造函数构造一个对象，但是实际上声明了一个函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w3</span><span class="p">{};</span> <span class="c1">// 调用无形参的构造函数，构造出一个对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li><code>{}</code>的缺陷
<ul>
<li>auto类型推导中使用<code>{}</code>进行初始化，则auto被推断为<code>initializer_list&lt;T&gt;</code></li>
<li>会优先使用形参为<code>initializer_list&lt;T&gt;</code>的构造函数，即使其他的构造函数更加匹配
<ul>
<li>只有当<code>{}</code>中参数无法转换为<code>initializer_list</code>中类型时，编译器才匹配普通函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">()</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;0&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;1&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;2&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;copy ctor&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;move copy ctor&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;convert to int&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">w1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，即使Widget(int i, bool d)更加匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w2</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">};</span> <span class="c1">// 编译报错，本来调用Widget(initializer_list&lt;int&gt; il)，但是使用{}初始化禁止窄化类型转换（存在从double到int的转换）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w3</span><span class="p">{</span><span class="n">w1</span><span class="p">};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)（中间先将w1转为int），即使Widget(const Widget&amp; w)更加匹配（如果w1无法转换为int，则调用该构造函数）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w4</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w1</span><span class="p">)};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，即使Widget(Widget&amp;&amp; w)更加匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 特殊情况：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w4</span><span class="p">{};</span> <span class="c1">// 调用Widget()，而非调用Widget(initializer_list&lt;int&gt; il)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">w5</span><span class="p">{{}};</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，而非调用Widget()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="nf">w6</span><span class="p">({});</span> <span class="c1">// 调用Widget(initializer_list&lt;int&gt; il)，而非调用Widget()
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>使用模板创建对象时，仔细考虑使用<code>()</code>还是<code>{}</code>进行初始化
<ul>
<li>标准库函数<code>std::make_unique</code>和<code>std::make_shared</code>也面临着这个问题，它们的解决方案是在内部使用小括号，并将这个决定写进文档中，作为其接口的组成部分。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">){</span> <span class="c1">// 使用可变参数模板
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">T</span> <span class="nf">localVector1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">localVector2</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 推断出T=vector&lt;int&gt;, Ts=int
</span></span></span><span class="line"><span class="cl"><span class="c1">// localVector1: 4,4,4
</span></span></span><span class="line"><span class="cl"><span class="c1">// localVector2: 3,4
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122811753">https://blog.csdn.net/Dong_HFUT/article/details/122811753</a></li>
</ul>
</li>
</ul>
<h1 id="08优先选用nullptr而非0或null">08：优先选用nullptr，而非0或NULL</h1>
<ul>
<li>字面量0是一个int，NULL的实现为0L，可以转换为int，bool，<code>void*</code></li>
<li><code>nullptr</code>可以理解为任意类型的空指针
<ul>
<li>使得重载函数的调用明确</li>
<li>提高代码的清晰度</li>
<li>使用类型推导时，<code>nullptr</code>可以隐式转换为任意类型指针</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122891898">https://blog.csdn.net/Dong_HFUT/article/details/122891898</a></li>
</ul>
</li>
</ul>
<h1 id="09优先选用别名声明而非typedef">09：优先选用别名声明，而非typedef</h1>
<ul>
<li><code>using</code>别名的优点：
<ul>
<li>清晰，比<code>typedef</code>更容易理解</li>
<li>可以直接对模板起别名
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">MyAllocList</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 如果非要使用typedef，需要包装一层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">MyAllocList</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list1</span><span class="p">;</span> <span class="c1">// list1=std::list&lt;T, MyAlloc&lt;T&gt;&gt;,此时MyAllocList一定是一个别名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">typename</span> <span class="n">MyAllocList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">list2</span><span class="p">;</span> <span class="c1">// list2=MyAllocList&lt;T&gt;中的std::list&lt;T, MyAlloc&lt;T&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 需要使用typename显式说明MyAllocList&lt;T&gt;::type是一个类型，而非数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>应用：标准库的<code>&lt;type_traits&gt;</code>中提供了一整套用于类型转换的类模板
<ul>
<li>虽然C++11中仍然是使用<code>typedef</code>实现的，但是C++14中是使用<code>using</code>声明实现的</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">remove_const</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="c1">// C++11中, 是一个内部包裹typedef的类模板，将T中的const属性移除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">remove_const_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>     <span class="c1">// C++14中, 是一个类模板中typedef别名的别名，将T中的const属性移除
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122847510">https://blog.csdn.net/Dong_HFUT/article/details/122847510</a></li>
</ul>
</li>
</ul>
<h1 id="10优先选用限定作用域的枚举类型而非不限作用域的枚举类型">10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h1>
<ul>
<li>无作用域限制的枚举（unscoped enums，C++98）
<ul>
<li>有时使用可能简便一点
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">UserInfo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="c1">//name, email,age
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="nc">UserInfoFields</span> <span class="p">{</span><span class="n">uiName</span><span class="p">,</span> <span class="n">uiEmail</span><span class="p">,</span> <span class="n">uiAge</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">UserInfo</span> <span class="n">uInfo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// 位置1为email
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">uiEmail</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// 发生隐式类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">UserInfoFields</span><span class="o">::</span><span class="n">uiEmail</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span> <span class="c1">// 冗余
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// C++14下的辅助类:既想使用有作用限制的枚举，又不想过于啰嗦
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">toUType</span><span class="p">(</span><span class="n">E</span> <span class="n">enumerator</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">enumerator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">toUType</span><span class="p">(</span><span class="n">UserInfoFields</span><span class="o">::</span><span class="n">uiEmail</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">uInfo</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>有作用域限制的枚举（scoped enums，C++11）
<ul>
<li>减少名称污染
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">unscopedColor</span><span class="p">{</span><span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">black</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 无作用域限制的枚举，因此枚举类型暴露在{}之外
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">scopedColor</span> <span class="p">{</span><span class="n">red</span><span class="p">,</span> <span class="n">blue</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">red</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 有作用域限制的枚举，枚举类型限制在{}之内，因此减少名称污染
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>有强类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">unscopedColor</span><span class="p">{</span><span class="n">black</span><span class="p">,</span> <span class="n">white</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">black</span><span class="p">;</span> <span class="c1">// 无作用域限制的枚举，可以发生隐式类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">scopedColor</span> <span class="p">{</span><span class="n">red</span><span class="p">,</span> <span class="n">blue</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">d2</span> <span class="o">=</span>  <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">scopedColor</span><span class="o">::</span><span class="n">red</span><span class="p">);</span> <span class="c1">// 有作用域限制的枚举，不会发生隐式类型转换，类型转换需要显式说明
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>可以前向声明：只有在指定底层类型后，才能进行前向声明
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">unscopedColor</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">;</span> <span class="c1">// 没有提供默认底层类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="k">class</span><span class="err">; //默认底层类型为</span><span class="nc">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122914289">https://blog.csdn.net/Dong_HFUT/article/details/122914289</a></li>
</ul>
</li>
</ul>
<h1 id="11优先选用删除函数而非private未定义函数">11：优先选用删除函数，而非private未定义函数</h1>
<ul>
<li>背景：编译期会自动生成某些函数，但是有时不需要这些函数；</li>
<li>C++98的做法：声明为private的，且只声明不定义（effective C++中item6）
<ul>
<li>在private中声明但是不定义，使之在链接阶段因为没有定义而报错</li>
<li>在基类中声明为private的，会因为无法拷贝控制派生类中的基类部分，将报错从链接期提前到编译期</li>
</ul>
</li>
<li>C++11的做法：在声明中标记为<code>=delete</code>
<ul>
<li>将删除的函数声明为public的，原因是编译器先检查访问权限，再检查delete状态。如果将删除的函数声明为private的，调用删除的函数时，可能报错原因提示是private的；但是更期望的更明确的含义是这些函数是删除的</li>
<li><code>=delete</code>可以在任意函数中进行标记，不仅仅局限于成员函数</li>
</ul>
</li>
<li>应用：
<ul>
<li>比如可以阻止某些形参的隐式类型转换
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span><span class="k">delete</span><span class="p">;</span> <span class="c1">// 因此禁止double和float两种参数的调用（C++总是倾向于将 float 转换为 double）
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>阻止某些模板类型的实例化
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">=</span><span class="k">delete</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">g</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 成员模板函数在类外阻止某些类型的实例化
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123005509">https://blog.csdn.net/Dong_HFUT/article/details/123005509</a></li>
</ul>
</li>
</ul>
<h1 id="12给意在改写的函数添加override声明">12：给意在改写的函数添加override声明</h1>
<ul>
<li>重写override需要满足的条件
<ul>
<li>基类的重写函数必须是虚函数</li>
<li>基类和派生类的重写函数
<ul>
<li>函数名（析构函数除外）、形参类型、函数常量性完全相同</li>
<li>函数引用限定符完全相同（C++11，函数引用限定符：该成员函数可以被左值对象还是右值对象调用）</li>
<li>返回值类型、异常规格说明兼容</li>
</ul>
</li>
</ul>
</li>
<li>将重写的函数标记为<code>override</code>，如果不满足重写条件则报错</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123008755">https://blog.csdn.net/Dong_HFUT/article/details/123008755</a></li>
</ul>
</li>
</ul>
<h1 id="13优先选用const_iterator而非iterator">13：优先选用<code>const_iterator</code>，而非<code>iterator</code></h1>
<ul>
<li>C++98在容器的成员函数中对<code>const_iterator</code>支持有限</li>
<li>C++11在容器的成员函数中支持<code>const_iterator</code>，但是只提供了非成员的begin和end
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="o">&gt;</span> <span class="c1">// C++11实现cbegin的方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">cbegin</span><span class="p">(</span><span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">)){</span> <span class="c1">// auto=const Container::iterator&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>C++14提供了非成员的cbegin和cend</li>
<li>尽量使用非成员的cbegin和cend，因为某些数据结构（比如数组）没有成员函数cbegin和cend，非成员的cbegin和cend更加通用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>  
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">findAndInsert</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">targetVal</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">insertVal</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">cbegin</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> <span class="n">cend</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> <span class="n">targetVal</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">container</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">insertVal</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123030976">https://blog.csdn.net/Dong_HFUT/article/details/123030976</a></li>
</ul>
</li>
</ul>
<h1 id="14只要函数不会抛出异常就为其加上noexcept声明">14：只要函数不会抛出异常，就为其加上<code>noexcept</code>声明</h1>
<blockquote>
<ul>
<li>noexcept 是函数接口的一部分，并且调用者可能会依赖这个接口。</li>
<li>相较于 non-noexcept 函数，noexcept 函数有被更好优化的机会。</li>
<li>noexcept 对于 move 操作、swap、内存释放函数和析构函数是非常有价值的。</li>
<li>大部分函数是异常中立的而不是 noexcept。</li>
</ul>
</blockquote>
<ul>
<li>背景：
<ul>
<li>C++98中异常规范的局限性：接口的实现一旦被修改，其异常规范可能也变化</li>
<li>因此C++11只需要指明接口是否可能抛出异常</li>
</ul>
</li>
<li>优点：一个<code>noexcept</code>函数有更多编译优化的机会
<ul>
<li>不需要保持运行栈为解开的状态</li>
<li>不需要保证对象以构造顺序的逆序完成析构</li>
</ul>
</li>
<li>应用：如果知道一个函数不会抛出异常，一定要加上<code>noexcept</code>
<ul>
<li><code>noexcept</code>属性对于移动操作、swap、内存释放函数和析构函数最有价值。C++11 STL 中的大部分函数遵循 “能移动则移动，必须复制才复制” 策略</li>
<li>默认<code>noexcept</code>函数：C++11内存释放函数和所有的析构函数都默认隐式地具备<code>noexcept</code>属性
<ul>
<li>析构函数未隐式地具备<code>noexcept</code>属性的唯一情况，就是所有类中有数据成员（包含递归的成员）的类型显式地将其析构函数声明为<code>noexcept(false)</code></li>
<li>如果标准库使用了某个对象，其析构函数抛出了异常，则该行为是未定义的。</li>
</ul>
</li>
</ul>
</li>
<li>条件<code>noexcept</code>：一个函数是否为<code>noexcept</code>，取决于<code>noexcept</code>中的表达式是否为<code>noexcept</code>
<ul>
<li>只有被调用的低层次的函数是<code>noexcept</code>，高层次的调用方才是<code>noexcept</code>的</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">myPair</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">myPair</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">))</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>异常中立函数：本身不抛出异常，但是调用的函数可能抛出异常，因此不适合标记为<code>noexcept</code>
<ul>
<li>但是允许<code>noexcept</code>函数中调用没有<code>noexcept</code>保证的函数</li>
</ul>
</li>
<li>通常只为宽松规约提供<code>noexcept</code>声明
<ul>
<li>宽松规约（wide contract，宽接口）：不带前提条件，被调用时不需要关注程序的状态，传入的参数方面没有限制，宽接口的函数永远不会出现未定义的行为</li>
<li>狭隘规约（narrow contract，窄接口）：带前提条件，如果违反前提条件，则结果是未定义的
<ul>
<li>调用者来保证调用时满足前提条件</li>
<li>如果调用时违反前提条件，则抛出异常；如果定义为<code>noexcept</code>的，违反前提条件结果是未定义的；相较而言，找出抛出异常的原因相对简单一些</li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123163671">https://blog.csdn.net/Dong_HFUT/article/details/123163671</a></li>
</ul>
</li>
</ul>
<h1 id="15只要有可能使用constexpr就使用它">15：只要有可能使用<code>constexpr</code>，就使用它</h1>
<ul>
<li><code>constexpr</code>对象：具备const属性，并且在编译期（和链接期）可以确定其值
<ul>
<li>const对象不能保证在编译期确定其值</li>
</ul>
</li>
<li><code>constexpr</code>函数
<ul>
<li>含义：
<ul>
<li>如果所有传入 constexpr 函数的参数都能在编译时知道，则结果将在编译时计算出来。</li>
<li>如果传入 constexpr 函数的参数有任何一个不能在编译期知道，则结果在运行时计算出来</li>
</ul>
</li>
<li>使用
<ul>
<li>C++11中，<code>constexpr</code>函数有且只能有一条return语句；C++14无此限制</li>
<li>constexpr 函数被限制只能接受和返回 literal 类型（字面量，非指针和引用，自定义类型也可能是字面量类型的）</li>
<li>C++11中，如果成员函数修改了操作的对象，或者成员函数的返回值是void的，则该成员函数无法成为<code>constexpr</code>的；C++14无此限制</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">xVal</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">yVal</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">noexcept</span><span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">xVal</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">yVal</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">getX</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="kt">double</span> <span class="nf">getY</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span><span class="k">return</span> <span class="n">y</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">        <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">setX</span><span class="p">(</span><span class="kt">double</span> <span class="n">newX</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">newX</span><span class="p">;}</span> <span class="c1">// C++14中，移除了两条限制，因此可以设置为constexpr的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">setY</span><span class="p">(</span><span class="kt">double</span> <span class="n">newY</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">newY</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">constexprt</span> <span class="n">Point</span> <span class="nf">p1</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123172189">https://blog.csdn.net/Dong_HFUT/article/details/123172189</a></li>
</ul>
</li>
</ul>
<h1 id="16保证const成员函数的线程安全性">16：保证const成员函数的线程安全性</h1>
<ul>
<li>const成员的好处：不会修改成员变量，而且可以区分重载（const对象和非const对象调用）</li>
<li>保证const成员函数的线程安全性
<ul>
<li>使用<code>std::mutex</code>，进入临界区锁对象获取互斥量，出临界区析构锁（释放互斥量）</li>
<li>使用<code>std::atomic</code>，但是只能同步单一变量或者内存单元</li>
<li><code>std::mutex</code>和<code>std::atomic</code>都是move-only的</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123316263">https://blog.csdn.net/Dong_HFUT/article/details/123316263</a></li>
</ul>
</li>
</ul>
<h1 id="17理解特殊成员函数的生成机制">17：理解特殊成员函数的生成机制</h1>
<ul>
<li>特殊成员函数（special member function）：
<ul>
<li>一般是public、inline和novirtual的
<ul>
<li>例外：如果基类中的析构函数是virtual的，派生类中的析构函数也是virtual的</li>
</ul>
</li>
<li>拷贝构造和拷贝赋值是两个独立的操作</li>
<li>移动构造和移动赋值不是独立的操作，如果声明了其中一个，编译器会阻止生成另外一个</li>
<li>如果显式申明一个拷贝操作，则两个移动操作不会自动生成</li>
</ul>
</li>
<li>三法则（The Rule of Three）：如果声明了{拷贝构造函数、拷贝赋值操作、析构函数}中任意一个，则应该声明所有这三个函数，因为往往意味着类要管理某些资源
<ul>
<li>因此，如果只声明了一个析构函数，编译器应该不会自动生成拷贝操作</li>
<li>但实际上编译器还是可能自动生成拷贝操作（历史遗留原因，以及C++11为了兼容历史代码）</li>
<li>因此，只有当类中没有声明析构函数、拷贝操作、移动操作，而且需要时，编译器才会生成移动操作</li>
</ul>
</li>
<li>如果想让编译器自动生成相关函数（即使违背了这些限制），添加<code>=default</code>进行标记</li>
<li>C++11中对特殊成员函数的生成规则：
<ul>
<li>默认构造函数：同C++98</li>
<li>析构函数：本质同C++98，只是默认声明为<code>noexcept</code></li>
<li>拷贝构造函数：运行期行为同C++98（memberwise 拷贝构造 non-static 成员变量）
<ul>
<li>如果类中声明了一个移动操作，则拷贝构造函数和拷贝赋值运算符被标记为<code>=delete</code>的</li>
<li>如果类中自定义拷贝赋值运算符或析构函数，可以生成拷贝构造函数，但是已经成为被废弃的方法</li>
</ul>
</li>
<li>拷贝赋值运算符：规则同拷贝构造函数</li>
<li>移动构造函数和移动赋值运算符：仅当类中不包含用户声明的拷贝操作、移动操作和析构函数时才生成</li>
</ul>
</li>
<li>特殊情况：成员模板函数不会抑制特殊成员函数的自动生成
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Widget</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> <span class="c1">// 编译器仍然会生成copy和move操作，即使可以实例化得到
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/123433559">https://blog.csdn.net/Dong_HFUT/article/details/123433559</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch02 Auto</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch02-auto/</link>
      <pubDate>Thu, 01 Feb 2024 21:47:20 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch02-auto/</guid>
      <description>05：优先选用auto，而非显式类型推断 优点一：避免变量未初始化 使用auto声明的变量未初始化，直接导致编译报错 优点二：简化变量声明（避免写</description>
      <content:encoded><![CDATA[<h1 id="05优先选用auto而非显式类型推断">05：优先选用auto，而非显式类型推断</h1>
<ul>
<li>优点一：避免变量未初始化
<ul>
<li>使用auto声明的变量未初始化，直接导致编译报错</li>
</ul>
</li>
<li>优点二：简化变量声明（避免写一长串类型名）</li>
<li>优点三：声明闭包类型（lambda表达式）
<ul>
<li>C++11中lambda式返回值可以使用auto，C++14中lambda式形参也可以使用auto</li>
<li><code>std::function</code>通常比起<code>auto</code>更大更慢，还可能导致内存消耗异常，因此实际使用时更推荐<code>auto</code>。
<ul>
<li>使用<code>auto</code>声明的、存储着一个闭包的变量和该闭包是同一类型，从而它要求的内存量也和该闭包相同</li>
<li>使用<code>std::function</code>声明的、存储着一个闭包的变量是<code>std::function</code>的一个实例，不管给定的签名如何，它都占有固定大小的内存，而这个大小对于其存储的闭包而言并不一定够用，如果是这样，那么<code>std::function</code>的构造函数就会分配堆上的内存来存储该闭包。</li>
</ul>
</li>
</ul>
</li>
<li>优点四：避免类型截断</li>
<li>优点五：避免类型不匹配
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">item</span><span class="p">:</span> <span class="n">mp</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// auto=std::pair&lt;const std::string,int&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 但是如果显式定义类型，很容易定义为std::pair&lt;std::string, int&gt;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h1 id="06当auto推导的类型不符合要求时使用带显式类型的初始化习惯用法">06：当auto推导的类型不符合要求时，使用带显式类型的初始化习惯用法</h1>
<blockquote>
<ul>
<li>隐式的代理类型可能导致auto类型推导结果不符合预期，因此应该显式声明类型</li>
</ul>
</blockquote>
<ul>
<li>代理类：模拟和拓展某些其他类型的行为，比如智能指针，比如<code>std::vector&lt;bool&gt;::reference</code>
<ul>
<li><code>std::vector&lt;bool&gt;</code>进行了特化，与一般<code>std::vector</code>不同：
<ul>
<li>一般对于<code>vector&lt;T&gt;</code>的<code>operator []</code>操作，返回类型为<code>T&amp;</code>；但是对于<code>vector&lt;bool&gt;</code>的<code>operator []</code>操作，返回类型为<code>vector&lt;bool&gt;::reference</code>（因此可能发生到<code>bool</code>的隐式类型转换），这是因为标准库无法返回对bit的引用</li>
<li><code>vector&lt;bool&gt;::reference</code>的实现中，可能有一个指向word的指针和一个对应的offset，很可能出现难以预料的错误
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">flg</span> <span class="o">=</span> <span class="n">func</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// func()返回一个临时的右值对象，flg是vector&lt;bool&gt;::reference类型，然后临时的右值对象被析构
</span></span></span><span class="line"><span class="cl"><span class="c1">// 因为vector&lt;bool&gt;::reference类型中可能有一个指针，再使用flg可能出现未定义的行为
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>表达式模板中，计算结果可能被解析为一棵语法解析树，而非直接返回计算结果，因此实际得到的结果类型（语法解析树）可能并非期望的类型
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/441617539"># C++元编程之表达式模板优化数组计算</a></li>
</ul>
</li>
</ul>
</li>
<li>总之，对(隐形)代理类的auto类型推导往往得到的不是预期的类型，因此要么显式声明类型，要么使用<code>static_cast</code>强转然后进行auto类型推导</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Modern Cpp Notes] Ch01 类型推导</title>
      <link>https://qinganzhang.github.io/posts/effective-modern-cpp/ch01-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</link>
      <pubDate>Thu, 01 Feb 2024 21:47:04 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-modern-cpp/ch01-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</guid>
      <description>01：理解模板类型推导 在模板类型推导中，引用类型参数将被视为非引用类型处理，也就是说其引用性被忽略。 - 在万能引用参数类型推导时，左值参数被特</description>
      <content:encoded><![CDATA[<h1 id="01理解模板类型推导">01：理解模板类型推导</h1>
<blockquote>
<ul>
<li>在模板类型推导中，引用类型参数将被视为非引用类型处理，也就是说其引用性被忽略。
- 在万能引用参数类型推导时，左值参数被特殊处理。
- 值传递形参的类型推导时，其 <em>const</em> 和 <em>volatile</em> 被忽略。
- 在模板类型推导时，数组或者函数类型被转换为指针类型，除非它们用来初始化引用。</li>
</ul>
</blockquote>
<ul>
<li>背景：有时模板类型推导无法一下看出来T是什么类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span> <span class="c1">// 比如实参可能是int, const int, const int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>类型T的推导不仅取决于expr的类型，也取决于ParamType的形式</li>
</ul>
</li>
<li>情况一：ParamType是指针或引用，但不是万能引用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">param</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>情况二：ParamType是万能引用，因此可能发生引用折叠</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>情况三：ParamType不是指针，也不是引用，因此视为值传递（实参的const/volatile性质被忽略，因为值进行了复制，形参副本不影响原来的实参）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>特殊情况一：传入的实参为数组类型
<ul>
<li>如果模板是情况一：推导出T为数组类型（包含类型和元素数量）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;zhang&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="c1">// 推导出T=const char[6], f(const char(&amp;param)[6])
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>应用：比如可以在编译阶段计算数组元素个数：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">arraySize</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span> <span class="p">{</span><span class="k">return</span> <span class="n">N</span><span class="p">;}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果模板是情况三：将数组名视为指针，因此T是指针类型</li>
</ul>
</li>
<li>特殊情况二：传入的实参为函数类型
<ul>
<li>如果模板是情况一：推导出T为函数引用类型</li>
<li>如果模板是情况三：推导出T为函数指针类型</li>
</ul>
</li>
<li>参考：
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122727237">https://blog.csdn.net/Dong_HFUT/article/details/122727237</a></li>
</ul>
</li>
</ul>
<h1 id="02理解auto类型推导">02：理解auto类型推导</h1>
<blockquote>
<ul>
<li>一般情况下，auto类型推导和模板类型推导完全相同；但是auto类型推导会假定使用<code>{}</code>的列表初始化表达式是一个<code>std::initializer_list</code>，但是模板类型推导不会</li>
<li>在函数返回值或lambda式形参中使用auto，意思是使用模板类型推导而非使用auto类型推导</li>
</ul>
</blockquote>
<ul>
<li>背景：将一个变量赋值给auto类型变量，auto是什么类型</li>
<li>同[[ch01-类型推导#01：理解模板类型推导|01：理解模板类型推导]]中的总体原则：将实参赋值给形参
<ul>
<li>除了一个例外：使用<code>{}</code>进行列表初始化</li>
<li>auto类型推导：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span> <span class="c1">// auto=std::initializer_list&lt;int&gt;,首先推导为std::initializer_list&lt;T&gt;，然后再推断类型T=int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">y</span><span class="p">{</span><span class="mi">2</span><span class="p">};</span> <span class="c1">// auto=int
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>模板类型推导：不能直接将<code>{}</code>的列表初始化表达式推导为<code>T=std::initializer_list&lt;type&gt;</code>，
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">// 报错：直接传入{}列表初始化的实参，模板类型推导失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">initList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">g</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">// T=int
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><a href="https://stackoverflow.com/questions/17582667/why-do-auto-and-template-type-deduction-differ-for-braced-initializers">为什么两种行为不同的一个可能解释</a>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 左边推导出T=vector&lt;int&gt;, 右边如果推导出T=initializer_list&lt;int&gt;,则左右冲突
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>auto可以作为函数返回值类型、lambda式形参类型（C++14）
<ul>
<li>但是原理是模板类型推导，而非auto类型推导</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122740091">https://blog.csdn.net/Dong_HFUT/article/details/122740091</a></li>
</ul>
</li>
</ul>
<h1 id="03理解decltype">03：理解<code>decltype</code></h1>
<blockquote>
<ul>
<li>绝大多数情况下，decltype会得到变量或表达式的类型，而不进行修改</li>
<li>对于类型为T的左值表达式，除非该表达式只有一个名字，否则decltype总是返回T&amp;</li>
<li>C++14支持<code>decltype(auto)</code>：auto 表示类型需要推导，decltype 表示使用decltype规则进行推导</li>
</ul>
</blockquote>
<ul>
<li>背景：给定一个名字或表达式，<code>decltype</code>返回其类型：原来是值/左值/右值，返回值/左值/右值</li>
<li>体会auto类型推导和decltype类型推导的区别
<ul>
<li>auto类型推导：将变量<code>rhs</code>赋值给<code>lhs</code>，推导出<code>lhs</code>的类型</li>
<li>decltype类型推导：返回变量<code>rhs</code>的类型</li>
</ul>
</li>
<li>使用场景：
<ul>
<li>声明一个函数模板，其返回值类型取决于参数类型
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">getItem</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltpye</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="c1">// 返回类型是引用T&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果返回值为auto，使用auto类型推导，返回类型将不是引用
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">getItem</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="c1">// 返回类型是T
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>可以同时使用auto和<code>deltype</code>：auto 表示类型需要推导，decltype 表示使用decltype规则进行推导
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">getItem</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="c1">// 返回类型是引用T&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>优化与完善：为了传入右值的<code>Container</code>，使用万能引用，同时使用完美转发
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">getItem</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="c1">// C++14，或者C++11使用尾置返回类型
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>一般而言decltype返回的类型都比较直观，除了一种情况：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// decltype(x)=int
</span></span></span><span class="line"><span class="cl"><span class="c1">// decltype((x))=int&amp;
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://blog.csdn.net/Dong_HFUT/article/details/122745518">https://blog.csdn.net/Dong_HFUT/article/details/122745518</a></li>
<li><a href="https://zyfforlinux.blog.csdn.net/article/details/52658452">https://zyfforlinux.blog.csdn.net/article/details/52658452</a></li>
</ul>
</li>
</ul>
<h1 id="04掌握查看类型推导结果的方法">04：掌握查看类型推导结果的方法</h1>
<ul>
<li>在代码编辑阶段查看类型推导结果：IDE</li>
<li>在代码编译阶段查看类型推导结果：查看编译报错</li>
<li>在代码运行阶段查看类型推导结果：
<ul>
<li><code>typeid</code>：不同编译期实现不同，无法保证完全可靠，而且类型的引用、const、volatile等性质被忽略</li>
<li>Boost库的模板函数<code>boost::typeindex::type_id_with_cvr</code>
<ul>
<li>如果类型不包含引用、const、volatile等性质，则<code>type_id_with_cvr</code>与<code>typeid</code>返回相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/type_index.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">typeindex</span><span class="o">::</span><span class="n">type_id_with_cvr</span><span class="p">;</span> <span class="c1">// c:const, v:volatile, r:reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">type_id_with_cvr</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">().</span><span class="n">pretty_name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Cpp Notes] Ch08 定制new和delete</title>
      <link>https://qinganzhang.github.io/posts/effective-cpp/ch08-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/</link>
      <pubDate>Thu, 01 Feb 2024 21:14:41 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-cpp/ch08-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/</guid>
      <description>49：了解new-handler的行为 new申请内存失败会抛出bad alloc的异常，此前会调用一个错误处理函数，此函数由std::set_</description>
      <content:encoded><![CDATA[<h1 id="49了解new-handler的行为">49：了解new-handler的行为</h1>
<ul>
<li><code>new</code>申请内存失败会抛出<code>bad alloc</code>的异常，此前会调用一个错误处理函数，此函数由<code>std::set_new_handler()</code>指定
<ul>
<li><code>set::set_new_handler()</code>
<ul>
<li>接受一个错误处理函数，返回旧的错误处理函数</li>
<li><code>throw</code>表示可能抛出的异常类型，参数为空表示不抛出任何异常</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">new_handler</span><span class="p">)();</span> <span class="c1">// 无形参，返回值为void的函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">new_handler</span> <span class="nf">set_new_handler</span><span class="p">(</span><span class="n">new_handler</span> <span class="n">f</span><span class="p">)</span> <span class="k">throw</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>当new申请不到足够的内存时，会不断调用错误处理函数f，因此错误处理函数应该进行下面的处理之一：
<ul>
<li>提供更多可用的内存</li>
<li>向<code>set_new_handler</code>中传入一个新的错误处理函数</li>
<li><code>set_new_handler</code>函数中传入一个空指针，因此内存分配失败时不进行处理，直接抛出异常</li>
<li>抛出<code>bad_alloc</code>的异常</li>
<li>不返回：调用<code>std::abort</code>或<code>std::exit</code>
<ul>
<li><code>abort</code>会设置程序非正常退出</li>
<li><code>exit</code>会设置程序正常退出，当存在未处理异常时，会调用<code>terminate</code>，内部回调<code>set::set_terminate</code>设置的回调函数，默认会调用<code>abort</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>类型相关错误处理
<ul>
<li>为不同的类分配对象时，使用不同的错误处理函数</li>
<li>重载<code>set_new_handler</code>和<code>operator new</code>，重载为static成员</li>
<li>可以写成模板
<ul>
<li>此处的模板参数<code>T</code>并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，使得模板机制为每个派生类具现化出一份对应的<code>currentHandler</code></li>
<li>这个做法用到了所谓的 CRTP（curious recurring template pattern，奇异递归模板模式），也常被用于静态多态</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">NewHandlerSupport</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">set_new_handler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">NewHandlerSupport</span><span class="p">()</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">set_new_handler</span><span class="p">(</span><span class="n">currentHandler</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">NewHandlerSupport</span><span class="p">(</span><span class="k">const</span> <span class="n">NewHandlerSupport</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 阻止拷贝构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">NewHandlerSupport</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NewHandlerSupport</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 阻止拷贝复制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">currentHandler</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">NewHandlerSupport</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">currentHandler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">NewHandlerSupport</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">set_new_handler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">new_handler</span> <span class="n">oldHandler</span> <span class="o">=</span> <span class="n">currentHandler</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">currentHandler</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">oldHandler</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="n">NewHandlerSupport</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NewHandlerSupport</span> <span class="nf">h</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set_new_handler</span><span class="p">(</span><span class="n">currentHandler</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回的函数指针初始化了一个对象h，在退出函数时，执行h的析构过程，即将原来的handle恢复
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Widget</span><span class="o">:</span> <span class="k">public</span> <span class="n">NewHandlerSupport</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>new分配失败后，可能不会抛出异常，而是返回null，这种称为<code>nothrow new</code>
<ul>
<li>例子：<code>new (std::nothrow) int[10];</code></li>
<li><code>nothrow new</code>只能保证内存分配错误时不抛出异常，无法保证对象的构造函数不抛出异常</li>
</ul>
</li>
</ul>
<h1 id="50-了解new和delete的合理替换时机">50： 了解new和delete的合理替换时机</h1>
<ul>
<li>为什么需要自定义<code>operator new</code>
<ul>
<li>检测使用错误：检测多次delete，检测越界</li>
<li>提高效率：手动维护更适合应用场景的存储策略
<ul>
<li>比如针对特定类型，增加分配和归还的速度</li>
<li>比如将相关对象集成到簇中（即尽量分配到一个内存页上）</li>
</ul>
</li>
<li>收集使用的统计信息</li>
<li>其他原因：比如安全性（将申请到的内存初始化为0），字节对齐等</li>
</ul>
</li>
</ul>
<h1 id="51-编写new和delete时需固守常规">51： 编写new和delete时需固守常规</h1>
<ul>
<li>
<p><code>operator new</code>需要无限循环地获取资源，如果没能获取则调用&quot;new handler&quot;，不存在&quot;new handler&quot;时应该抛出异常；</p>
</li>
<li>
<p><code>operator new</code>应该处理<code>size == 0</code>的情况；</p>
</li>
<li>
<p><code>operator delete</code>应该兼容空指针；</p>
</li>
<li>
<p><code>operator new/delete</code>作为成员函数应该处理<code>size &gt; sizeof(Base)</code>的情况（因为继承的存在）。</p>
</li>
<li>
<p>外部（非成员函数的）<code>operator new</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// size=0时，返回合法的指针就说明成功分配了内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 申请失败，获得new handler，多线程需要加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">new_handler</span> <span class="n">h</span> <span class="o">=</span> <span class="n">set_new_handler</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">set_new_handler</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// auto h = get_new_handler(); // C++11方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">)();</span> <span class="c1">// new-handler应该实现item49中描述的五种行为之一，否则，此处陷入死循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="k">throw</span> <span class="n">bad_alloc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>成员<code>operator new</code></p>
<ul>
<li>如果<code>operator new</code>是针对基类的，也就是说<code>operator new</code>是针对大小为<code>sizeof(Base)</code>的内存进行优化的</li>
<li>一般来说派生类不应该使用基类的<code>operator new</code>，因为派生类对象大小与基类对象大小一般不同</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="n">Base</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Base</span><span class="p">))</span> <span class="c1">// sizeof(Base)永远不会为0（至少为1），因为空对象至少会插入一个char
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="c1">// 使用全局的operator new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>operator new[]</code>与<code>operator new</code>有相同的参数和返回值，只需要分配一块原始内存</li>
</ul>
</li>
<li>
<p><code>delete</code></p>
<ul>
<li>delete</li>
<li>惯例：delete一个空指针是安全的</li>
</ul>
</li>
<li>
<p>外部<code>operator delete</code></p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">rawMemory</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rawMemory</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 释放 rawMemory 所指的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>成员<code>operator delete</code>
<ul>
<li>如果基类的析构函数不是虚函数，则size大小为静态类型的大小；
<ul>
<li>比如<code>Base* p = new Derived; delete p;</code>中，很可能派生类大小大于基类大小，因此存在内存泄露</li>
</ul>
</li>
<li>否则size为动态类型的大小</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Base</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">rawMemory</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rawMemory</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Base</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">rawMemory</span><span class="p">);</span>    <span class="c1">// 转交给标准的 operator delete 进行处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 释放 rawMemory 所指的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h1 id="52-写了placement-new也要写palcement-delete">52： 写了<code>placement new</code>也要写`palcement delete</h1>
<ul>
<li><code>placement new</code>：广义上指拥有额外参数的<code>operator new</code></li>
<li>背景：
<ul>
<li>在使用new创建对象时，往往进行了两个函数的调用：一个是<code>operator new</code>，进行内存分配；一个是对象的构造函数</li>
<li>如果构造失败，此时对象没有被创建，对象无法被析构，且此时还没有拿到分配内存的地址</li>
<li>因此需要运行时系统进行delete，运行时系统需要知道使用的是哪一种<code>operator new</code>，因此调用对应的<code>operator delete</code>
<ul>
<li>如果没有对应的<code>operator delete</code>函数，则运行时系统什么都不做，导致内存泄露</li>
</ul>
</li>
</ul>
</li>
<li>当定义了<code>placement new</code>时，同时也要定义对应的<code>placement delete</code>
<ul>
<li>用户直接调用<code>delete</code>时，运行时系统不会将其解释为<code>placement delete</code>，因此还需要定义一个正常的delete</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">log</span><span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">log</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">)</span> <span class="k">throw</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>名称隐藏：类中的名称会隐藏类外的名称，子类的名称会隐藏父类的名称
<ul>
<li>三种全局new
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="nf">operator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">);</span>           <span class="c1">// normal new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">operator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>                 <span class="c1">// placement new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">operator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">nothrow_t</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">// nothrow new
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
</li>
<li>最佳实践：
<ul>
<li>将全局版本new在一个基类中进行重载，内部调用全局new进行实现</li>
<li>然后在自定义类Widget中，public继承，并使用using声明使得三种new和三种delete对Widget可见，因此同时Widget可以定义自己版本的<code>placement new</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StandardNewDeleteForms</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// normal new/delete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pMemory</span><span class="p">)</span> <span class="k">throw</span><span class="p">()</span> <span class="p">{</span> <span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">pMemory</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// placement new/delete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="k">throw</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pMemory</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="k">throw</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">pMemory</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// nothrow new/delete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">nothrow_t</span><span class="o">&amp;</span> <span class="n">nt</span><span class="p">)</span> <span class="k">throw</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">nt</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pMemory</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">nothrow_t</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">throw</span><span class="p">()</span> <span class="p">{</span> <span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">pMemory</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="o">:</span> <span class="k">public</span> <span class="n">StandardNewDeleteForms</span> <span class="p">{</span>           
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">StandardNewDeleteForms</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">;</span>         
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">StandardNewDeleteForms</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">   <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">log</span><span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">);</span>   <span class="c1">// 自定义 placement new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pMemory</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">logStream</span><span class="p">)</span> <span class="k">throw</span><span class="p">();</span>            <span class="c1">// 对应的 placement delete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Cpp Notes] Ch07 模板与泛型编程</title>
      <link>https://qinganzhang.github.io/posts/effective-cpp/ch07-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Thu, 01 Feb 2024 21:14:25 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-cpp/ch07-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</guid>
      <description>41： 了解隐式接口与编译期多态 面向对象中的类设计时需要考虑显式接口和运行时多态，而模板编程中需要考虑隐式接口和编译器多态 如果函数的形参是普通</description>
      <content:encoded><![CDATA[<h1 id="41-了解隐式接口与编译期多态">41： 了解隐式接口与编译期多态</h1>
<blockquote>
<p>面向对象中的类设计时需要考虑显式接口和运行时多态，而模板编程中需要考虑隐式接口和编译器多态</p>
</blockquote>
<ul>
<li>如果函数的形参是普通类：
<ul>
<li>普通类的显式接口由函数签名（函数名、形参类型、返回值类型）表征，运行时多态由虚函数实现</li>
<li>在函数进行编译时，就可以知道该普通类有哪些接口</li>
</ul>
</li>
<li>如果函数的形参是模板类型：
<ul>
<li>模板类型的隐式接口由表达式的合法性表征（即该模板类型应该支持函数中形参调用的方法），编译器多态由模板初始化和重载函数的解析实现</li>
<li>在函数进行编译时，无法知道模板类型有哪些接口，因此视为鸭子类型（即传入对象支持函数中调用的方法即可）
<ul>
<li>在编译函数时当然无法确定模板类型，但是当传入实参后，内部如果调用了实参未定义的函数，同样会在编译期报错而非运行期</li>
</ul>
</li>
</ul>
</li>
<li>参考：
<ul>
<li><a href="https://www.zhihu.com/question/423699453">https://www.zhihu.com/question/423699453</a></li>
</ul>
</li>
</ul>
<h1 id="42-了解typename的双重意义">42： 了解<code>typename</code>的双重意义</h1>
<ul>
<li>在模板声明中，使用<code>class</code>与<code>typename</code>完全相同</li>
<li>在模板内部，<code>typename</code>还可以用来显式指明【嵌套从属类型名称】
<ul>
<li>背景：比如编译器无法在模板内部判断<code>T::mem</code>是一个static成员（默认），还是一个类型</li>
<li>嵌套从属类型名称：<code>T::mem</code>是一个依赖于模板参数<code>T</code>的类型</li>
<li>例子：模板内部<code>typename T::age myAge = 25;</code></li>
<li><code>typename</code>还可以用来显式指明【嵌套从属类型名称】，可以出现在模板内部、函数形参列表，但是不可以出现在【类派生列表】和【构造函数中成员初始化列表】中
<ul>
<li>当类型名称过于复杂时，可以使用类型别名</li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://harttle.land/2015/09/09/effective-cpp-42.html">https://harttle.land/2015/09/09/effective-cpp-42.html</a></li>
</ul>
</li>
</ul>
<h1 id="43-使用模板化基类中的成员函数">43： 使用模板化基类中的成员函数</h1>
<ul>
<li>背景：如果基类是一个模板类，派生类进行继承
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Buff</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RedBuff</span><span class="o">:</span> <span class="k">public</span> <span class="n">Buff</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BlueBuff</span><span class="o">:</span> <span class="k">public</span> <span class="n">Buff</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span> <span class="cm">/* 假设有成员函数func() */</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//template &lt;&gt; // 全特化基类
</span></span></span><span class="line"><span class="cl"><span class="c1">//class Container&lt;Buff*&gt; { /* 假设没有成员函数func() */ };
</span></span></span><span class="line"><span class="cl"><span class="c1">// template &lt;typename T=Buff*&gt; // 使用默认模板实参，同全特化基类
</span></span></span><span class="line"><span class="cl"><span class="c1">// class Container&lt;T&gt; { /* 假设没有成员函数func() */ }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PlayerContainer</span><span class="o">:</span> <span class="k">public</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 派生类继承模板化基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// 这里编译报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>对于模板化基类，可能有特化版本，且其中可能有不同的接口</li>
<li>对于派生类而言，也无法确定类型T，因此C++规定派生类不在模板化基类中查找继承而来的接口</li>
</ul>
</li>
<li>解决方法：向编译器承诺所有的特化版本都遵循模板化基类的接口（或者说使用非特化版本的模板化基类中的接口）
<ul>
<li>使用<code>this</code>显式指出访问基类的成员函数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PlayerContainer</span><span class="o">:</span> <span class="k">public</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 派生类继承模板化基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// this指针可以访问所有成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>使用<code>using</code>声明
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PlayerContainer</span><span class="o">:</span> <span class="k">public</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 派生类继承模板化基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">;</span> <span class="c1">// 告诉编译器，func在模板化基类中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>使用作用域运算符<code>::</code>明确指出，不推荐使用，因为如果func是虚函数，使用这种方法不会产生多态
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PlayerContainer</span><span class="o">:</span> <span class="k">public</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 派生类继承模板化基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">func</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// 明确指出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<h1 id="44-将与参数无关的代码抽离模板">44： 将与参数无关的代码抽离模板</h1>
<ul>
<li>背景：代码膨胀
<ul>
<li>模板提供的是编译期多态，不同的类型参数会生成不同的模板</li>
<li>比如一个模板类接受一个类型参数T与一个非类型参数N，大部分成员都使用类型参数T，只有极少部分成员使用非类型参数N</li>
<li>如果使用相同的类型type、但是不同的非类型参数n进行实例化，生成的代码中大部分都相同，只有极少部分不同</li>
</ul>
</li>
<li>抽取公共代码：
<ul>
<li>模板中生成的冗余代码是隐式的，因为模板只有一份，生成不同实例后才可能产生冗余</li>
<li>比如可以将与参数无关的代码（成员函数，数据成员）放入基类中，然后private继承</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://harttle.land/2015/09/12/effective-cpp-44.html">https://harttle.land/2015/09/12/effective-cpp-44.html</a></li>
</ul>
</li>
</ul>
<h1 id="45-运用成员函数模板接受所有兼容类型">45： 运用成员函数模板接受所有兼容类型</h1>
<ul>
<li>背景：假如类型参数T存在继承关系，但是模板实例化后是完全不同的两个类
<ul>
<li>比如有一个继承体系，基类Base，派生类Derived</li>
<li>指向派生类的指针可以转换为指向基类的指针：<code>Base* p = new Derived();</code></li>
<li>但是指向派生类的智能指针无法转换为指向基类的智能指针： <code>shared_ptr&lt;Base*&gt; sp = make_shared&lt;Derived*&gt;(new Derived());</code></li>
</ul>
</li>
<li>重载构造函数
<ul>
<li>接受同一模板的其他实例的构造函数称为通用构造函数</li>
<li>兼容类型检查：将<code>MySmartPtr&lt;U&gt;</code>转换为<code>MySmartPtr&lt;T&gt;</code>，前提是类型U可以转换为类型T</li>
<li>如果没有声明拷贝构造函数，编译器会自己生成一个，而非使用通用构造函数去进行成员模板实例化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MySmartPtr</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">MyShartPtr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">MySmartPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">MySmartPtr</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span><span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{};</span> <span class="c1">// 带类型兼容检查的通用构造函数，可以实现隐式类型转换（因为不带explicit）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">T</span><span class="o">*</span> <span class="nf">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">ptr</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">T</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">MySmartPtr</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="k">new</span> <span class="n">Derived</span><span class="p">());</span> <span class="c1">// 隐式类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">MySmartPtr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">MySmartPtr</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Derived</span><span class="p">());</span> <span class="c1">// T=Base*, U=Derived*
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://harttle.land/2015/09/13/effective-cpp-45.html">https://harttle.land/2015/09/13/effective-cpp-45.html</a></li>
</ul>
</li>
</ul>
<h1 id="46需要类型转换时请将模板定义为非成员函数">46：需要类型转换时请将模板定义为非成员函数</h1>
<ul>
<li>背景：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rational</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">Rational</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rational</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Rational</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">oneHalf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Rational</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">oneHalf</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// Error
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>模板函数的调用过程：
<ul>
<li>首先推导出类型T，将函数进行实例化：此时无法从2推导得出类型T</li>
<li>在调用时，有的参数可能需要隐式类型转换</li>
</ul>
</li>
<li>解决方法：将模板函数定义为类的友元，因此类模板实例化后类型T已知
<ul>
<li>如果仅仅是声明，编译器不会对友元函数进行实例化，因此需要进行定义</li>
<li>定义在类内部的函数是inline的，可以在类外部定义一个辅助函数（也是模板函数，但是不需要隐式类型转换）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Rational</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">Rational</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rational</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rational</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">friend</span> <span class="n">Rational</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rational</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">func</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// 可以推导出类型T，而且不需要进行隐式类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h1 id="47-请使用traits-classes表现类型信息">47： 请使用traits classes表现类型信息</h1>
<blockquote>
<ul>
<li>使用Traits的特点：
<ul>
<li>可以同时支持自定义类型和基础类型</li>
<li>在编译期就获取信息</li>
</ul>
</li>
</ul>
</blockquote>
<p>C++中的Traits类可以在编译期提供类型信息，是通过Traits模板及其特化来实现的
C++标准库中提供了不同的Traits：<code>iterator_traits</code>,<code>char_traits</code>,<code>numeric_limits</code>等（以<code>iterator_traits</code>为例）</p>
<ul>
<li>背景：容器与算法通过迭代器联系在一起，算法中可能需要知道迭代器的类型、迭代器中元素的类型，由此有不同的处理方法
<ul>
<li>比如算法<code>advance</code>可以让一个迭代器移动n步（负数则反向移动）
<ul>
<li>迭代器有五种：其中随机访问迭代器可以直接使用<code>+=</code>操作
<ul>
<li>C++提供了五个类标识迭代器类型：<code>input_iterator_tag</code>，<code>output_iterator_tag</code>，<code>forward_iterator_tag</code>，<code>bidirectional_iterator_tag</code>，<code>random_access_iterator_tag</code></li>
</ul>
</li>
<li>传入的参数也可能是基本类型的指针</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">advance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断迭代器类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">iter</span> <span class="n">is</span> <span class="n">random</span> <span class="n">access</span> <span class="n">iterator</span><span class="p">)</span> <span class="n">iter</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断迭代器中元素类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">value_type</span> <span class="n">is</span> <span class="n">MyVector</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;MyVector&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>分析：
<ul>
<li>如果<code>IterT</code>是类类型，因此可以在类中携带数据成员，表示迭代器类型和元素类型</li>
<li>但是<code>IterT</code>也可能是基本类型的指针类型，无法在其中携带信息</li>
</ul>
</li>
<li>Traits技法：使用Traits可以通过一个模板类间接获取<code>IterT</code>的相关信息
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_iterator_traits</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>Traits是C++中一种编程惯例，允许在编译期得到类型的信息
<ul>
<li>traits是一个用来携带信息的很小的类，需要实现两个部分：
<ul>
<li>traits中的类型可能是用户自定义的类型，
<ul>
<li>自定义类型中需要实现相应的迭代器，对具体的类型信息起一个通用的别名</li>
<li>traits中包装相应的信息</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyVector</span><span class="p">{</span> <span class="c1">// 自定义类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">class</span> <span class="nc">iterator</span><span class="p">{</span> <span class="c1">// 自定义类中的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">my_random_access_iterator_tag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// iterator_traits可以获取迭代器（或指针类型）的元素类型和迭代器类型（指针类型视为随机访问迭代器）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">iterator_traits</span><span class="p">{</span> <span class="c1">// IterT是类类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">IterT</span><span class="o">::</span><span class="n">iterator_category</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">IterT</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>traits中的类型可能是基本数据类型，遵循相同的名称，包装一下相应的信息
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">*&gt;</span><span class="p">{</span> <span class="c1">// 特化版本：IterT是基本类型，IterT是基本类型的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">my_random_access_iterator_tag</span><span class="p">;</span> <span class="c1">// 指针可以使用+=操作，因此视为随机访问迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">IterT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
</li>
<li>使用
<ul>
<li>不好的写法：使用<code>typeid</code>在运行时判断类型
<ul>
<li>但是IterT类型在编译期就可以确定，对象iter的类型需要在运行时确定</li>
<li>更严重的问题：静态类型检查（编译期必须确保所有源码都有效，即使是不会执行的源码） ^826df6
<ul>
<li>比如即使迭代器不是<code>my_random_access_iterator_tag</code>类型，编译期也会进入if语句测试该迭代器是否支持+=运算，不支持的话编译报错</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">advance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="k">typeid</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">&gt;::</span><span class="n">iterator_category</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">my_random_access_iterator_tag</span><span class="p">)</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="n">iter</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>推荐实现方法：根据不同的类型创建不同的重载方法（worker），然后在一个master函数中调用，依据traits类型进行重载调用</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">advance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将IterT中迭代器类型和元素类型萃取出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="k">typename</span> <span class="n">my_iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">&gt;::</span><span class="n">iterator_category</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="k">typename</span> <span class="n">my_iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 错误使用：如果iter是指针类型，则IterT为基本类型，无iterator_category属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// std::cout&lt;&lt;typeid(IterT::iterator_category).name()&lt;&lt;std::endl;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">doAdvance</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="k">typename</span> <span class="n">my_iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">&gt;::</span><span class="n">iterator_category</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 最后默认初始化一个iterator_category的对象，进行重载匹配，调用对应的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 随机访问迭代器版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">doAdvance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">,</span> <span class="n">my_random_access_iterator_tag</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">iter</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 前向迭代器版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">doAdvance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">,</span> <span class="n">my_forward_iterator_tag</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;d must be not less then 0&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">d</span><span class="o">--</span><span class="p">)</span> <span class="o">++</span><span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>测试代码</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// using namespace std;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_random_access_iterator_tag</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// my_random_access_iterator_tag() { std::cout&lt;&lt;&#34;my_random_access_iterator_tag ctor&#34;&lt;&lt;std::endl; }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_forward_iterator_tag</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// my_forward_iterator_tag() {std::cout&lt;&lt;&#34;my_forward_iterator_tag&#34;&lt;&lt;std::endl;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyVector</span><span class="p">{</span> <span class="c1">// 自定义类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">class</span> <span class="nc">iterator</span><span class="p">{</span> <span class="c1">// 自定义类中的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">my_random_access_iterator_tag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// iterator_traits可以获取迭代器（或指针类型）的元素类型和迭代器类型（指针类型视为随机访问迭代器）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 输入：使用类类型的迭代器或指针类型进行实例化
</span></span></span><span class="line"><span class="cl"><span class="c1">// 输出：萃取出元素类型和迭代器类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_iterator_traits</span><span class="p">{</span> <span class="c1">// IterT是类类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">IterT</span><span class="o">::</span><span class="n">iterator_category</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">IterT</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">*&gt;</span><span class="p">{</span> <span class="c1">// 特化版本：IterT是基本类型，IterT是基本类型的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">my_random_access_iterator_tag</span><span class="p">;</span> <span class="c1">// 指针可以使用+=操作，因此视为随机访问迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">IterT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// std双向迭代器版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">doAdvance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">bidirectional_iterator_tag</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">d</span><span class="o">--</span><span class="p">)</span> <span class="o">++</span><span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">while</span><span class="p">(</span><span class="o">++</span><span class="n">d</span><span class="p">)</span> <span class="o">--</span><span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// std随机访问迭代器版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">doAdvance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">random_access_iterator_tag</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">iter</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 自定义随机访问迭代器版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">doAdvance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">,</span> <span class="n">my_random_access_iterator_tag</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">iter</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 自定义前向迭代器版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">doAdvance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">,</span> <span class="n">my_forward_iterator_tag</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;d must be not less then 0&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">d</span><span class="o">--</span><span class="p">)</span> <span class="o">++</span><span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DistT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">myAdvance</span><span class="p">(</span><span class="n">IterT</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="n">DistT</span> <span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将IterT中迭代器类型和元素类型萃取出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="k">typename</span> <span class="n">my_iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">&gt;::</span><span class="n">iterator_category</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="k">typename</span> <span class="n">my_iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 错误使用：如果iter是指针类型，则IterT为基本类型，无iterator_category属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// std::cout&lt;&lt;typeid(IterT::iterator_category).name()&lt;&lt;std::endl;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// std::cout&lt;&lt; (typeid(typename my_iterator_traits&lt;IterT&gt;::iterator_category) == typeid(std::bidirectional_iterator_tag)) &lt;&lt;std::endl;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 不好的写法：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 静态类型检查，即使iter不是随机访问迭代器，也会进入if语句块内进行检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// if( typeid(typename my_iterator_traits&lt;IterT&gt;::iterator_category) == typeid(std::random_access_iterator_tag) )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//     iter += d;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">doAdvance</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="k">typename</span> <span class="n">my_iterator_traits</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">&gt;::</span><span class="n">iterator_category</span><span class="p">());</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 最后默认初始化一个iterator_category的对象，进行重载匹配，调用对应的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">myAdvance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">lst</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">myAdvance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">it</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="48-认识模板元编程">48： 认识模板元编程</h1>
<ul>
<li>模板元编程（template metaprogramming，TMP）：编写模板，执行于编译期，生成具象化的代码
<ul>
<li>优点：可以将很多工作从运行期转移到编译期
<ul>
<li>一些错误可以提前发现</li>
<li>运行时更高效：可执行文件体积小，运行期短，内存需求少</li>
<li>避免了[[ch07-模板与泛型编程#^826df6|静态类型检查]]的问题</li>
</ul>
</li>
<li>缺点：编译时间变长</li>
</ul>
</li>
<li>模板元编程
<ul>
<li>图灵完备</li>
<li>循环由递归实现</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Cpp Notes] Ch06 继承与面向对象设计</title>
      <link>https://qinganzhang.github.io/posts/effective-cpp/ch06-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 01 Feb 2024 21:14:04 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-cpp/ch06-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</guid>
      <description>32：确定你的public继承构造出is-a关系 public继承的意思是，子类是一种特殊的父类（is-a关系） 子类必须涵盖父类每一个特点，必</description>
      <content:encoded><![CDATA[<h1 id="32确定你的public继承构造出is-a关系">32：确定你的public继承构造出is-a关系</h1>
<ul>
<li>public继承的意思是，子类是一种特殊的父类（is-a关系）
<ul>
<li>子类必须涵盖父类每一个特点，必须无条件继承父类所有特性和接口</li>
<li>否则没有is-a关系，不应该使用public继承
<ul>
<li>因为很多时候凭生活经验判断，可能会错误判断为具有is-a关系，但是子类可能没有父类的某个特性</li>
</ul>
</li>
</ul>
</li>
<li>程序设计没有银弹</li>
</ul>
<h1 id="33避免覆盖继承而来的名称">33：避免覆盖继承而来的名称</h1>
<ul>
<li>背景：父类中有多个重载的虚函数（同名），子类只重写了其中一个，会导致子类中父类的其他重载函数不可见
<ul>
<li>根本原因：如果子类重写了父类的重载函数的一部分，在进行名字查找中，可以在相应的静态类型（子类）中查找到名字，但是类型无法匹配</li>
</ul>
</li>
<li>避免方法：
<ul>
<li>对于父类的重载方法，子类要么全部重写，要么一个都不重写
<ul>
<li>使用<code>using</code>声明</li>
</ul>
</li>
<li>使用转交函数（forwarding function）？</li>
</ul>
</li>
</ul>
<h1 id="34区分接口继承与实现继承">34：区分接口继承与实现继承</h1>
<ul>
<li>public继承可以分为<code>函数接口继承</code>和<code>函数实现继承</code>
<ul>
<li>基类中声明纯虚函数，派生类只继承其接口，且派生类需要提供实现
<ul>
<li>从代码层面提醒派生类主动实现其接口，即使纯虚函数在基类中也可以有实现（派生类也需要显式指明需要使用基类中的实现）</li>
</ul>
</li>
<li>基类中声明虚函数，派生类继承其接口和缺省实现</li>
<li>基类中声明普通函数，派生类继承其接口和实现（好的编程习惯是不对子类方法进行重写）</li>
</ul>
</li>
</ul>
<h1 id="35考虑virtual函数以外的其他选择">35：考虑virtual函数以外的其他选择</h1>
<ul>
<li>通常面向多态的做法：
<ul>
<li>将接口设置为virtual的</li>
</ul>
</li>
<li>通过<code>Non-Virtual Interface(NVI)</code>来实现template method模式
<ul>
<li>将接口<code>Func</code>的真正实现函数<code>onFunc</code>设置为private virtual的
<ul>
<li>基类中的private virtual方法，通过public继承到派生类，派生类可以进行重写</li>
</ul>
</li>
<li>将接口<code>Func</code>设置为public non-virtual的，在<code>Func</code>中调用<code>onFunc</code>
<ul>
<li>non-virtual的接口<code>Func</code>就称为virtual <code>onFunc</code>的wrapper</li>
</ul>
</li>
<li>优点：在接口<code>Func</code>中调用<code>onFunc</code>前后，可以前置和后置的工作</li>
<li>缺点：在某些场景的继承体系中，virtual函数必须调用基类的版本，因此virtual函数必须是protected甚至public的，此时无法使用NVI</li>
</ul>
</li>
<li>strategy模式
<ul>
<li>基于<code>Function Pointers</code>的strategy模式
<ul>
<li>直接在构造函数中传入一个函数指针，用于实现多态</li>
<li>进一步的，可以基于C++11的<code>std::function</code>来实现strategy模式，在构造函数中传入一个可调用对象</li>
<li>古典的strategy模式：将函数指针替换为类指针，使用该类中的成员函数</li>
</ul>
</li>
<li>优点：同一种类型可以使用不同的方法进行计算，而且可以在运行期变更使用的函数</li>
<li>缺点：函数指针只能访问public成员，否则只能弱化封装性，将外部函数声明为友元</li>
</ul>
</li>
</ul>
<h1 id="36绝不重写继承而来的non-virtual函数">36：绝不重写继承而来的non-virtual函数</h1>
<ul>
<li>从语法上看
<ul>
<li>虚函数执行的是动态绑定，非虚函数执行的是静态绑定</li>
<li>如果有多态调用的需求，设置为虚函数</li>
</ul>
</li>
<li>从设计上看
<ul>
<li>public继承意味着一种is-a关系，子类是一种特殊的父类，不变性（父类的共性）凌驾于特异性（子类的个性）之上</li>
<li>重写public继承而来的non-virtual表示子类修改了父类的特性，违背了is-a关系，造成了设计上的矛盾</li>
</ul>
</li>
</ul>
<h1 id="37绝不重写继承而来的虚函数的缺省参数值">37：绝不重写继承而来的(虚函数的)缺省参数值</h1>
<ul>
<li>虚函数执行的是动态绑定，但是缺省参数值是静态绑定
<ul>
<li>因此可能执行的是动态类型版本的虚函数，但是缺省参数值是静态类型版本虚函数的，没有使用动态类型版本的缺省参数值，极易引起误会</li>
<li>缺省参数值采用静态绑定是为了提高运行时效率，这样可以在编译期将参数确定，而非得到运行时</li>
</ul>
</li>
<li>解决方法：
<ul>
<li>如果使用虚函数，则采用相同的缺省参数值</li>
<li>使用<code>Non-Virtual Interface(NVI)</code>代替虚函数
<ul>
<li>将接口<code>Func</code>设置为public non-virtual的（因此不期望被重写），并带有缺省参数，因此不管怎么继承，缺省参数值都是相同的</li>
<li>将接口<code>Func</code>的实现逻辑<code>onFunc</code>设置为private virtual的，<code>Func</code>中将缺省参数传递给<code>onFunc</code>，调用动态版本的虚函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="38通过复合构造出has-a关系或根据某物实现出">38：通过复合构造出has-a关系或“根据某物实现出”</h1>
<ul>
<li>复合：一个类作为另一个类的数据成员</li>
<li>当复合发生在应用域内的对象之间时，表现出has-a的关系
<ul>
<li>比如Person类中有一个Address类</li>
</ul>
</li>
<li>当复合发生在实现域内的对象之间时，表现出“根据某物实现出”的关系
<ul>
<li>比如使用List类模拟实现出一个Set类</li>
</ul>
</li>
</ul>
<h1 id="39-明智而审慎地使用private继承">39： 明智而审慎地使用private继承</h1>
<ul>
<li>private继承的特点：
<ul>
<li>如果派生类private继承自基类，则从派生类无法转换到基类</li>
<li>但是如果派生类public继承自基类，则派生类可以slice（切掉）转换为基类</li>
</ul>
</li>
<li>private继承的意义：“根据某物实现出”
<ul>
<li>仅仅是为了让派生类使用基类中的某些方法，派生类与基类没有直接意义上的联系</li>
</ul>
</li>
<li>private继承的使用：当需要进行“根据某物实现出”的时候
<ul>
<li>能用复合，就不要用private：绝大多数private继承的场合都可以使用“public继承+复合”进行代替
<ul>
<li>使用private继承：
<ul>
<li>比如想在Widget的派生类中，不定义OnTick方法，即使使用private继承，在Widget的派生类中仍然可以重新定义OnTick方法（类似NVI中方法）</li>
<li>同时Widget编译时必须依赖Timer</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 使用private继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Timer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">OnTick</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="o">:</span> <span class="k">private</span> <span class="n">Timer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">OnTick</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// override
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Widget的派生类中仍有OnTick方法
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>使用复合：
<ul>
<li>在Widget的派生类中，可以没有OnTick方法（同C++11对成员函数使用<code>final</code>）</li>
<li>可以将WidgetTimer定义移出Widget，从而Widget编译时不需要Timer</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Timer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">OnTick</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">class</span> <span class="nc">WidgetTimer</span><span class="o">:</span> <span class="k">public</span> <span class="n">Timer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">virtual</span> <span class="kt">void</span> <span class="n">OnTick</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="n">WidgetTimer</span> <span class="n">timer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>使用private继承的情况：空白基类最优化（Empty Base Optimization，EBO）</li>
</ul>
</li>
</ul>
<h1 id="40-明智而审慎地使用多重继承">40： 明智而审慎地使用多重继承</h1>
<ul>
<li>多重继承中可能遇到歧义调用，需要指明调用哪个基类中的接口
<ul>
<li>即使同名接口一个在基类中是public的，一个是private的（不会被调用），也会发生歧义</li>
<li>因为C++首先会找到最佳匹配函数，之后才会验证其可用性，如果两个同名的函数匹配程度相同，则发生二义性</li>
</ul>
</li>
<li>遇到菱形继承时，使用虚继承，且尽量少的在虚基类中携带数据</li>
<li>多重继承的使用场景：public继承自某个抽象基类，private继承自某个协助实现的基类</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Cpp Notes] Ch05 实现</title>
      <link>https://qinganzhang.github.io/posts/effective-cpp/ch05-%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 01 Feb 2024 21:13:46 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-cpp/ch05-%E5%AE%9E%E7%8E%B0/</guid>
      <description>26：尽可能延后变量定义式的出现时间 原因一：程序前面部分可能有if判断、异常处理等，可能不会运行到后面部分 原因二：直接构造的效率高于默认构造</description>
      <content:encoded><![CDATA[<h1 id="26尽可能延后变量定义式的出现时间">26：尽可能延后变量定义式的出现时间</h1>
<ul>
<li>原因一：程序前面部分可能有if判断、异常处理等，可能不会运行到后面部分</li>
<li>原因二：直接构造的效率高于默认构造+赋值</li>
<li>原因三：变量可能在循环中使用，变量定义在循环内部而非循环前面，可以避免将变量的作用域扩大；除非对循环部分的性能有要求。</li>
</ul>
<h1 id="27尽量少做转型动作">27：尽量少做转型动作</h1>
<ul>
<li>三种风格的转型：
<ul>
<li>C语言风格：<code>(T)expression</code></li>
<li>函数风格：<code>T(expression)</code></li>
<li>C++风格：
<ul>
<li><code>const_cast&lt;T&gt;(expression)</code>：去除const属性</li>
<li><code>dynamic_cast&lt;T&gt;(exprssion)</code>：将指向为基类的指针转型为指向派生类的指针，可能耗费重大运行成本
<ul>
<li>尽量少使用</li>
</ul>
</li>
<li><code>reinterpret_cast&lt;T&gt;(expression)</code></li>
<li><code>static_cast&lt;T&gt;(expression)</code>：最常用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="28避免返回handles指向对象内部成分">28：避免返回handles指向对象内部成分</h1>
<ul>
<li>handles：引用、指针、迭代器</li>
<li>避免返回指向内部对象的handles，返回一个成员变量的副本
<ul>
<li>增加可封装性</li>
<li>帮助const成员函数的行为像一个const</li>
<li>将发生”dangling handles“的可能性降到最低（当临时对象析构后，也就无法通过handle获取对象内部的成员）</li>
</ul>
</li>
</ul>
<h1 id="29为异常安全而努力是值得的">29：为“异常安全”而努力是值得的</h1>
<ul>
<li>异常安全的含义：当异常被抛出时
<ul>
<li>不泄露资源：使用RAII</li>
<li>不发生数据败坏</li>
</ul>
</li>
<li>异常安全的函数提供三种不同级别的保证：
<ul>
<li>基本承诺：不发生数据败坏，但是不保证程序状态</li>
<li>强烈保证：程序状态不变（即程序回复到”调用函数之前“的状态）
<ul>
<li>通过RAII和调换代码顺序实现</li>
<li>或者通过copy and swap实现：创建副本资源并进行操作，所有操作完成后，使用一个不会抛出异常的swap将副本与当前资源进行交换</li>
</ul>
</li>
<li>不抛掷承诺：总能完成功能，作用域内置类型上的所有操作都提供nothrow承诺</li>
</ul>
</li>
<li>强烈保证有时无法实现</li>
<li>异常安全保证具有木桶效应</li>
</ul>
<h1 id="30透彻了解内联的里里外外">30：透彻了解内联的里里外外</h1>
<blockquote>
<p><code>inline</code>最初只是针对编译器的优化建议，而非强制；是否内联由优化等级所控制，与是否内联无关</p>
</blockquote>
<ul>
<li>声明：
<ul>
<li>隐式声明：将函数定义与类内部（但不是一种好的编程风格）</li>
<li>显示声明：<code>inline</code></li>
</ul>
</li>
<li>内联函数通常被置于头文件中，因为内联大部分情况下时编译期行为</li>
<li><code>inline</code>必须放在函数定义前
<ul>
<li>从实现上看，<code>inline</code>放在函数声明前不起作用</li>
<li>从编程风格看，应该严格区分声明与定义，而且用户不需要、也没有必要知道该函数是否内联</li>
</ul>
</li>
<li><code>inline</code>只是对编译器的一个申请，不是强制命令</li>
</ul>
<h1 id="31将文件间的编译依存关系降到最低">31：将文件间的编译依存关系降到最低</h1>
<blockquote>
<ul>
<li>pimpl idiom（pimpl：pointer to implementation）设计思想：
<ul>
<li>原来main class包含类的具体实现逻辑</li>
<li>现在将main class中具体实现逻辑，放到一个实现类Impl中，在private中添加一个指向Impl的指针</li>
<li>因此main class只是提供接口，实现类Impl负责实现接口，”类的接口与实现分离“</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>背景：即使只是改动类的实现，而不改变类的接口，这样所有包含该类的源码都要重新编译
<ul>
<li>根本原因在于，编译器在编译期必须知道对象的大小，如果不知道类的定义，就无法为对象分配内存</li>
</ul>
</li>
<li>方法一：提供句柄类，用”声明的依存性“替换”定义的依存性“
<ul>
<li>原来：假设1000个文件依赖于Person.h，这1000个文件都要重新编译链接
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Person.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 假设在Person.cpp中，略微修改了std::string Person::name()的实现，1000个文件需要全部重新编译
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>现在：只需要修改PersonImpl的具体实现，重新编译这一个文件即可
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Person.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">PersonImpl</span><span class="p">;</span> <span class="c1">// PersonImpl声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">PersonImpl</span> <span class="o">*</span><span class="n">pImpl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Person.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;Person.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;PersonImpl.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Person</span><span class="o">::</span><span class="n">name</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pImpl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">();</span> <span class="c1">// 调用实现类中同名函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// PersonImpl.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">PersonImpl</span><span class="p">{</span> <span class="c1">// PersonImpl与Person有相同的public函数，且Person的private数据成员移动到了PersonImpl的private部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>    
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// PersonImpl.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;PersonImpl.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">PersonImpl</span><span class="o">::</span><span class="n">name</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">mName</span><span class="p">;}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>方法二：将句柄类定义为抽象类
<ul>
<li>基类中定义一个工厂方法，返回动态类型为派生类，静态类型为基类的指针</li>
<li>因此修改派生类中的方法的实现逻辑，不会影响到基类，”类的接口与实现分离“</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Person.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Person</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">shared</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Person</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Person.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;Person.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;RealPerson.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">std</span><span class="o">::</span><span class="n">shared</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">Person</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">shared</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">RealPerson</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// RealPerson.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">RealPerson</span><span class="o">:</span> <span class="k">public</span> <span class="n">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">RealPerson</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">mName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">RealPerson</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>    
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>参考
<ul>
<li><a href="https://www.zhihu.com/question/52832178/answer/192499529">https://www.zhihu.com/question/52832178/answer/192499529</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Cpp Notes] Ch04 设计与声明</title>
      <link>https://qinganzhang.github.io/posts/effective-cpp/ch04-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Thu, 01 Feb 2024 21:13:35 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-cpp/ch04-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/</guid>
      <description>18：让接口容易被正确使用，不易被误用 函数接口传参，使用者可能理解错误或不小心传错 将函数参数封装为新的类型，比如封装新的年月日类，而非直接传</description>
      <content:encoded><![CDATA[<h1 id="18让接口容易被正确使用不易被误用">18：让接口容易被正确使用，不易被误用</h1>
<ul>
<li>函数接口传参，使用者可能理解错误或不小心传错
<ul>
<li>将函数参数封装为新的类型，比如封装新的年月日类，而非直接传入数字</li>
</ul>
</li>
<li>限制类型内可以进行的操作
<ul>
<li>比如添加const限制，比如item3</li>
</ul>
</li>
<li>尽量使自定义类型和内置类型的行为保持一致</li>
<li>消除使用者的资源管理责任
<ul>
<li>比如直接返回一个智能指针，而非返回一个raw指针</li>
</ul>
</li>
</ul>
<h1 id="19设计class犹如设计type">19：设计class犹如设计type</h1>
<p>设计类时，考虑的问题：</p>
<ul>
<li>如何创建以销毁：如何实现构造函数和析构函数</li>
<li>初始化与赋值的区别：如何实现构造函数和赋值操作符</li>
<li>类对象传值：如何实现拷贝构造函数</li>
<li>成员类型的合法值：在构造函数和赋值操作中进行检查</li>
<li>继承关系的约束：基类的相关虚函数、成员函数是否需要被声明为virtual</li>
<li>是否允许由别的类转换而来：如何写转换构造函数</li>
<li>哪些操作符和函数是合理的</li>
<li>哪些操作符和函数应该拒绝</li>
<li>成员给哪些用户使用：成员的访问控制权限</li>
<li>新类型的未声明接口是什么</li>
<li>是否有必要将类一般化为类模板</li>
<li>这个新类型是否真的需要</li>
</ul>
<h1 id="20传参时尽量传常量引用而非传值">20：传参时，尽量传常量引用而非传值</h1>
<ul>
<li>优点：
<ul>
<li>减少一次对象的复制</li>
<li>避免对象切割（比如形参是基类，实参是派生类），同时实现多态</li>
</ul>
</li>
<li>使用传值的情况：内置类型，STL迭代器，函数对象</li>
</ul>
<h1 id="21函数返回值尽量不要为引用">21：函数返回值尽量不要为引用</h1>
<blockquote>
<ul>
<li>禁止在函数中返回一个指向局部变量的指针或引用</li>
<li>不要在函数中返回一个动态分配的对象</li>
<li>不要在可能多次调用的函数中返回一个局部静态变量</li>
</ul>
</blockquote>
<ul>
<li>错误返回引用的例子：
<ul>
<li>返回栈空间中局部变量的引用：函数返回后，栈上相应对象被销毁，因此未定义</li>
<li><a href="https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/1c97b0c2a188e5fe29a79443c7ac79c2a3eae6ec/4.DesignsAndDeclarations/21.DontTryToReturnAReferenceWhenYouMustReturnAnObject.md#%E4%BC%A0%E9%80%92%E5%A0%86%E4%B8%AD%E7%94%9F%E6%88%90%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8">返回堆空间中局部变量的引用</a>：虽然函数返回后不会释放对象，但是函数返回赋值的变量占有了堆空间的资源，而且极易容易忘记释放（因为一般也基本不会考虑对返回值进行delete），造成内存泄露</li>
<li>返回静态变量的引用：当多次调用该函数返回静态变量的引用时，静态变量只有一个，<a href="https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/1c97b0c2a188e5fe29a79443c7ac79c2a3eae6ec/4.DesignsAndDeclarations/21.DontTryToReturnAReferenceWhenYouMustReturnAnObject.md#%E4%BC%A0%E9%80%92%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8">例子</a></li>
</ul>
</li>
<li>C++11中可以使用移动语义，减少拷贝带来的消耗</li>
</ul>
<h1 id="22将成员变量声明为private">22：将成员变量声明为private</h1>
<ul>
<li>将成员变量声明为public的缺点：
<ul>
<li>缺乏语法一致性：访问public成员变量，可以直接访问或者调用成员函数</li>
<li>对成员变量处理缺少准确控制：将成员变量设置为private的，可以提供setter/getter函数来控制其读写权限</li>
<li>不利于封装：在成员变量发生变化时，可以在相关函数中通知其他变量，从而进行相应修改</li>
</ul>
</li>
</ul>
<h1 id="23宁以non-membernon-friend替换member函数">23：宁以non-member、non-friend替换member函数</h1>
<blockquote>
<p>功能颗粒度较高的函数设置为类外的函数，而非封装为public成员函数</p>
</blockquote>
<ul>
<li>背景：public成员函数可分为两类：
<ul>
<li>功能颗粒度较低的函数：public/protected成员函数，内部直接访问private成员</li>
<li>功能颗粒度较高的函数：public/protected成员函数，内部由若干个public成员函数集成而来</li>
</ul>
</li>
<li>尽量将功能颗粒度较高的函数封装为类外的函数：
<ul>
<li>优化类的封装性：如果封装为public函数，本来希望该函数只是public函数的集成，但是这样没法在代码层面体现出来</li>
<li>允许我们从更多维度组织代码结构，提供更大的包裹弹性：比如将不同public成员函数封装为不同功能的外部函数</li>
<li>优化编译依赖关系：比如不同的public成员函数可以封装为不同功能的外部函数，这些外部函数分别放在不同文件中，但是属于同一个命名空间中；这样使用时，需要哪个功能，就只需要包含该文件即可</li>
</ul>
</li>
</ul>
<h1 id="24若所有参数皆需要类型转换请为此采用non-member函数">24：若所有参数皆需要类型转换，请为此采用non-member函数</h1>
<blockquote>
<p>如果希望运算符的任意操作数可以发生隐式类型转换，则应该将运算符重载为非成员函数（比如友元）</p>
</blockquote>
<ul>
<li>背景：运算符可以重载，重载为成员函数呢，还是重载为非成员函数呢？
<ul>
<li>规定：如果运算符是成员函数，则它的第一个运算对象不会发生隐式类型转换
<ul>
<li>因为编译器根据第一个运算对象的类型，确定调用的运算符是属于哪一类的</li>
<li>比如：<code>z = x * y</code>等价于<code>z = x.operator*(y)</code>，x不会发生隐式类型转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="25考虑写出一个不抛出异常的swap函数">25：考虑写出一个不抛出异常的swap函数</h1>
<ul>
<li>如果Widge是一个类，可以在std命名空间中实现<code>std::swap&lt;T&gt;</code>的Widge全特化版本，同时在Widge中实现类内的swap函数以修改private成员的值
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">){</span> <span class="c1">// member swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span> <span class="c1">// default swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 调用std::swap进行private成员的处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;&gt;</span> <span class="c1">// std::swap特例化版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">swap</span><span class="o">&lt;</span><span class="n">Widge</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>如果Widge是一个类模板
<ul>
<li>不能偏特例化一个函数模板
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// non-member swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">swap</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">Widget</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);}</span> <span class="c1">// 编译报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>但是可以偏特例化一个类模板，添加一个重载版本
<ul>
<li>但是不要在std命名空间中添加新东西</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Widget</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>解决方法：置于一个新的命名空间中
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">WidgetStuff</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Widget</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>因此，如果想使得Widget专属版swap在尽可能多的语境下被调用，需要
<ul>
<li>在Widget中提供一个public swap函数（不可抛出异常），内部调用<code>std::swap</code></li>
<li>同时可能需要同时实现两个版本：
<ul>
<li>Widget所在命名空间WidgetStuff中，实现一个nom-member swap，内部调用<code>Widget::swap</code></li>
<li>如果Widget是一个类而非类模板，在std中特化<code>std::swap</code>，内部调用<code>Widget::swap</code></li>
</ul>
</li>
</ul>
</li>
<li>C++11之后，<code>std::swap</code>改用<code>std::move</code>实现，所以几乎不存在性能缺陷</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Cpp Notes] Ch03 资源管理</title>
      <link>https://qinganzhang.github.io/posts/effective-cpp/ch03-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 01 Feb 2024 21:13:22 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-cpp/ch03-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</guid>
      <description>13：以对象管理资源 资源获取即初始化（RAII）：使用析构函数确保资源被释放 复制时使用移动语义，移交资源的所有权 背景：使用动态内存分配时，很</description>
      <content:encoded><![CDATA[<h1 id="13以对象管理资源">13：以对象管理资源</h1>
<blockquote>
<ul>
<li>资源获取即初始化（RAII）：使用析构函数确保资源被释放</li>
<li>复制时使用移动语义，移交资源的所有权</li>
</ul>
</blockquote>
<ul>
<li>背景：使用动态内存分配时，很容易忘记delete，尤其是程序在中间退出（比如if判断后return）</li>
<li>RAII（Resource Acquisition Is Initialization）资源获取即初始化：
<ul>
<li>资源的有效期与持有资源的对象的生命周期严格绑定（即获取资源的时候要通过构造函数初始化）</li>
<li>对象独占资源</li>
<li>即让编译器在每个退出的分支上，对象都进行析构，从而释放资源</li>
<li>使用模板更加方便</li>
</ul>
</li>
<li>移交所有权
<ul>
<li>背景：如果两个指针同时指向一个资源，会析构两遍；因此RAII类独占资源（类似<code>unique_ptr</code>）</li>
<li>在RAII类中，将拷贝相关的函数设置为<code>=delete</code>，RAII无法进行拷贝</li>
<li>因此只能通过移动构造函数使用<code>std::move</code>进行移交所有权</li>
</ul>
</li>
<li>如何把RAII类作为函数的参数
<ul>
<li>值传递：各位caller，我不要ownership了，请拿走</li>
<li>非const引用传递：拿不拿走都行，提前商量好（不推荐）</li>
<li>const引用传递：可以拿走用一下，但是ownership还是我的</li>
<li>右值引用：同第二条，无法确定caller是否拿走了ownership</li>
</ul>
</li>
<li>C++98与C++11
<ul>
<li>C++98中<code>std::auto_ptr</code>类似于C++11中<code>std::unique_ptr</code>，但是<code>std::unique_ptr</code>不允许所有权被转移</li>
<li>C++98中<code>std::tr1::shared_ptr</code>类似于C++11中<code>std::shared_ptr</code>，<code>weak_ptr</code>只是拥有资源的使用权而非所有权，因此不占用引用计数，可以解决环状引用的问题</li>
</ul>
</li>
<li>梳理：RAII作为一种管理资源的方式（或思想），早期使用<code>auto_ptr</code>作为解决方案，C++11之后使用unique_ptr和move语义作为解决方案</li>
<li>参考：
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/600337719">现代C++学习—— 什么是RAII</a></li>
</ul>
</li>
</ul>
<h1 id="14在资源管理类中小心copying行为">14：在资源管理类中小心copying行为</h1>
<blockquote>
<p>复制RAII对象必须一并处理资源的copy行为</p>
</blockquote>
<ul>
<li>copy行为的不同情况：
<ul>
<li>大部分情况下，对RAII对象的复制操作本身就不合法</li>
<li>对底层资源使用引用计数法（<code>shared_ptr</code>）</li>
<li>复制底层资源（行为像值，进行深拷贝）</li>
<li>转移资源所有权（<code>unique_ptr</code>）</li>
</ul>
</li>
</ul>
<h1 id="15在资源管理类中提供对原始资源的访问">15：在资源管理类中提供对原始资源的访问</h1>
<ul>
<li>将RAII对象转换为对资源的直接访问
<ul>
<li>通过显示转换：提供一个<code>get()</code>函数返回智能指针内部的原始指针</li>
<li>通过隐式转换
<ul>
<li>像使用原始指针一样使用智能指针，比如智能指针一样可以使用<code>-&gt;</code>访问成员</li>
<li>直接访问原始指针：在RAII类内实现返回原始指针的类型转换运算符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="16成对使用new和delete时要采取相同形式">16：成对使用new和delete时要采取相同形式</h1>
<ul>
<li>new一个对象，使用delete释放；new一个数组，使用<code>delete []</code>进行释放
<ul>
<li><code>delete []</code>表示知道释放的是数组，读取数组元素数量，从而多次调用析构函数</li>
</ul>
</li>
<li>尽量避免对数组使用<code>typedef</code>，此时在delete时很容易出现混淆：用delete还是<code>delete[]</code>，可以的话可以使用<code>std::vector</code>等容器</li>
</ul>
<h1 id="17以独立语句将new的对象置入智能指针">17：以独立语句将new的对象置入智能指针</h1>
<ul>
<li>背景：编译器可能对单一语句中的执行顺序进行重新调整
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">priority</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MyResource</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MyResource</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">MyResource</span><span class="p">),</span> <span class="n">priority</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">该语句的执行顺序可能是：
</span></span></span><span class="line"><span class="cl"><span class="cm">    MyResource* tmp_ptr = new MyResource;
</span></span></span><span class="line"><span class="cl"><span class="cm">    int priority = priority();
</span></span></span><span class="line"><span class="cl"><span class="cm">    std::shared_ptr&lt;MyResource&gt; sp = std::shared_ptr&lt;MyResource&gt;(tmp_ptr);
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>如果<code>int priority = priority();</code>执行失败，则<code>tmp_ptr</code>指向的临时资源无法被释放，发生内存泄漏</li>
<li>根本原因是：资源被创建和资源被转换成资源管理对象有时间差，中间可能有干扰</li>
</ul>
</li>
<li>解决方法：以独立语句将new的对象置于智能指针中，因为编译器无法对跨语句的操作进行调整
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MyResource</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="n">MyResource</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">priority</span><span class="p">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Cpp Notes] Ch02 构造、析构、赋值运算</title>
      <link>https://qinganzhang.github.io/posts/effective-cpp/ch02-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</link>
      <pubDate>Thu, 01 Feb 2024 21:12:53 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-cpp/ch02-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/</guid>
      <description>05：了解C++默默编写并调用了哪些函数 如果没有自定义相应拷贝控制成员，而且需要使用该拷贝控制成员，则编译器进行合成 有时编译器不会进行合成，</description>
      <content:encoded><![CDATA[<h1 id="05了解c默默编写并调用了哪些函数">05：了解C++默默编写并调用了哪些函数</h1>
<blockquote>
<ul>
<li>如果没有自定义相应拷贝控制成员，而且需要使用该拷贝控制成员，则编译器进行合成</li>
<li>有时编译器不会进行合成，因为一些操作非法</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="n">MyClass</span> <span class="n">m1</span><span class="p">;</span> <span class="c1">// 生成默认构造函数和析构函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">MyClass</span> <span class="nf">m2</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span> <span class="c1">// 生成复制构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">m2</span> <span class="o">=</span> <span class="n">m1</span><span class="p">;</span> <span class="c1">// 生成赋值构造运算符
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>默认构造函数和析构函数
<ul>
<li>作用：调用{基类和non-static成员变量}的构造函数和析构函数</li>
<li>当自定义构造函数后，编译器就不会自动生成构造函数</li>
<li>生成的析构函数是non-virtual的，除非基类的析构函数是virtual的</li>
</ul>
</li>
<li>复制构造函数</li>
<li>赋值构造运算符
<ul>
<li>自动生成赋值构造运算符的条件是，相关操作必须合法
<ul>
<li>比如成员变量是const或引用，则不能进行赋值</li>
<li>比如基类中赋值构造运算符是private的，则派生类中无法调用父类相应的赋值构造运算符对父类成员进行赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="06若不想使用编译器自动生成的函数就该明确拒绝">06：若不想使用编译器自动生成的函数，就该明确拒绝</h1>
<blockquote>
<p>在声明中将拷贝控制成员标记为<code>=delete</code>，将不会自动生成该拷贝控制成员</p>
</blockquote>
<ul>
<li>背景：有时不希望类具有拷贝等行为（语义要求）</li>
<li>三种方法：将不需要自动生成的拷贝控制成员
<ul>
<li>在private中进行定义
<ul>
<li>虽然类外部无法访问，但不是绝对安全，可以在成员函数和友元中使用</li>
<li>写为空函数体，使其在链接过程中报错</li>
</ul>
</li>
<li>在基类中声明为private
<ul>
<li>这样即使在成员函数和友元中使用相应拷贝控制成员，也会因为无法拷贝控制相应基类成员，从而将报错从链接期提前到编译期</li>
</ul>
</li>
<li>在声明中标记为<code>=delete</code></li>
</ul>
</li>
</ul>
<h1 id="07为多态基类声明virtual析构函数">07：为多态基类声明virtual析构函数</h1>
<blockquote>
<p>声明多态性质的基类的析构函数为virtual的</p>
</blockquote>
<ul>
<li>背景：当<code>delete</code>一个指向派生类的基类指针时，只会调用non-virtual的基类析构函数，派生类中成员无法释放</li>
<li>只有当类中至少包含一个除析构函数外的virtual函数时（多态性质），才将析构函数声明为virtual的
<ul>
<li>为了保持可移植性</li>
<li>如果该类不包含virtual函数，则通常该类不会作为基类</li>
</ul>
</li>
<li>将基类析构函数声明为pure virtual函数，从而将基类构造为抽象基类（避免了考虑将其他哪个函数声明为pure virtual函数）</li>
<li>所有的STL容器都不包含virtual析构函数，因此不要将STL容器作为基类
<ul>
<li>因为STL容器设计不是用来作为基类，不带有多态语义要求，只有多态性质的基类才需要声明一个virtual析构函数</li>
<li>不是所有基类都带有多态性质</li>
</ul>
</li>
</ul>
<h1 id="08别让异常逃离析构函数">08：别让异常逃离析构函数</h1>
<blockquote>
<ul>
<li>析构函数不要抛出异常，但是析构函数中可以使用try catch进行异常处理</li>
</ul>
</blockquote>
<ul>
<li>C++11中，默认将析构函数声明为<code>noexcept</code>，防止在析构函数中抛出异常
<ul>
<li><code>try</code>语句块中抛出异常时，会将作用域中对象依次调用析构函数，然后进入catch语句块中
<ul>
<li>如果此时调用的析构函数中继续报错，则core dumped</li>
</ul>
</li>
</ul>
</li>
<li>可以在析构函数中使用try catch捕获异常，或者<a href="https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/master/2.ConstructorsDestructorsAndAssignmentOperation/08.PreventExceptionsFromLeavingDestructors.md#%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E8%AE%A9%E4%BD%BF%E7%94%A8%E8%80%85%E6%9C%89%E6%9C%BA%E4%BC%9A%E5%AF%B9%E5%BC%82%E5%B8%B8%E5%81%9A%E5%87%BA%E5%8F%8D%E5%BA%94">重新设计接口</a>，使得防止抛出异常的函数在析构函数中被调用</li>
</ul>
<h1 id="09绝不在构造和析构过程中调用virtual函数">09：绝不在构造和析构过程中调用<code>virtual</code>函数</h1>
<blockquote>
<p>不要再构造/析构函数（及其调用的函数中）中调用virtual函数，因为这样虚函数不会呈现多态</p>
</blockquote>
<ul>
<li>当派生类中的基类部分被构造时，其调用的虚函数只会调用基类中的版本，不会调用派生类中的版本，即不会呈现多态
<ul>
<li>从安全性角度看，因为此时派生类部分还未构造，使用派生类的虚函数版本可能产生未定义的行为，所以C++规定使用基类的版本</li>
<li>从原理角度看，在构造基类部分时，对象的类型实际上是基类类型</li>
</ul>
</li>
<li>当派生类中的基类部分被析构时，同样不会呈现多态
<ul>
<li>从安全性角度看，此时派生类部分已经析构，调用派生类的虚函数版本产生未定义的行为</li>
<li>从原理角度看，此时对象为基类类型</li>
</ul>
</li>
<li>构造函数/析构函数内调用的函数，也要保证其中不调用虚函数</li>
</ul>
<h1 id="10令operator返回一个reference-to-this">10：令<code>operator=</code>返回一个<code>reference to *this</code></h1>
<blockquote>
<p>令赋值运算符返回一个<code>*this</code>的引用</p>
</blockquote>
<h1 id="11在operator中处理自我赋值">11：在<code>operator=</code>中处理自我赋值</h1>
<blockquote>
<p>进行重新排列赋值或者copy and swap</p>
</blockquote>
<ul>
<li>背景：有时可能很隐蔽的进行了自赋值的操作，特别是类管理资源时，很可能被意外delete掉</li>
<li>进行重新排列赋值：先保存当前资源副本，然后new，最后delete原来的资源；可以保证异常安全性，而且identity test没有必要
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">MyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Resource</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">MyResource</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyResource</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Resource</span><span class="p">();</span> <span class="c1">// 如果new失败，则当前资源不会被释放 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span> <span class="c1">// new成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>copy and swap</li>
</ul>
<h1 id="12复制对象时勿忘记其每一个成分">12：复制对象时勿忘记其每一个成分</h1>
<ul>
<li>派生类复制时，不要忘记将基类部分也复制</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span><span class="o">:</span> <span class="n">base_id</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span> <span class="n">base_id</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">base_id</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Base</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">base_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">base_id</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">base_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">string</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">id</span><span class="p">),</span> <span class="n">myname</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="p">(</span><span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">myname</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">myname</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// 将派生类直接赋值给基类，派生类被切掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Derived</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">Base</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">// 调用基类operator=
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">myname</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">myname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">myname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    
    <item>
      <title>[Effective Cpp Notes] Ch01 让自己习惯C&#43;&#43;</title>
      <link>https://qinganzhang.github.io/posts/effective-cpp/ch01-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc&#43;&#43;/</link>
      <pubDate>Thu, 01 Feb 2024 21:10:56 +0800</pubDate>
      
      <guid>https://qinganzhang.github.io/posts/effective-cpp/ch01-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFc&#43;&#43;/</guid>
      <description>01 视C++为一个语言联邦 C++高效编程守则视状况而变化，取决于你使用C++的哪一部分 C++支持面向过程、面向对象、面向函数、泛型编程、元编程</description>
      <content:encoded><![CDATA[<h1 id="01-视c为一个语言联邦">01 视C++为一个语言联邦</h1>
<blockquote>
<p>C++高效编程守则视状况而变化，取决于你使用C++的哪一部分</p>
</blockquote>
<ul>
<li>C++支持面向过程、面向对象、面向函数、泛型编程、元编程，因此可以将C++视为一个由相关语言组成的联邦而非单一语言（各个方面的编程范式不太相同）：
<ul>
<li>C：有指针、数组，没有模板、重载和异常</li>
<li>Object-Oriented C++：类、封装、继承、多态、虚函数</li>
<li>Template C++：模板元编程</li>
<li>STL：</li>
</ul>
</li>
<li>编程范式（或者编程技巧）的区别：
<ul>
<li>对于C而言，传值比传引用更加高效</li>
<li>对于Object-Oriented C++而言，常量引用传递往往更好（可以传递左值、右值）</li>
<li>对于Template C++而言，模板往往不知道处理的对象是什么类型</li>
<li>对于STL而言，迭代器和函数对象是基于C的指针，所以此时应该选择值传递</li>
</ul>
</li>
</ul>
<h1 id="02尽量以constenuminline替换define">02：尽量以<code>const,enum,inline</code>替换<code>#define</code></h1>
<blockquote>
<ul>
<li>尽量使用编译器操作代替预处理器操作：
<ul>
<li>对于常量，尽量使用<code>const</code>对象或<code>enum</code>来替换<code>#define</code></li>
<li>对于形似函数的宏，最好改用<code>inline</code>替换<code>#define</code></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>尽量使用编译器操作代替预处理器操作
<ul>
<li><code>#define</code>是在预处理阶段进行替换，宏的名字不会出现在符号表中。</li>
</ul>
</li>
<li>对于常量，尽量使用<code>const</code>对象或<code>enum</code>来替换<code>#define</code>
<ul>
<li>两个典型场景：
<ul>
<li>定义常量指针</li>
<li>定义class专属常量，比如<code>const static</code>成员
<ul>
<li>类内static成员可以进行【声明时初始化】，虽然不是定义（即没有分配空间），但是只要不取地址，此时也可以使用该变量</li>
<li>如果类内static成员进行【声明时初始化】，而且需要取地址，则需要在类外对变量进行定义
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">Widget</span><span class="o">::</span><span class="n">val</span><span class="p">;</span> <span class="c1">// 由于const，无法进行赋值
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对于形似函数的宏，最好改用<code>inline</code>替换<code>#define</code>
<ul>
<li>虽然使用宏本身少了一次调用过程，但是有时即使加上括号，结果也不正确
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">CALL_WITH_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>      <span class="c1">// a 累加了一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">CALL_WITH_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// a 累加了两次
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>使用<code>inline</code>可以保证正确性，并且可以使用模板</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/master/1.AccustomingYourselfToCpp/02.PreferConstsEnumsInlinesToDefine.md">https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/master/1.AccustomingYourselfToCpp/02.PreferConstsEnumsInlinesToDefine.md</a></li>
</ul>
</li>
</ul>
<h1 id="03尽可能使用const">03：尽可能使用<code>const</code></h1>
<blockquote>
<ul>
<li>声明为<code>const</code>可以帮助编译器检测错误</li>
<li><code>const</code>成员函数默认遵循<code>bitwise constness</code>，但是编写程序时应该使用<code>logical constness</code>，必要时将成员声明为<code>mutable</code>来保证可以修改</li>
<li><code>const</code>和<code>non-const</code>成员函数有实质等价的实现，令<code>non-const</code>版本调用<code>const</code>版本可以避免代码重复</li>
</ul>
</blockquote>
<ul>
<li>const和指针：顶层const与底层const</li>
<li>const和STL：const迭代器是顶层const，<code>const_iterator</code>是底层const</li>
<li>const和函数：
<ul>
<li>函数返回值和函数形参尽量声明为const的，有助于编译器定位相关报错
<ul>
<li>比如将比较运算符<code>==</code>误写为赋值运算符<code>=</code></li>
</ul>
</li>
<li>成员函数声明为const的
<ul>
<li>使得成员函数更容易被理解（这个成员函数不能修改成员），而且此时形参往往也是const引用</li>
<li>一个const成员函数，一个non-const成员函数，可以进行重载
<ul>
<li>const对象调用const版本成员函数，普通对象调用non-const版本成员函数</li>
<li>常量性转移
<ul>
<li>背景：const成员函数与non-const成员函数中间逻辑相同，可能存在大量的重复代码，一个方法是将重复的代码写成函数放在private中</li>
<li>更好的办法是，让non-const成员函数调用const成员函数（如果反过来，const成员函数调用non-const成员函数，不能保证对象不被修改）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TextBlock</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">pos</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>        
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&amp;&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TextBlock</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="c1">// *this是TextBlock&amp;, 强转加上const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="c1">// const TextBlock&amp;调用operator[]，否则TextBlock&amp;调用operator[]一直重复调用自己
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
</li>
<li><code>mutable</code>：使得成员变量即使在const成员函数中也可以被修改，主要是为了实现<code>logical constness</code>
<ul>
<li>背景：<code>bitwise constness</code>与<code>logical constness</code>
<ul>
<li><code>bitwise constness</code>：成员函数不应该修改任何<code>non-static</code>成员变量（const成员函数的默认方式）
<ul>
<li>编译器容易实现，只需要寻找成员变量的赋值操作</li>
</ul>
</li>
<li><code>logical constness</code>：允许成员函数修改成员变量，对于使用者而言，可以体现出constness即可
<ul>
<li>比如一个指针成员变量，按照<code>bitwise constness</code>，限定指针为顶层的，但是却无法保证不修改所指对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>参考
<ul>
<li><a href="https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/master/1.AccustomingYourselfToCpp/03.UseConstWheneverPossible.md">https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/master/1.AccustomingYourselfToCpp/03.UseConstWheneverPossible.md</a></li>
</ul>
</li>
</ul>
<h1 id="04确定对象被使用前已被初始化">04：确定对象被使用前已被初始化</h1>
<blockquote>
<ul>
<li>内置类型对象一定要进行手动初始化</li>
<li>构造函数中最好使用初始化列表对成员变量进行初始化，而非在函数体中进行赋值</li>
<li>为了避免跨编译单元的初始化顺序问题，尽量以local static对象代替non-local static对象</li>
</ul>
</blockquote>
<ul>
<li>内置类型变量的初始化
<ul>
<li>内置类型变量（即使是类中的内置类型成员变量）是否会初始化，取决于其在内存中的位置（堆空间？栈空间？）</li>
</ul>
</li>
<li>自定义类对象的初始化
<ul>
<li>初始化与赋值的区别
<ul>
<li>赋值：比如在构造函数函数体中进行“赋值”
<ul>
<li>非内置类型的成员变量的初始化发生在进入构造函数之前，每个成员变量的default构造函数被自动调用，构造了两次（默认构造一次，复制构造一次）</li>
<li>但是内置类型的成员变量不会自动初始化，此时无区别</li>
</ul>
</li>
<li>初始化：比如在构造函数初始化列表中
<ul>
<li>此时相当于只调用了一次成员变量的构造函数（赋值构造）</li>
<li>如果是const或者是引用，此时不能被赋值，只能进行初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>变量初始化顺序
<ul>
<li>在初始化列表中，编译器按照父类-&gt;子类的顺序进行成员变量初始化，但尽量还是与成员声明顺序保持一致</li>
<li><a href="https://github.com/XiaotaoGuo/Effective-Cpp-Reading-Note/blob/master/1.AccustomingYourselfToCpp/04.MakeSureThatObjectsAreInitilizedBeforeTheyAreUsed.md#%E4%B8%8D%E5%90%8C%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E5%86%85%E5%AE%9A%E4%B9%89%E7%9A%84-non-local-static-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F">不同编译单元内定义的non-local static对象的初始化顺序</a>
<ul>
<li><a href="obsidian://booknote?type=annotation&amp;book=Effective%20C++-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Effective%20C++.pdf&amp;id=04a94357-a1e7-7b4a-a173-c2c4f30846d0&amp;page=61&amp;rect=114.240,403.600,300.642,413.680">一些情况下</a>，不同编译单元内的non-local static对象的初始化顺序有要求，但是C++没有明确定义（比如要求先FileSystem中tfs初始化，后Diectory中tdr初始化）</li>
<li>将每个 non-local static 对象移至自己的专属函数内（变成 local static 对象）</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
