<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GPU架构发展、兼容性和编译 | Paul's Blog</title>
<meta name=keywords content="cuda"><meta name=description content="CUDA编译链和兼容性 兼容性 CPU与GPU的区别 CPU只有少量的计算核心，有更多晶体管用于数据缓存和流程控制， GPU有大量计算能力较弱的计算"><meta name=author content="Paul"><link rel=canonical href=https://qinganzhang.github.io/posts/cuda-learning-notes/gpu%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E7%BC%96%E8%AF%91/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://qinganzhang.github.io/favicon.ico><link rel=apple-touch-icon href=https://qinganzhang.github.io/apple-touch-icon.png><meta name=twitter:title content="GPU架构发展、兼容性和编译 | Paul's Blog"><meta name=twitter:description content="CUDA编译链和兼容性 兼容性 CPU与GPU的区别 CPU只有少量的计算核心，有更多晶体管用于数据缓存和流程控制， GPU有大量计算能力较弱的计算"><meta property="og:title" content="GPU架构发展、兼容性和编译 | Paul's Blog"><meta property="og:description" content="CUDA编译链和兼容性 兼容性 CPU与GPU的区别 CPU只有少量的计算核心，有更多晶体管用于数据缓存和流程控制， GPU有大量计算能力较弱的计算"><meta property="og:type" content="article"><meta property="og:url" content="https://qinganzhang.github.io/posts/cuda-learning-notes/gpu%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E7%BC%96%E8%AF%91/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-01T22:00:30+08:00"><meta property="article:modified_time" content="2024-02-01T22:00:30+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://qinganzhang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"GPU架构发展、兼容性和编译","item":"https://qinganzhang.github.io/posts/cuda-learning-notes/gpu%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E7%BC%96%E8%AF%91/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GPU架构发展、兼容性和编译 | Paul's Blog","name":"GPU架构发展、兼容性和编译","description":"CUDA编译链和兼容性 兼容性 CPU与GPU的区别 CPU只有少量的计算核心，有更多晶体管用于数据缓存和流程控制， GPU有大量计算能力较弱的计算","keywords":["cuda"],"wordCount":"11734","inLanguage":"en","datePublished":"2024-02-01T22:00:30+08:00","dateModified":"2024-02-01T22:00:30+08:00","author":{"@type":"Person","name":"Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qinganzhang.github.io/posts/cuda-learning-notes/gpu%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E7%BC%96%E8%AF%91/"},"publisher":{"@type":"Organization","name":"Paul's Blog","logo":{"@type":"ImageObject","url":"https://qinganzhang.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://qinganzhang.github.io/ accesskey=h title="Paul's Blog (Alt + H)">Paul's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://qinganzhang.github.io/posts/ title=Posts class=active>Posts</a></li><li><a href=https://qinganzhang.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://qinganzhang.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://qinganzhang.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://qinganzhang.github.io/categories/ title=Categories>Categories</a></li><li><a href=https://qinganzhang.github.io/about/ title=About>About</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qinganzhang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://qinganzhang.github.io/posts/>Post</a></div><h1 class=post-title>GPU架构发展、兼容性和编译</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-02-01</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://qinganzhang.github.io/tags/cuda/>cuda</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>11734 words</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>24 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#cuda%e7%bc%96%e8%af%91%e9%93%be%e5%92%8c%e5%85%bc%e5%ae%b9%e6%80%a7 aria-label=CUDA编译链和兼容性>CUDA编译链和兼容性</a><ul><li><a href=#%e5%85%bc%e5%ae%b9%e6%80%a7 aria-label=兼容性>兼容性</a></li><li><a href=#cuda%e5%bc%80%e5%8f%91%e5%b9%b3%e5%8f%b0 aria-label=CUDA开发平台>CUDA开发平台</a></li><li><a href=#%e7%bc%96%e8%af%91%e7%9b%b8%e5%85%b3 aria-label=编译相关>编译相关</a><ul><li><a href=#%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b aria-label=编译过程>编译过程</a></li><li><a href=#nvcc%e7%bc%96%e8%af%91%e9%80%89%e9%a1%b9 aria-label=nvcc编译选项>nvcc编译选项</a></li></ul></li></ul></li><li><a href=#%e6%9e%b6%e6%9e%84%e5%8f%91%e5%b1%95 aria-label=架构发展>架构发展</a><ul><li><a href=#overview aria-label=Overview>Overview</a></li><li><a href=#tesla aria-label=Tesla>Tesla</a><ul><li><a href=#g80 aria-label=G80>G80</a></li><li><a href=#scoreboarding aria-label=scoreboarding>scoreboarding</a></li></ul></li><li><a href=#fermi aria-label=Fermi>Fermi</a><ul><li><a href=#%e7%89%b9%e7%82%b9 aria-label=特点>特点</a></li><li><a href=#sm aria-label=SM>SM</a></li><li><a href=#isa aria-label=ISA>ISA</a></li><li><a href=#gigathread aria-label=GigaThread>GigaThread</a></li></ul></li><li><a href=#kepler aria-label=Kepler>Kepler</a><ul><li><a href=#smx aria-label=SMX>SMX</a></li><li><a href=#dynamic-parallelism aria-label="Dynamic Parallelism">Dynamic Parallelism</a></li><li><a href=#hyper-q aria-label=Hyper-Q>Hyper-Q</a></li><li><a href=#grid-management-unit aria-label="Grid Management Unit">Grid Management Unit</a></li><li><a href=#nvidia-gpudirect aria-label="NVIDIA GPUDirect">NVIDIA GPUDirect</a></li></ul></li><li><a href=#maxwell aria-label=Maxwell>Maxwell</a><ul><li><a href=#%e7%89%b9%e7%82%b9-1 aria-label=特点>特点</a></li><li><a href=#smm aria-label=SMM>SMM</a></li></ul></li><li><a href=#pascal aria-label=Pascal>Pascal</a><ul><li><a href=#%e6%9e%b6%e6%9e%84 aria-label=架构>架构</a></li><li><a href=#unified-memory aria-label="Unified Memory">Unified Memory</a></li><li><a href=#compute-preemption aria-label="Compute preemption">Compute preemption</a></li><li><a href=#%e7%a1%ac%e4%bb%b6%e7%bb%93%e6%9e%84 aria-label=硬件结构>硬件结构</a></li></ul></li><li><a href=#volta aria-label=Volta>Volta</a><ul><li><a href=#sm%e5%92%8ctensor-core aria-label="SM和Tensor Core">SM和Tensor Core</a></li><li><a href=#independent-thread-scheduling aria-label="Independent Thread Scheduling">Independent Thread Scheduling</a></li><li><a href=#multi-process-servicemps aria-label="Multi-Process Service(MPS)">Multi-Process Service(MPS)</a></li><li><a href=#cooperative-groupscg aria-label="Cooperative Groups(CG)">Cooperative Groups(CG)</a></li></ul></li><li><a href=#turing aria-label=Turing>Turing</a></li><li><a href=#ampere aria-label=Ampere>Ampere</a><ul><li><a href=#sm-1 aria-label=SM>SM</a></li><li><a href=#memory%e6%96%b9%e9%9d%a2%e7%9a%84%e6%94%b9%e8%bf%9b aria-label=memory方面的改进>memory方面的改进</a></li><li><a href=#multi-instance-gpumig aria-label="Multi-Instance GPU(MIG)">Multi-Instance GPU(MIG)</a></li><li><a href=#cuda-advances aria-label="CUDA Advances">CUDA Advances</a></li></ul></li><li><a href=#ada-lovelace aria-label="Ada Lovelace">Ada Lovelace</a></li><li><a href=#hopper aria-label=Hopper>Hopper</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=cuda编译链和兼容性>CUDA编译链和兼容性<a hidden class=anchor aria-hidden=true href=#cuda编译链和兼容性>¶</a></h2><h3 id=兼容性>兼容性<a hidden class=anchor aria-hidden=true href=#兼容性>¶</a></h3><ul><li><p>CPU与GPU的区别</p><ul><li>CPU只有少量的计算核心，有更多晶体管用于数据缓存和流程控制，</li><li>GPU有大量计算能力较弱的计算核心，用于控制和缓存的晶体管较少</li></ul></li><li><p>GPU系列：</p><ul><li>Tesla系列：使用ECC内存，用于科学计算。后来也叫Data Center GPUs。</li><li>Quadro系列：专业级，用于OpenGL、CAD等需要高精度计算的场景。后来也叫Workstation GPUs。</li><li>GeForce系列：消费级，用于游戏和计算，但是没有ECC</li><li>Tegra系列：移动处理器</li><li>Jetson系列：嵌入式</li></ul></li><li><p>GPU架构、计算能力与对应系列</p><ul><li>计算能力（Compute Capability）决定了GPU硬件支持的功能，反映了设备支持的指令集及其他规范，也称SM version，注意GPU计算能力不等价于计算性能<table><thead><tr><th style=text-align:center>架构</th><th style=text-align:center>计算能力Compute Capability</th><th style=text-align:center>发布时间</th><th style=text-align:center>Tesla系列</th><th style=text-align:center>Quadro系列</th><th style=text-align:center>GeForce系列</th><th style=text-align:center>Jetson系列</th></tr></thead><tbody><tr><td style=text-align:center>Tesla</td><td style=text-align:center>X = 1</td><td style=text-align:center>2006</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>Fermi</td><td style=text-align:center>X = 2</td><td style=text-align:center>2010</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>Kepler</td><td style=text-align:center>X = 3</td><td style=text-align:center>2012</td><td style=text-align:center>Kepler K系列</td><td style=text-align:center>Quadro K系列</td><td style=text-align:center>GeForce 600/700系列</td><td style=text-align:center>Tegra K1</td></tr><tr><td style=text-align:center>Maxwell</td><td style=text-align:center>X = 5</td><td style=text-align:center>2014</td><td style=text-align:center>Maxwell M系列</td><td style=text-align:center>Quadro M系列</td><td style=text-align:center>GeForce 900系列</td><td style=text-align:center>Tegra X1</td></tr><tr><td style=text-align:center>Pascal</td><td style=text-align:center>X = 6</td><td style=text-align:center>2016</td><td style=text-align:center>Pascal P系列</td><td style=text-align:center>Quadro P系列</td><td style=text-align:center>GeForce 10系列</td><td style=text-align:center>Tegra X2</td></tr><tr><td style=text-align:center>Volta</td><td style=text-align:center>X = 7</td><td style=text-align:center>2017</td><td style=text-align:center>Tesla V系列</td><td style=text-align:center>-</td><td style=text-align:center>TITAN V</td><td style=text-align:center>AGX Xavier</td></tr><tr><td style=text-align:center>Turing</td><td style=text-align:center>X.Y = 7.5</td><td style=text-align:center>2018</td><td style=text-align:center>Tesla T系列</td><td style=text-align:center>Quadro RTX系列</td><td style=text-align:center>GeForce 16系列，GeForce 20系列</td><td style=text-align:center>AGX Xavier</td></tr><tr><td style=text-align:center>Ampere</td><td style=text-align:center>X = 8</td><td style=text-align:center>2020</td><td style=text-align:center>Tesla A系列</td><td style=text-align:center>RTX A系列</td><td style=text-align:center>GeForce 30系列</td><td style=text-align:center></td></tr><tr><td style=text-align:center>Ada Lovelace</td><td style=text-align:center>X.Y = 8.9</td><td style=text-align:center>2022</td><td style=text-align:center>L4、L40</td><td style=text-align:center>RTX Ada系列</td><td style=text-align:center>GeForce 40系列</td><td style=text-align:center></td></tr><tr><td style=text-align:center>Hopper</td><td style=text-align:center>X = 9</td><td style=text-align:center>2022</td><td style=text-align:center>H100</td><td style=text-align:center></td><td style=text-align:center>-</td><td style=text-align:center></td></tr></tbody></table></li></ul></li></ul><h3 id=cuda开发平台>CUDA开发平台<a hidden class=anchor aria-hidden=true href=#cuda开发平台>¶</a></h3><ul><li>CUDA 提供两个编程接口
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-27-15:12:04.png alt=image-20231227151204463 style=zoom:50%><ul><li>CUDA driver API：low-level<ul><li>CUDA (driver) library由NVIDIA driver安装，比如常用的共享库<code>libcuda.so</code>，对应头文件为<code>cuda.h</code>，里面提供的API称为CUDA driver API<ul><li>同时可以看到NVIDIA driver的版本：<code>find / -name libcuda.*</code></li></ul></li><li>NVIDIA driver同时包含了<code>nvidia-smi</code>命令，可以看到NVIDIA driver的版本，以及当前NVIDIA driver支持的最高CUDA版本（向下兼容）</li><li>或者使用函数<code>cudaDriverGetVersion(int* driverVersion)</code></li></ul></li><li>CUDA runtime API：high-level<ul><li>CUDA Runtime library由CUDA Toolkit安装，比如常用的共享库<code>libcudart.so</code>，对应头文件为<code>cuda_runtime.h</code>，里面提供的API称为CUDA runtime API<ul><li><code>cuda_runtime_api.h</code>是纯C版本，<code>cuda_runtime.h</code>是C++版本</li><li>离线安装的CUDA工具包会默认携带与之匹配特定的驱动程序</li></ul></li><li>CUDA Toolkit中同时包含了一些工具比如编译器nvcc，<code>nvcc -V</code>显示的CUDA版本是runtime API版本<ul><li>cuda driver API版本（即驱动支持的最高cuda版本）应该高于cuda runtime API版本（即当前安装的cuda toolkit版本）</li></ul></li><li>或者使用函数<code>cudaRuntimeGetVersion(int *runtimeVersion)</code></li></ul></li></ul></li><li>注意不要将GPU计算能力与CUDA (driver/runtime)版本混淆</li><li>参考<ul><li><a href=https://leimao.github.io/blog/CUDA-Driver-VS-CUDA-Runtime/># CUDA Driver VS CUDA Runtime</a></li><li><a href=https://blog.csdn.net/jslove1997/article/details/113737934># cuda 的driver API 和 runtime API</a></li></ul></li></ul><h3 id=编译相关>编译相关<a hidden class=anchor aria-hidden=true href=#编译相关>¶</a></h3><h4 id=编译过程>编译过程<a hidden class=anchor aria-hidden=true href=#编译过程>¶</a></h4><ul><li><p><a href=https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#the-cuda-compilation-trajectory>编译过程</a>
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-27-23:36:39.png alt=image-20231227233638914 style=zoom:67%></p><ul><li>编译device code<ul><li>首先将预处理之后的C++ code经过CICC compiler编译成PTX code<ul><li>PTX可以视为虚架构的汇编，虚架构体现了应用程序对GPU计算能力的要求，版本尽量低，因此可以适用于更加广泛的GPU架构</li></ul></li><li>再使用ptxas (PTX optimizing assembler)，根据实架构，将PTX code编译成cubin二进制机器码<ul><li>.cubin：CUDA device code binary file (CUBIN) for a single GPU architecture</li></ul></li><li>将PTX code和cubin放到fatbin.c文件中<ul><li>.fatbin：CUDA fat binary file that may contain multiple PTX and CUBIN files</li></ul></li></ul></li><li>编译host code<ul><li>将预处理之后的C++ code，使用cudafe++将host和device部分分离</li><li>分离后的host代码，结合device code部分得到的fatbin.c文件，进行编译<ul><li>在host code看来，device code其实就是一段数据。</li></ul></li></ul></li><li>对每一个.cu文件都执行单独的host code和device code编译</li><li>链接：<ul><li>使用nvlink将所有.o目标文件中的device code重新链接到一个cubin文件中，并通过fatbinary转换为.fatbin.c文件</li><li>将.fatbin.c文件，结合一些其他的文件，编译得到device code最终对应的目标文件</li><li>将host code的目标文件和device code最终的目标文件链接起来，得到最终的可执行文件</li></ul></li></ul></li><li><p>使用</p><ul><li><p>需要选项 <code>-arch=compute_XY</code> 指定一个PTX虚拟架构的计算能力，虚架构版本：<a href=https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#virtual-architecture-feature-list>Virtual Architecture Feature List</a></p><table><thead><tr><th style=text-align:center>Architecture</th><th style=text-align:center>虚架构</th><th style=text-align:center>实架构</th></tr></thead><tbody><tr><td style=text-align:center>Maxwell</td><td style=text-align:center><code>compute_50</code>，<code>compute_52</code>，<code>compute_53</code></td><td style=text-align:center><code>sm_50</code>，<code>sm_52</code>，<code>sm_53</code></td></tr><tr><td style=text-align:center>Pascal</td><td style=text-align:center><code>compute_60</code>，<code>compute_61</code>，<code>compute_62</code></td><td style=text-align:center><code>sm_60</code>，<code>sm_61</code>，<code>sm_62</code></td></tr><tr><td style=text-align:center>Volta</td><td style=text-align:center><code>compute_70</code>，<code>compute_72</code></td><td style=text-align:center><code>sm_70</code>，<code>sm_72</code></td></tr><tr><td style=text-align:center>Turing</td><td style=text-align:center><code>compute_75</code></td><td style=text-align:center><code>sm_75</code></td></tr><tr><td style=text-align:center>Ampere</td><td style=text-align:center><code>compute_80</code>，<code>compute_86</code>，<code>compute_87</code></td><td style=text-align:center><code>sm_80</code>，<code>sm_86</code>，<code>sm_87</code></td></tr><tr><td style=text-align:center>Ada Lovelace</td><td style=text-align:center><code>compute_89</code></td><td style=text-align:center><code>sm_89</code></td></tr><tr><td style=text-align:center>Hopper</td><td style=text-align:center><code>compute_90</code>，<code>compute_90a</code></td><td style=text-align:center><code>sm_90</code>，<code>sm_90a</code></td></tr></tbody></table></li><li><p>需要选项 <code>-code=sm_ZW</code> 指定一个真实架构的计算能力，实架构版本：<a href=https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#gpu-feature-list>GPU Feature List</a></p><ul><li>CUDA二进制兼容性只能保证局限在相同大版本计算能力的架构中</li><li>实架构的计算能力必须大于等于虚架构的计算能力</li></ul></li><li><p>如果希望编译出来的文件能在更多的GPU上运行，可以使用<code>-gencode</code>同时指定多组计算能力，生成多个PTX版本代码，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-gencode arch=compute_35, code=sm_35
</span></span><span class=line><span class=cl>-gencode arch=compute_50, code=sm_50
</span></span><span class=line><span class=cl>-gencode arch=compute_60, code=sm_60
</span></span></code></pre></td></tr></table></div></div><ul><li>此时，编译出来的可执行文件将包含3个二进制版本，在不同架构的GPU中运行时会自动选择对应的二进制版本</li><li><code>-code=</code>可以指定虚架构，此时将进行即时编译，只会包含PTX代码</li></ul></li><li><p>如果在运行期间找不到当前架构的二进制版本代码，则使用即时编译</p><ul><li>即时编译推迟cubin的生成，将PTX代码在runtime内编译成cubin然后执行，因为runtime时已经知道当前运行在哪种GPU架构中，因此可以直接生成</li><li>缺点是增加了程序的启动延迟，但是可以使用编译缓存来缓解</li></ul></li><li><p>默认cuda以whole program compilation mode来编译</p></li></ul></li><li><p>reference and more reading</p><ul><li><a href=https://arnon.dk/matching-sm-architectures-arch-and-gencode-for-various-nvidia-cards/># Matching CUDA arch and CUDA gencode for various NVIDIA architectures</a></li><li><a href=https://zhuanlan.zhihu.com/p/409154399># CUDA 编译与 NVVM IR 笔记</a></li><li><a href=https://zhuanlan.zhihu.com/p/432674688># 银河系CUDA编程指南(2.5)——NVCC与PTX</a></li><li><a href=https://zhuanlan.zhihu.com/p/623756901># NVCC编译流程+中间文件+GDB调试cuda程序初探</a></li><li><a href=https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#>nvcc文档</a></li><li><a href=https://blog.csdn.net/feng__shuai/article/details/111319185># CUDA编译过程</a></li></ul></li></ul><h4 id=nvcc编译选项>nvcc编译选项<a hidden class=anchor aria-hidden=true href=#nvcc编译选项>¶</a></h4><ul><li><code>-g</code>：在host端生成调试信息</li><li><code>-G</code>：在device端生成调试信息。如果<code>-dopt</code>未指定，则关闭编译优化。</li><li><code>-lineinfo</code>：为device端生成行号，同时将source information嵌入到可执行文件中</li><li><code>-dopt</code>：如果<code>-G</code>没有指定，则<code>-dopt=on</code>，允许device端代码编译优化。如果<code>-G</code>指定，enables limited debug information generation for optimized device code</li></ul><p>常用编译命令：</p><ul><li><code>nvcc -lineinfo -arch=compute_86 -code=sm_86</code><ul><li>或者<code>alias mynvcc='nvcc -lineinfo -arch=compute_86 -code=sm_86'</code></li></ul></li></ul><h2 id=架构发展>架构发展<a hidden class=anchor aria-hidden=true href=#架构发展>¶</a></h2><h3 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>¶</a></h3><img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-27-11:38:55.png alt=image-20231227113855018 style=zoom:80%>
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-27-11:39:54.png alt=image-20231227113954626 style=zoom:80%>
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-27-11:40:15.png alt=image-20231227114015125 style=zoom:80%><h3 id=tesla>Tesla<a hidden class=anchor aria-hidden=true href=#tesla>¶</a></h3><h4 id=g80>G80<a hidden class=anchor aria-hidden=true href=#g80>¶</a></h4><img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-16-18:23:37.png alt=image-20231216182335365 style=zoom:50%><ul><li>SP（Streaming Processor）：scalar ALU for a single CUDA thread<ul><li>ALU执行是流水线化的，即一项操作会被分为X个步骤由X个组件去处理，每个步骤都耗费1周期。虽然一条指令要X周期才能执行完，但对于每个组件只要1周期就执行完了，所以每个周期都能送入一份数据进ALU。<ul><li>SP的频率是调度单元（以及外部纹理单元等）的2倍，所以在调度单元看来，是需要2周期去消化1条指令。</li></ul></li></ul></li><li>SM（Streaming Mulitprocessor）：每个线程块分配到一个SM上<ul><li>SM的频率是GPU频率的两倍</li></ul></li></ul><h4 id=scoreboarding>scoreboarding<a hidden class=anchor aria-hidden=true href=#scoreboarding>¶</a></h4><ul><li><p>作用：在指令发射阶段，检查待发射的指令是否与正在执行但尚未写回寄存器的指令之间存在数据相关。三种数据相关：
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-26-18:56:45.png alt=image-20231226185644918 style=zoom:70%></p></li><li><p>大致原理：scoreboard为每个warp寄存器分配一个bit来记录相应寄存器的写完成状态，</p><ul><li>如果后序指令不存在数据相关，则进入流水线</li><li>如果存在数据相关，通过检查标识位，后续指令就会stall而无法发射，此时可以切换其他warp的指令进行调度</li></ul></li><li><p>参考</p><ul><li><a href=https://blog.csdn.net/angus_huang_xu/article/details/105746777># ILP——指令级并行2：记分牌（Scoreboard）技术</a></li><li>通用图形处理器设计3.5</li></ul></li></ul><h3 id=fermi>Fermi<a hidden class=anchor aria-hidden=true href=#fermi>¶</a></h3><p>以<a href=https://www.ece.lsu.edu/gp/refs/gf100-whitepaper.pdf>GF100</a>为例，架构：
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-16:18:45.png alt=image-20231220161845919 style=zoom:80%></p><h4 id=特点>特点<a hidden class=anchor aria-hidden=true href=#特点>¶</a></h4><ul><li><strong>第三代流式多处理器（SM）</strong><ul><li>每个SM有<strong>32</strong>个CUDA核心，比GT200多<strong>4倍</strong></li><li><strong>双精度浮点</strong>峰值性能比GT200提高<strong>8倍</strong></li><li><strong>两个warp调度器</strong>，可以同时调度和分发指令给两个独立的warp</li><li><strong>64KB RAM</strong>，可供共享内存和L1缓存配置化划分使用</li></ul></li><li><strong>第二代并行线程执行ISA（Instruction Set Architecture指令集架构）</strong><ul><li>统一地址空间，完全支持C++（比如虚函数、new/delete等）</li><li>针对OpenCL和DirectCompute进行了优化</li><li>完全支持<strong>IEEE 754-2008</strong> 32位和64位精度</li><li>具有64位扩展的完整32位整数路径</li><li>内存访问指令支持向64位寻址的过渡</li><li>通过<strong>预测</strong>提高性能<ul><li>Predication enables short conditional code segments to execute efficiently with no branch instruction overhead</li></ul></li></ul></li><li><strong>改进的内存子系统</strong><ul><li>具有<strong>可配置L1和统一L2高速缓存</strong>的NVIDIA Parallel DataCacheTM层次结构<ul><li>之前Tesla架构没有L1、L2 cache</li></ul></li><li>支持<strong>ECC</strong>内存的第一款GPU</li><li>大大提高原子内存操作性能</li></ul></li><li><strong>NVIDIA GigaThread引擎</strong><ul><li>应用程序上下文<strong>切换速度提高了10倍</strong></li><li>并发内核执行</li><li>无序线程块执行</li><li><strong>双向可重叠</strong>的内存传输引擎</li></ul></li></ul><h4 id=sm>SM<a hidden class=anchor aria-hidden=true href=#sm>¶</a></h4><ul><li><p>SM架构：有4个执行端口
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-10:29:56.png alt=image-20231220102952702 style=zoom:80%></p><ul><li>core<ul><li>每个CUDA处理器都有完全<strong>流水线化</strong>的整数算术逻辑单元（ALU）和浮点单位（FPU）</li></ul></li><li>LD/ST单元<ul><li>每个SM有16个Load/Store单元，允许16个线程每个时钟周期计算源和目的地址，支持将每个地址的数据读取和存储到缓存或DRAM中</li></ul></li><li>SFU</li></ul></li><li><p>dual warp scheduler
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-10:58:34.png alt=image-20231220105834360 style=zoom:50%></p><ul><li>每个SM有两个warp scheduler和两个instruction dispatch unit，每个周期可以同时issue和execute两个warp<ul><li>warp scheduler：选择warp</li><li>Instruction Dispatch Unit：将指令发送到对应的端口（16个core、或16个LD/ST、或4个SFU中）</li><li>由于SP（或者core）的频率是调度单元的2倍，因此调度单元一个周期选择一个warp，一个周期内2倍频率的core连续两次在half-warp上执行</li><li>由于SFU只有4个，因此一个warp在SFU中计算需要消耗8个周期，但是此时它不阻塞调度</li></ul></li><li>由于warp之间独立运行，因此warp scheduler不需要检查指令流中的依赖关系</li><li>大多数指令可以这样同时dual issue，两个整数指令、两个浮点指令或混合发出整数、浮点、加载、存储和 SFU 指令；但是双精度指令不支持dual dispatch with any other operation</li></ul></li><li><p>G80/GT200/Fermi对比
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-11:01:59.png alt=image-20231220110159265 style=zoom:40%></p></li></ul><h4 id=isa>ISA<a hidden class=anchor aria-hidden=true href=#isa>¶</a></h4><ul><li>Fermi是第一个支持PTX2.0的架构<ul><li>PTX2.0统一了各种内存空间的寻址</li></ul></li></ul><h4 id=gigathread>GigaThread<a hidden class=anchor aria-hidden=true href=#gigathread>¶</a></h4><ul><li>两级thread scheduler<ul><li>thread scheduler：将线程块调度和分配到SM，GigaThread</li><li>warp scheduler：将warp调度和分配到执行单元</li></ul></li><li>特点：<ul><li>应用程序上下文切换速度更快</li><li>concurrent(并发) kernel执行：（感觉下面的图画得有些confused？）<ul><li>同一应用程序上下文的不同kernel可以并行在GPU上执行</li><li>不同应用程序上下文的kernel可以顺序执行
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-11:24:02.png alt=image-20231220112402824 style=zoom:80%></li></ul></li></ul></li></ul><h3 id=kepler>Kepler<a hidden class=anchor aria-hidden=true href=#kepler>¶</a></h3><p><a href=https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/tesla-product-literature/NVIDIA-Kepler-GK110-GK210-Architecture-Whitepaper.pdf>GK110/210</a>是Kepler架构中高端型号，用于科学计算，因此主要以这两种型号为基础来介绍kepler架构。总体架构：15个SMX
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-14:00:18.png alt=image-20231220140018532 style=zoom:50%></p><h4 id=smx>SMX<a hidden class=anchor aria-hidden=true href=#smx>¶</a></h4><ul><li><p>架构
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-14:18:50.png alt=image-20231220141850070 style=zoom:80%></p></li><li><p>SMX中的core的频率与主GPU频率相同，以增大面积为代价，降低功耗
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-16:58:59.png alt=image-20231220165859291 style=zoom:33%></p></li><li><p>warp scheduler
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-15:04:24.png alt=image-20231220150424654 style=zoom:40%></p><ul><li>4个warp scheduler和8个instruction dispatch unit<ul><li>warp scheduler中调度的warp，对应的2个instruction dispatch unit可以在一个周期分配给该warp两个独立的指令</li><li>两个指令中允许双精度指令与其他指令dual dispatch</li></ul></li><li>kepler架构针对warp scheduler在降低功耗方面的优化：从硬件的动态调度转向编译器辅助的静态调度
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-16:49:07.png alt=image-20231220164907711 style=zoom:50%></li><li>Fermi用硬件scoreboard来记录寄存器的使用信息，从而确定指令之间的依赖关系<ul><li>硬件scoreboard就是记录各个组件（寄存器、执行单元）当下的情况，并自动根据指令涉及的操作数、ALU去匹配。</li></ul></li><li>到了Kepler架构，因为指令的执行周期是可以预计的，所以调度信息其实在编译期就能确定了。于是ISA就做了更改，每7条指令为一组，附加一段调度信息（Control Code），把因为数据依赖需要等待的cycle数记录进去。硬件上许多动态调度的模块被砍掉了，节省了功耗。<ul><li>访存指令的延迟依旧是没法预计的，因为不知道有没有cache miss，所以遇到访存指令势必需要一个等待数据就绪的同步过程，可以借助软件scoreboard来完成。</li><li>软件scoreboard可以看作是预分配几个信条量，有依赖关系的指令会显式声明对哪几个信号量做操作，这样一来要记录维护的信息变少了，逻辑也简单了。同时软件scoreboard没有dependency check，一方面可以将这部分卸载到编译器，另一方面考虑到dependency不多</li></ul></li></ul></li><li><p>cache</p><ul><li>Kepler的L1 Cache是用来为reg spill或者stack data服务的，即访存数据其实并不会缓存在L1里。</li><li>对于那些readonly的global memory，允许借用Tex Cache</li></ul></li><li><p>shuffle指令：warp可以读取来自warp内其他线程中任意排列的值，因此节省了共享内存</p></li></ul><h4 id=dynamic-parallelism>Dynamic Parallelism<a hidden class=anchor aria-hidden=true href=#dynamic-parallelism>¶</a></h4><h4 id=hyper-q>Hyper-Q<a hidden class=anchor aria-hidden=true href=#hyper-q>¶</a></h4><ul><li>之前架构中只有一个CPU与GPU的工作分配器（CWD）之间的硬件工作队列，多个流复用一个队列，可能造成虚假的依赖性</li><li>现在有32个硬件工作队列</li></ul><h4 id=grid-management-unit>Grid Management Unit<a hidden class=anchor aria-hidden=true href=#grid-management-unit>¶</a></h4><ul><li>为了支持动态并行，需要改变对grid的管理</li></ul><h4 id=nvidia-gpudirect>NVIDIA GPUDirect<a hidden class=anchor aria-hidden=true href=#nvidia-gpudirect>¶</a></h4><ul><li>可以实现 GPU 与其他设备（例如网络接口卡 (NIC) 和存储设备）之间的直接通信和数据传输，但是中间数据不经过CPU</li></ul><h3 id=maxwell>Maxwell<a hidden class=anchor aria-hidden=true href=#maxwell>¶</a></h3><p>以GM204为例，4个GPC，每个GPC有4个SMM
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-17:44:14.png alt=image-20231220174414182 style=zoom:50%></p><h4 id=特点-1>特点<a hidden class=anchor aria-hidden=true href=#特点-1>¶</a></h4><ul><li>更高效的SM（Maxwell SM，也称SMM）：core数量减少但是效率增加<ul><li>指令调度提升<ul><li>所有核心的SMM功能单元都分配给特定的调度器，没有共享单元。</li><li>每个分区中的core数量是32，warp scheduler方便调度</li><li>支持双发射（两个独立的指令，比如一个计算一个访存），也支持单发射（此时正好调度到一个warp）</li></ul></li><li>现有代码的占用率增加：每个SM上active的block数量翻倍</li><li>减少算数指令延迟</li></ul></li><li>更大的专用共享内存：<ul><li>每个SMM有64KB的共享内存，4个processing block共享；但是每个线程块只能用48KB</li><li>L1缓存专职服务于texture，L2缓存大小激增</li></ul></li><li>快速的共享内存原子操作</li><li>支持动态并行：Kepler只在高端GPU中支持，Maxwell在低功率芯片中也支持</li></ul><h4 id=smm>SMM<a hidden class=anchor aria-hidden=true href=#smm>¶</a></h4><img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-17:49:42.png alt=image-20231220174942639 style=zoom:67%><h3 id=pascal>Pascal<a hidden class=anchor aria-hidden=true href=#pascal>¶</a></h3><p>以<a href=https://images.nvidia.com/content/pdf/tesla/whitepaper/pascal-architecture-whitepaper-v1.2.pdf>GP100</a>为例，6个GPC，每个GPC有5个TPC，每个TPC有2个Pascal SM（但是P100有56个SM）
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-21:36:02.png alt=image-20231220213601888 style=zoom:50%></p><h4 id=架构>架构<a hidden class=anchor aria-hidden=true href=#架构>¶</a></h4><ul><li>SMP
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-21:36:31.png alt=image-20231220213631880 style=zoom:60%><ul><li>每个SM有64个core</li><li>每个SM中寄存器数量保持不变，因为SM数量更多，所以总的寄存器数量也变多</li><li>每个SM中共享内存从GM200的96KB下降到64KB，但是因为SM数量更多，因此共享内存总量更大</li><li>每个SM中有32个双精度FP64 CUDA core</li></ul></li><li>支持FP16</li><li>有专用的共享内存（64KB/SM），L2 cache进一步增大</li></ul><h4 id=unified-memory>Unified Memory<a hidden class=anchor aria-hidden=true href=#unified-memory>¶</a></h4><h4 id=compute-preemption>Compute preemption<a hidden class=anchor aria-hidden=true href=#compute-preemption>¶</a></h4><ul><li>计算抢占：允许在GPU上运行的计算任务在指令级别粒度上被中断</li><li>在Pascal架构之前：<ul><li>仅仅在线程块粒度可以被中断</li><li>如果GPU上同时运行计算任务和显示任务，则长时间的计算可能会使得显示任务变得不响应和非交互</li></ul></li><li>Pascal中<ul><li>支持计算抢占，因此显示任务会保持流畅运行</li><li>同时，计算抢占允许在单个GPU上交互式调试kernel</li></ul></li></ul><h4 id=硬件结构>硬件结构<a hidden class=anchor aria-hidden=true href=#硬件结构>¶</a></h4><ul><li>内存从原来的GDDR5更换到HBM</li><li>NVLink：可以GPU之间连接，也可以CPU和GPU之间连接<ul><li>通过NVLink连接的GPU，程序可以直接访问另一个GPU的显存</li></ul></li></ul><h3 id=volta>Volta<a hidden class=anchor aria-hidden=true href=#volta>¶</a></h3><p>以V100为例，有6个GPC，每个GPC有7个TPC，每个TPC有2个SM</p><h4 id=sm和tensor-core>SM和Tensor Core<a hidden class=anchor aria-hidden=true href=#sm和tensor-core>¶</a></h4><img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-21:47:39.png alt=image-20231220214739795 style=zoom:90%><ul><li><p>core的变化：允许FP32和INT32操作同时执行</p><ul><li>原来SM是core（ALU+FPU）+DPU的结构，因此FP32与INT32无法同时运行<ul><li>由于ALU都是流水线化、分阶段的，因此虽然ALU和FPU可以同时运行，但是可能处于不同阶段</li></ul></li><li>现在SM是FP32+FP64+INT的结构，分离了ALU和FPU<ul><li>因此FP32与INT32可以同时运行</li><li>而且FP32和INT32可以满吞吐运行<ul><li>对于1个warp共32个线程，交给16个单元去执行的话，要像G80等架构提到的那样占用连续的两个周期来完成issue。不过在第二个周期，dispatch unit可以继续发射指令到其他单元，比如INT32。两者交错起来，就正好能达到满吞吐。</li><li>虽然增加了1周期的延迟，但是Volta大多数指令延迟都从6个周期降低到4个周期，总体还是快</li></ul></li></ul></li><li>意义：很多程序具有执行指针算术（整数内存地址计算）与浮点计算相结合的内部循环，流水线循环的每次迭代都可以更新地址（INT32指针算术）并为下一次迭代加载数据，同时在FP32中处理当前迭代。</li></ul></li><li><p>Tensor Core</p><ul><li>每个tensor core在每个时钟周期内，可以执行64个浮点FMA操作（<code>4*4*4</code>的GEMM）</li><li>每个tensor core执行浮点FMA操作：<code>D=A*B+C</code>
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-21:58:40.png alt=image-20231220215840623 style=zoom:33%></li></ul></li><li><p>enhanced L1 data cache and shared memory</p><ul><li>Instruction Cache<ul><li>原来SM中有一个Instruction Cache，每个processing block中有一个Instruction Buffer</li><li>现在SM中有一个L1 Instruction Cache，每个processing block中有一个L0 Instruction Cache</li></ul></li><li>提高了L1 data cache的带宽，降低了其延迟</li><li>共享内存<ul><li>将共享内存和L1 data cache整合起来，一共128KB，其中共享内存可以分配到96KB</li><li>纹理内存、全局内存都会经过L1 data cache</li></ul></li><li>之前的GPU只有load caching，GV100中引入了write caching</li></ul></li></ul><h4 id=independent-thread-scheduling>Independent Thread Scheduling<a hidden class=anchor aria-hidden=true href=#independent-thread-scheduling>¶</a></h4><ul><li><p>之前的SIMT模型</p><ul><li>一个warp使用一个共享的程序计数器，作用于32个线程，使用一个活动掩码，masked thread就是inactive的thread。各个分支依次执行，最后reconverge（同步）</li><li>由于divergence处理成顺序的执行，因此，来自不同区域或不同执行状态的 Warp 中的线程不能相互发送信号或交换数据，同时需要由锁或互斥锁保护的细粒度数据共享的算法很容易导致死锁<ul><li>例子：比如0~3号线程在执行完A之后，需要使用到X的计算结果，此时无法实现
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-22:29:49.png alt=image-20231220222949079 style=zoom:50%></li></ul></li></ul></li><li><p>Volta的SIMT模型：引入独立线程调度，每个线程都有自己的程序计数器和调用堆栈
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-22:33:17.png alt=image-20231220223317559 style=zoom:50%></p><ul><li>Volta的独立线程调度允许GPU放弃任何线程的执行，以便更好地利用执行资源或允许一个线程等待另一个线程生成数据，现在线程可以按照子warp粒度进行分支和重新汇聚，同时Volta中的收敛优化器仍会将执行相同代码的线程组合在一起、并行运行以达到最大效率。<ul><li>可以使用CUDA 9的warp同步函数<code>__syncwarp()</code>来强制warp重新汇聚，因此假设了warp同步的代码不再安全</li><li><code>void __syncwarp(unsigned mask = 0xffffffff)</code><ul><li>二进制位1表示对应的线程参与同步</li></ul></li></ul></li><li>虽然一个SM中拆分为了4个processing block，每个processing block16个FP32/INT32，而且每个线程都有自己的PC和stack，看起来half-warp在1个周期内可以直接调度和dispatch到一个processing block；但是每次调度仍然是一个warp（32个线程），消耗2个周期（1个周期调度到1个processing block，2个周期将完整的warp调度完毕）。<ul><li>前面的方法会增加调度硬件的复杂性，而且这种运行时的动态信息会改变各个组件的可用情况，也可能会破坏编译器静态调度的预设状态。</li></ul></li><li>例子1：可以实现warp内部细粒度的同步
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-05-15:23:05.png style=zoom:60%></li><li>例子2：分支间交错执行，可以掩盖stall<ul><li>独立线程调度使得假设了warp同步的代码不再安全，比如此时在执行Z的时候，一个warp中的32个线程没有reconverge（同步），而是保持原来的branch执行<ul><li>这是因为调度程序必须保守地假设Z可能会产生其他分叉执行分支所需的数据，如果是这种情况，自动强制重新汇聚将不安全。
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-21-15:17:24.png alt=image-20231221151724143 style=zoom:60%>
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-22:58:51.png alt=image-20231220225851393 style=zoom:50%></li></ul></li><li>此时需要使用<code>__syncwarp()</code>强制汇聚，可以提高SIMT效率<br><img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-22:59:19.png alt=image-20231220225919107 style=zoom:50%></li><li>因此，从CUDA 9开始，原来的warp shuffle指令<code>__shfl</code>都变成了deprecated，推荐使用<code>__shfl_sync</code>，里面加入了mask参数</li></ul></li><li>例子3：无饥饿算法，多线程环境下双向链表插入节点<ul><li>Volta的独立线程调度确保即使线程T0当前持有节点A的锁，同一warp中的另一个线程T1也可以成功等待锁变得可用，而不会妨碍线程T0的进展。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__device__</span> <span class=kt>void</span> <span class=nf>insert_after</span><span class=p>(</span><span class=n>Node</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=n>Node</span> <span class=o>*</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lock</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>lock</span><span class=p>(</span><span class=n>a</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=n>a</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>unlock</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>unlock</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li>缺点：增加了寄存器负担，单个线程的程序计数器一般要占用两个寄存器</li><li>参考<ul><li><a href=https://www.zhihu.com/question/290660113>https://www.zhihu.com/question/290660113</a></li><li><a href=https://developer.nvidia.com/blog/inside-volta/>https://developer.nvidia.com/blog/inside-volta/</a></li><li><a href=https://zhuanlan.zhihu.com/p/186192189>https://zhuanlan.zhihu.com/p/186192189</a></li></ul></li></ul></li></ul><h4 id=multi-process-servicemps>Multi-Process Service(MPS)<a hidden class=anchor aria-hidden=true href=#multi-process-servicemps>¶</a></h4><ul><li><p>MPS：实现多个计算应用程序共享GPU时的性能提升和隔离</p></li><li><p>特点</p><ul><li>保证服务质量：限制每个应用程序只使用GPU资源的一部分，从而降低或消除排队阻塞</li><li>独立地址空间：不同应用程序进行地址隔离
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-21-00:11:58.png alt=image-20231221001158198 style=zoom:50%></li></ul></li><li><p>发展</p><ul><li><p>Volta之前都是通过软件方法，使用时间片的方式Time-slice scheduling
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-23:49:35.png alt=image-20231220234935121 style=zoom:40%></p><ul><li>从Kepler GK110 GPU开始，NVIDIA引入了基于软件的Multi-Process Service（MPS）和MPS Server，MPS Server允许将多个不同的CPU进程（应用程序上下文）组合成单个应用程序上下文并运行在GPU上，从而实现更高的GPU资源利用率。</li><li>对于Pascal，CUDA Multi-Process Service是一个CPU进程，它代表已经请求和其他GPU应用程序同时共享执行资源的GPU应用程序。该进程充当中介，将工作提交到GPU内部的工作队列中以进行并发内核执行。</li></ul></li><li><p>Volta MPS：
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-20-23:53:30.png alt=image-20231220235330434 style=zoom:50%></p><ul><li>Server CUDA Context管理GPU硬件资源，多个MPS Clients会将它们的任务通过MPS Server传入GPU</li><li>Volta MPS对MPS server的关键部分使用硬件加速，使得MPS客户端能够直接将工作提交到GPU内部的工作队列中，同时将MPS客户端的最大数量从Pascal上的16增加到Volta上的48</li><li>Volta MPS旨在将GPU共享在单个用户的应用程序之间，并不适用于多用户或多租户用例</li><li>如果其中一个运行出错，则可能导致运行的任务都失败，即Volta MPS不提供客户端之间的致命故障隔离。</li></ul></li></ul></li><li><p>应用：</p><ul><li>No Batching的推理场景中，允许许多单独的单个推理任务同时提交到GPU，提升GPU利用率</li><li>支持linux下的统一内存，<ul><li>在GPU执行时，之前的MPS client都是运行在一个单独的地址空间，与访问独立CPU进程内存不兼容</li></ul></li></ul></li><li><p>Hyper-Q与MPS</p><ul><li>Hyper-Q：多流优化，同一个应用程序下多个stream中，没有依赖的操作可以并行执行</li><li>MPS：同时并行运行多个应用程序，多个应用程序共享同一个GPU context</li></ul></li><li><p>more reading and reference</p><ul><li><a href=https://docs.nvidia.com/deploy/pdf/CUDA_Multi_Process_Service_Overview.pdf>MULTI-PROCESS SERVICE</a></li><li><a href=https://zhuanlan.zhihu.com/p/346389176># 教你如何继续压榨GPU的算力</a></li><li><a href=https://asphelzhn.github.io/2019/04/14/tensor_09_MPS/>https://asphelzhn.github.io/2019/04/14/tensor_09_MPS/</a></li><li><a href=https://blog.csdn.net/cleanarea/article/details/112691820>https://blog.csdn.net/cleanarea/article/details/112691820</a></li></ul></li></ul><h4 id=cooperative-groupscg>Cooperative Groups(CG)<a hidden class=anchor aria-hidden=true href=#cooperative-groupscg>¶</a></h4><p>协作组是CUDA 9引入的新特性，允许自定义线程通信的粒度
<a href=https://zhuanlan.zhihu.com/p/673304744># CUDA 编程模型之协作组（Cooperative Groups）</a>
<a href=https://blog.csdn.net/kunhe0512/article/details/128927355># CUDA协作组详解</a></p><h3 id=turing>Turing<a hidden class=anchor aria-hidden=true href=#turing>¶</a></h3><p>以<a href=https://images.nvidia.com/aem-dam/Solutions/design-visualization/technologies/turing-architecture/NVIDIA-Turing-Architecture-Whitepaper.pdf>TU102</a>为例，有6个GPC，每个GPC有6个TPC，每个TPC有2个SM
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-21-16:35:55.png alt=image-20231221163555318 style=zoom:75%></p><ul><li>SM<ul><li>添加了独立的integer datapath，可以与浮点数指令同时运行</li><li>Uniform Register：将共享内存、texture cache、memory load cache（L1 data cache？）重新设计，统一到一起</li></ul></li><li>第二代Tensor Core<ul><li>添加了INT8和INT4精度模式，增强了推理性能</li><li>支持DLSS（Deep Learning Super Sampling）</li></ul></li><li>实时光线追踪、渲染管线、RT Core、DLSS等图像相关</li></ul><h3 id=ampere>Ampere<a hidden class=anchor aria-hidden=true href=#ampere>¶</a></h3><p>以<a href=https://images.nvidia.com/aem-dam/en-zz/Solutions/data-center/nvidia-ampere-architecture-whitepaper.pdf>GA100</a>为例，有8 GPCs, 8 TPCs/GPC, 2 SMs/TPC</p><h4 id=sm-1>SM<a hidden class=anchor aria-hidden=true href=#sm-1>¶</a></h4><img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-21-17:25:04.png alt=image-20231221172504272 style=zoom:80%><ul><li>第三代Tensor Core<ul><li>Tensor Core Sparsity利用2:4的细粒度结构化稀疏性，使得吞吐量翻倍<ul><li>稀疏矩阵定义：2:4稀疏矩阵，即每个四元组中有两个非零值
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-21-20:41:04.png alt=image-20231221204104503 style=zoom:67%></li><li>过程：使用稠密权重进行训练，然后进行细粒度结构化剪枝，最后通过额外的训练步骤对剩余的非零权重进行微调。</li><li>具体而言，A100使用Sparse MMA(Matrix Multiply-Accumulate)指令，跳过对带零值的输入进行计算，从而使 Tensor Core 的计算吞吐量翻倍
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-21-21:01:09.png alt=image-20231221210109424 style=zoom:50%></li></ul></li><li>支持所有数据类型：FP16、BF16、TF32、FP64、INT8、INT4 和 INT1，且比V100有进一步的加速效果
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-21-20:37:22.png alt=image-20231221203721459 style=zoom:50%><ul><li>如果不使用Tensor Core，默认使用FP32；如果使用Tensor Core，则默认使用TF32</li><li>支持FP16/FP32、BF16/FP32混合精度，且两种混合精度速度一样快</li><li>TF32一方面保持了FP16的精度，另一方面保持了FP32的范围，因此很适合训练</li></ul></li></ul></li></ul><h4 id=memory方面的改进>memory方面的改进<a hidden class=anchor aria-hidden=true href=#memory方面的改进>¶</a></h4><ul><li><p>Data sharing improvements：
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-00:00:12.png alt=image-20231222000012376 style=zoom:50%></p><ul><li>数据可以在一个warp中32个线程共享，原来Volta只能在8个线程之间共享<ul><li>因此节省了寄存器和带宽</li><li>同时，A100 Tensor Core将矩阵乘法指令的k维变为原来的4倍</li></ul></li><li>表格中的数据怎么来的？<a href=https://zhuanlan.zhihu.com/p/614429902>Nvidia tensorCore 计算过程</a></li></ul></li><li><p>Data Fetch improvement
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-10:22:10.png alt=image-20231222102210009 style=zoom:50%></p><ul><li>新的异步拷贝指令可以直接将数据从全局内存（通常是DRAM和L2缓存）中加载到共享内存中，绕过L1缓存和寄存器</li><li>原来Volta中，数据先经过L1缓存读取到寄存器，然后再写到共享内存中</li><li>异步拷贝指令与异步barrier搭配使用：异步拷贝完成后，通过异步barrier通知程序拷贝完成</li><li>Compute Data Compression
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-11:24:01.png alt=image-20231222112401558 style=zoom:33%><ul><li>Combined L1 cache and shared memory<ul><li>L1 data cache和共享内存整合到一起，一共192KB</li><li>FP32和INT32可以同时运行、且满吞吐运行（与Volta与Turing架构相同）</li></ul></li></ul></li></ul></li><li><p>L2 cache improvement</p><ul><li>设计改进
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-11:28:03.png alt=image-20231222112803822 style=zoom:67%></li><li>Residency Control：ping-pong buffer（或称double buffer）
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-11:16:24.png alt=image-20231222111624574 style=zoom:50%><ul><li>ping-pong buffer常驻于L2缓存上，减少对内存的写回，保持L2中数据重用</li><li>比如推理场景中，权重分段轮流装载到L2缓存上，让计算与权重装载并行。此时，多batch可以共用更多的权重</li></ul></li></ul></li><li><p>总结
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-11:31:53.png alt=image-20231222113153880 style=zoom:50%></p></li></ul><h4 id=multi-instance-gpumig>Multi-Instance GPU(MIG)<a hidden class=anchor aria-hidden=true href=#multi-instance-gpumig>¶</a></h4><ul><li><p>背景：Volta MPS虽然支持多个应用程序同时运行，但是可能一个应用程序占用太多内存带宽或是L2缓存，对其他应用程序造成影响</p></li><li><p>MIG
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-16:01:25.png alt=image-20231222160125125 style=zoom:50%></p><ul><li>MIG可以将每个A100 划分为最多7个GPU Instance，每个instance可以为client（虚拟机、容器、进程等）提供定义的服务质量和故障隔离</li><li>每个instance由若干个GPU slices组成，GPU slices的结构
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-16:16:03.png alt=image-20231222161603049 style=zoom:50%><ul><li>Sys Pipe：GigaThread Engine的一部分</li><li>一个GPC（7个TPC，14个SM）</li><li>一个L2 slice group（包括10个L2 cache slices）</li><li>对一部分frame buffer memory的访问</li></ul></li><li>每个instance内部可以再细分为compute instance
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-16:27:19.png alt=image-20231222162719640 style=zoom:67%><ul><li>compute instance可以自行配置和封装计算资源，默认每个instance创建一个compute instance，因此该compute instance使用该instance的全部资源</li><li>每个compute instance包括一个Sys Pipe和若干个GPC，所有共享一个compute instance的应用程序共享一个Sys Pipe，每个compute instance都可以单独进行上下文切换</li><li>每个compute instance都支持MPS，MPS client的最大数量与compute instance大小成正比</li></ul></li></ul></li><li><p>应用场景：</p><ul><li>Multi-Tenant</li><li>Single Tenant, Single User：一个用户运行多个GPU应用程序</li><li>Single Tenant, Multi-User：比如对外部提供AI服务</li></ul></li></ul><h4 id=cuda-advances>CUDA Advances<a hidden class=anchor aria-hidden=true href=#cuda-advances>¶</a></h4><ul><li><p>Task Graph Acceleration</p><ul><li>背景：对于深度学习等应用场景，有iterative structure（即same workflow is executed repeatedly）<ul><li>以前只能在每个iteration中，CPU重新提交任务到GPU。尤其是很多小的kernel在整个运行过程中，launch、init等开销占了相当一部分时间。</li><li>现在定义一个task graph（若干个操作、相应依赖关系和一些内存操作），可以define-once/run-repeatedly，即先将多个kernel预先构建为一个task graph，然后CPU一次性launch，减少了launch、init的时间<ul><li>kernel的执行流程可以分为三个步骤：launch，grid initialization，kernel execution
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-26-16:09:41.png alt=image-20231226160941218 style=zoom:50%></li></ul></li></ul></li><li>加速原理：<ul><li>launch optimization：submit multiple work items to the GPU in a single operation</li><li>execution dependency optimization：可以优化复杂的graph（比如workflow fork and re-join，在一个fork分支中可以有多个dependency）
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-26-17:31:09.png alt=image-20231226173109417 style=zoom:50%></li></ul></li></ul></li><li><p><a href=https://blog.csdn.net/kunhe0512/article/details/125509926>异步数据拷贝</a>和异步barrier：<code>memcpy_asnyc</code></p><ul><li><a href=https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#asynchronous-data-copies>异步数据拷贝</a>：<ul><li><code>memcpy_asnyc</code>：从global memory到shared memory的异步数据拷贝</li><li><code>cudaMemcpyAsync</code>：从CPU memory到GPU global memory的异步数据拷贝</li></ul></li><li><a href=https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#asynchronous-barrier>异步barrier</a>：<code>arrival</code>和<code>wait</code>是分开的
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-19:33:51.png alt=image-20231222193351615 style=zoom:40%><ul><li><code>arrival</code>：最快线程到达barrier</li><li><code>wait</code>：等待其他线程（或者最慢的线程）到达barrier</li><li>普通的barrier由于各线程快慢不一，中间有idle；异步barrier中间原来idle的部分现在进行其他independent work</li></ul></li><li><a href=https://developer.nvidia.com/blog/controlling-data-movement-to-boost-performance-on-ampere-architecture/>Controlling Data Movement to Boost Performance on the NVIDIA Ampere Architecture</a>：两阶段的pipeline，将计算与拷贝重叠
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-21:21:41.png alt=image-20231222212140951 style=zoom:50%></li></ul></li><li><p>L2 cache residency control</p><ul><li>两种数据：<ul><li>persisting data：数据重复使用，比如深度学习场景，或生产者-消费者场景</li><li>streaming data：数据只使用一次
<img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-12-22-21:19:04.png alt=image-20231222211904317 style=zoom:33%></li></ul></li><li>L2 cache中专门留出一部分给persisting data使用，persistent access优先访问这部分，具体见<a href=https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-l2-access-management>Device Memory L2 Access Management</a></li></ul></li><li><p>参考</p><ul><li><a href=https://blog.csdn.net/han2529386161/article/details/106411138># NVIDIA GPU A100 Ampere(安培) 架构深度解析</a></li><li><a href=https://zhuanlan.zhihu.com/p/467466998># CUDA效率优化之：CUDA Graph</a></li><li><a href=https://zhuanlan.zhihu.com/p/145477249># NV Ampere GPU架构学习与思考</a></li></ul></li></ul><h3 id=ada-lovelace>Ada Lovelace<a hidden class=anchor aria-hidden=true href=#ada-lovelace>¶</a></h3><ul><li>cuda core数量增加</li><li>第四代Tensor Core<ul><li>Hopper FP8 Transformer Engine</li></ul></li></ul><h3 id=hopper>Hopper<a hidden class=anchor aria-hidden=true href=#hopper>¶</a></h3><p><a href=https://resources.nvidia.com/en-us-tensor-core>white paper</a></p><h3 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>¶</a></h3><ul><li><a href=https://mp.weixin.qq.com/s/qakvAfNV4KkmNa3P56i-dQ>https://mp.weixin.qq.com/s/qakvAfNV4KkmNa3P56i-dQ</a></li><li><a href=https://www.zhihu.com/people/zhang-huan-11-88/posts>江南泣相关（翻译）博客</a>和对应<a href=https://developer.nvidia.com/key-technologies>white paper</a></li><li><a href=https://zhuanlan.zhihu.com/p/258196004>NVIDIA GPU的一些解析（一）</a>的相关解读</li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://qinganzhang.github.io/posts/cuda-learning-notes/%E6%B5%81%E5%92%8C%E5%90%8C%E6%AD%A5/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>流和同步</span>
</a><a class=next href=https://qinganzhang.github.io/posts/effective-modern-cpp/ch08-%E5%BE%AE%E8%B0%83/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>[Effective Modern Cpp Notes] Ch08 微调</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://qinganzhang.github.io/>Paul's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>