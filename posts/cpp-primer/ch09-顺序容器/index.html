<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ch09 顺序容器 | Paul's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="第九章 顺序容器 9.1 顺序容器概述 顺序容器（sequential container）：元素顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。"><meta name=author content="Paul"><link rel=canonical href=https://qinganzhang.github.io/posts/cpp-primer/ch09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://qinganzhang.github.io/favicon.ico><link rel=apple-touch-icon href=https://qinganzhang.github.io/apple-touch-icon.png><meta name=twitter:title content="Ch09 顺序容器 | Paul's Blog"><meta name=twitter:description content="第九章 顺序容器 9.1 顺序容器概述 顺序容器（sequential container）：元素顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。"><meta property="og:title" content="Ch09 顺序容器 | Paul's Blog"><meta property="og:description" content="第九章 顺序容器 9.1 顺序容器概述 顺序容器（sequential container）：元素顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。"><meta property="og:type" content="article"><meta property="og:url" content="https://qinganzhang.github.io/posts/cpp-primer/ch09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T15:57:27+08:00"><meta property="article:modified_time" content="2024-02-27T15:57:27+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://qinganzhang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Ch09 顺序容器","item":"https://qinganzhang.github.io/posts/cpp-primer/ch09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ch09 顺序容器 | Paul's Blog","name":"Ch09 顺序容器","description":"第九章 顺序容器 9.1 顺序容器概述 顺序容器（sequential container）：元素顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。","keywords":["cpp"],"wordCount":"5630","inLanguage":"en","datePublished":"2024-02-27T15:57:27+08:00","dateModified":"2024-02-27T15:57:27+08:00","author":{"@type":"Person","name":"Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qinganzhang.github.io/posts/cpp-primer/ch09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"},"publisher":{"@type":"Organization","name":"Paul's Blog","logo":{"@type":"ImageObject","url":"https://qinganzhang.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://qinganzhang.github.io/ accesskey=h title="Paul's Blog (Alt + H)">Paul's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://qinganzhang.github.io/posts/ title=Posts class=active>Posts</a></li><li><a href=https://qinganzhang.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://qinganzhang.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://qinganzhang.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://qinganzhang.github.io/categories/ title=Categories>Categories</a></li><li><a href=https://qinganzhang.github.io/about/ title=About>About</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qinganzhang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://qinganzhang.github.io/posts/>Post</a></div><h1 class=post-title>Ch09 顺序容器</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-02-27</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://qinganzhang.github.io/tags/cpp/>cpp</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>5630 words</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>12 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ac%ac%e4%b9%9d%e7%ab%a0-%e9%a1%ba%e5%ba%8f%e5%ae%b9%e5%99%a8 aria-label="第九章 顺序容器">第九章 顺序容器</a><ul><li><a href=#91-%e9%a1%ba%e5%ba%8f%e5%ae%b9%e5%99%a8%e6%a6%82%e8%bf%b0 aria-label="9.1 顺序容器概述">9.1 顺序容器概述</a><ul><li><a href=#%e9%a1%ba%e5%ba%8f%e5%ae%b9%e5%99%a8%e7%b1%bb%e5%9e%8b aria-label=顺序容器类型>顺序容器类型</a></li></ul></li><li><a href=#92-%e5%ae%b9%e5%99%a8%e5%ba%93%e6%a6%82%e8%a7%88 aria-label="9.2 容器库概览">9.2 容器库概览</a><ul><li><a href=#%e7%b1%bb%e5%9e%8b aria-label=类型>类型</a></li><li><a href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=构造函数>构造函数</a></li><li><a href=#%e8%b5%8b%e5%80%bc%e5%92%8cswap aria-label=赋值和swap>赋值和<code>swap</code></a></li><li><a href=#%e5%a4%a7%e5%b0%8f aria-label=大小>大小</a></li></ul></li><li><a href=#93-%e9%a1%ba%e5%ba%8f%e5%ae%b9%e5%99%a8%e6%93%8d%e4%bd%9c aria-label="9.3 顺序容器操作">9.3 顺序容器操作</a><ul><li><a href=#%e6%b7%bb%e5%8a%a0%e5%85%83%e7%b4%a0 aria-label=添加元素>添加元素</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e5%85%83%e7%b4%a0 aria-label=访问元素>访问元素</a></li><li><a href=#%e5%88%a0%e9%99%a4%e5%85%83%e7%b4%a0 aria-label=删除元素>删除元素</a></li><li><a href=#%e7%89%b9%e6%ae%8a%e7%9a%84forward_list%e6%93%8d%e4%bd%9c aria-label=特殊的forward_list操作>特殊的forward_list操作</a></li><li><a href=#%e6%94%b9%e5%8f%98%e5%ae%b9%e5%99%a8%e5%a4%a7%e5%b0%8f aria-label=改变容器大小>改变容器大小</a></li><li><a href=#%e8%bf%ad%e4%bb%a3%e5%99%a8 aria-label=迭代器>迭代器</a></li></ul></li><li><a href=#94-vector%e5%af%b9%e8%b1%a1%e6%98%af%e5%a6%82%e4%bd%95%e5%a2%9e%e9%95%bf%e7%9a%84 aria-label="9.4 vector对象是如何增长的">9.4 vector对象是如何增长的</a><ul><li><a href=#%e7%ae%a1%e7%90%86%e5%ae%b9%e9%87%8f%e7%9a%84%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0 aria-label=管理容量的成员函数>管理容量的成员函数</a></li></ul></li><li><a href=#95-%e9%a2%9d%e5%a4%96%e7%9a%84string%e6%93%8d%e4%bd%9c aria-label="9.5 额外的string操作">9.5 额外的string操作</a><ul><li><a href=#%e6%9e%84%e9%80%a0string%e7%9a%84%e5%85%b6%e4%bb%96%e6%96%b9%e6%b3%95 aria-label=构造string的其他方法>构造string的其他方法</a></li><li><a href=#substr%e6%93%8d%e4%bd%9c aria-label=substr操作>substr操作</a></li><li><a href=#%e6%94%b9%e5%8f%98string%e7%9a%84%e5%85%b6%e4%bb%96%e6%96%b9%e6%b3%95 aria-label=改变string的其他方法>改变string的其他方法</a></li><li><a href=#string%e6%90%9c%e7%b4%a2%e6%93%8d%e4%bd%9c aria-label=string搜索操作>string搜索操作</a></li><li><a href=#scompare%e7%9a%84%e5%87%a0%e7%a7%8d%e5%8f%82%e6%95%b0%e5%bd%a2%e5%bc%8f aria-label=s.compare的几种参数形式>s.compare的几种参数形式</a></li><li><a href=#string%e5%92%8c%e6%95%b0%e5%80%bc%e8%bd%ac%e6%8d%a2 aria-label=string和数值转换>string和数值转换</a></li></ul></li><li><a href=#96-%e5%ae%b9%e5%99%a8%e9%80%82%e9%85%8d%e5%99%a8adapter aria-label="9.6 容器适配器（adapter）">9.6 容器适配器（adapter）</a><ul><li><a href=#%e9%80%82%e9%85%8d%e5%99%a8%e7%9a%84%e9%80%9a%e7%94%a8%e6%93%8d%e4%bd%9c%e5%92%8c%e7%b1%bb%e5%9e%8b aria-label=适配器的通用操作和类型>适配器的通用操作和类型</a></li><li><a href=#stack aria-label=stack>stack</a></li><li><a href=#queue%e5%92%8cpriority_queue aria-label=queue和priority_queue>queue和priority_queue</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=第九章-顺序容器>第九章 顺序容器<a hidden class=anchor aria-hidden=true href=#第九章-顺序容器>¶</a></h1><h2 id=91-顺序容器概述>9.1 顺序容器概述<a hidden class=anchor aria-hidden=true href=#91-顺序容器概述>¶</a></h2><ul><li><strong>顺序容器</strong>（sequential container）：元素顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</li></ul><h3 id=顺序容器类型>顺序容器类型<a hidden class=anchor aria-hidden=true href=#顺序容器类型>¶</a></h3><table><thead><tr><th>容器类型</th><th>介绍</th></tr></thead><tbody><tr><td><code>vector</code></td><td>随机访问，尾部插入/删除快</td></tr><tr><td><code>deque</code></td><td>随机访问，头尾插入/删除快</td></tr><tr><td><code>list</code></td><td>双向链表。只支持双向顺序访问，任何位置插入/删除都快</td></tr><tr><td><code>forward_list</code></td><td>单向链表。只支持单向顺序访问。任何位置插入/删除都快</td></tr><tr><td><code>array</code></td><td>固定大小数组，随机访问。不能添加或者删除元素。</td></tr><tr><td><code>string</code></td><td>随机访问，尾部插入/删除速度快。</td></tr></tbody></table><ul><li>list 的额外内存开销相比其他大很多。</li><li>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。<ul><li>如果不需要向中间插入数据，则先向vector中添加，再sort</li><li>如果一定要向中间插入数据，则先使用list，输入完成后再拷贝到vector中</li></ul></li></ul><h2 id=92-容器库概览>9.2 容器库概览<a hidden class=anchor aria-hidden=true href=#92-容器库概览>¶</a></h2><h3 id=类型>类型<a hidden class=anchor aria-hidden=true href=#类型>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>iterator</code></td><td>此容器类型的迭代器类型</td></tr><tr><td><code>const_iterator</code></td><td>可以读取元素但不能修改元素的迭代器类型</td></tr><tr><td><code>size_type</code></td><td>无符号整数类型，足够保存此种容器类型最大可能的大小</td></tr><tr><td><code>difference_type</code></td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td><code>value_type</code></td><td>元素类型</td></tr><tr><td><code>reference</code></td><td>元素的左值类型；和<code>value_type &</code>含义相同</td></tr><tr><td><code>const_reference</code></td><td>元素的<code>const</code>左值类型，即<code>const value_type &</code></td></tr></tbody></table><ul><li>迭代器范围begin和end，其中end是指向尾后地址，左闭右开</li><li>当不需要修改时，尽量使用const iterator</li></ul><h3 id=构造函数>构造函数<a hidden class=anchor aria-hidden=true href=#构造函数>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>C c;</code></td><td>默认构造函数，构造空容器</td></tr><tr><td><code>C c1(c2);</code>或<code>C c1 = c2;</code></td><td>构造<code>c2</code>的拷贝<code>c1</code></td></tr><tr><td><code>C c(b, e)</code></td><td>构造<code>c</code>，将<strong>迭代器</strong><code>b</code>和<code>e</code>指定范围内的所有元素拷贝到<code>c</code></td></tr><tr><td><code>C c{a, b, c...}</code></td><td>列表初始化<code>c</code></td></tr><tr><td><code>C c(n)</code></td><td>只支持顺序容器，且不包括<code>array</code>，包含<code>n</code>个元素，这些元素进行了值初始化</td></tr><tr><td><code>C c(n, t)</code></td><td>包含<code>n</code>个初始值为<code>t</code>的元素</td></tr></tbody></table><ul><li>三种构造方式：<ul><li>直接拷贝：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。</li><li>迭代器范围构造：不要求容器类型相同，容器内的元素类型也可以不同，但是要能进行类型转换</li><li>列表初始化</li></ul></li><li>array初始化<ul><li>定义array需要同时指定元素类型和大小，默认初始化为0</li><li>array只能默认初始化或列表初始化，如果定义的数组很大并且需要初始化，可以先默认初始化然后用 fill 函数填充值。</li></ul></li></ul><h3 id=赋值和swap>赋值和<code>swap</code><a hidden class=anchor aria-hidden=true href=#赋值和swap>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c1 = c2;</code></td><td>将<code>c1</code>中的元素替换成<code>c2</code>中的元素</td></tr><tr><td><code>c1 = {a, b, c...}</code></td><td>将<code>c1</code>中的元素替换成列表中的元素（不适用于<code>array</code>）</td></tr><tr><td><code>c1.swap(c2)</code></td><td>交换<code>c1</code>和<code>c2</code>的元素</td></tr><tr><td><code>swap(c1, c2)</code></td><td>等价于<code>c1.swap(c2)</code></td></tr><tr><td><code>c.assign(b, e)</code></td><td>将<code>c</code>中的元素替换成迭代器<code>b</code>和<code>e</code>表示范围中的元素，<code>b</code>和<code>e</code>不能指向<code>c</code>中的元素，可以用不同但相容的类型赋值，或者用容器的子序列赋值</td></tr><tr><td><code>c.assign(il)</code></td><td>将<code>c</code>中的元素替换成初始化列表<code>il</code>中的元素</td></tr><tr><td><code>c.assign(n, r)</code></td><td>将<code>c</code>中的元素替换为<code>n</code>个值是<code>t</code>的元素</td></tr></tbody></table><ul><li>swap：<ul><li>对于array，swap会真正交换它们的元素；对于其他元素，swap不交换元素，只交换数据结构，因此很快</li><li>对于 string，swap 后，指针、引用和迭代器会失效。对于其他容器，交换后指针指向了另一个容器的相同位置。</li><li>建议统一使用<code>swap(a,b)</code></li></ul></li><li>assign赋值：<ul><li><code>assign</code>操作不适用于关联容器和<code>array</code></li><li><code>=</code>赋值要求两边类型相同，assign只要求可以转换即可</li></ul></li><li>array赋值：<ul><li>不能对内置数组拷贝或赋值，但是 array 可以。</li><li>使用一个 array 对另一个 array 赋值，需要两个array 元素类型与大小都相同。</li><li>不能用花括号列表对 array 赋值（只可以初始化）</li></ul></li></ul><h3 id=大小>大小<a hidden class=anchor aria-hidden=true href=#大小>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.size()</code></td><td><code>c</code>中元素的数目（不支持<code>forward_list</code>）</td></tr><tr><td><code>c.max_size()</code></td><td><code>c</code>中可保存的最大元素数目</td></tr><tr><td><code>c.empty()</code></td><td>若<code>c</code>中存储了元素，返回<code>false</code>，否则返回<code>true</code></td></tr></tbody></table><ul><li>forward_list支持max_size和empty，但是不支持size</li></ul><h2 id=93-顺序容器操作>9.3 顺序容器操作<a hidden class=anchor aria-hidden=true href=#93-顺序容器操作>¶</a></h2><h3 id=添加元素>添加元素<a hidden class=anchor aria-hidden=true href=#添加元素>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.push_back(t)</code></td><td>在<code>c</code>尾部创建一个值为<code>t</code>的元素，返回<code>void</code></td></tr><tr><td><code>c.emplace_back(args)</code></td><td>同上</td></tr><tr><td><code>c.push_front(t)</code></td><td>在<code>c</code>头部创建一个值为<code>t</code>的元素，返回<code>void</code></td></tr><tr><td><code>c.emplace_front(args)</code></td><td>同上</td></tr><tr><td><code>c.insert(p, t)</code></td><td>在迭代器<code>p</code>指向的元素之前创建一个值是<code>t</code>的元素，返回指向新元素的迭代器</td></tr><tr><td><code>c.emplace(p, args)</code></td><td>同上</td></tr><tr><td><code>c.insert(p, n, t)</code></td><td>在迭代器<code>p</code>指向的元素之前插入<code>n</code>个值为<code>t</code>的元素，返回指向第一个新元素的迭代器</td></tr><tr><td><code>c.insert(p, b, e)</code></td><td>将迭代器<code>b</code>和<code>e</code>范围内的元素，插入到<code>p</code>指向的元素之前</td></tr><tr><td><code>c.insert(p, il)</code></td><td><code>il</code>是一个花括号包围中的元素值列表，将其插入到<code>p</code>指向的元素之前</td></tr></tbody></table><ul><li>向vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。</li><li>头尾添加返回void，中间添加返回指向新添加元素的迭代器</li><li>push和insert传递的是元素类型的对象，emplace则将参数传递给元素类型的构造对象<ul><li>传递给emplace的参数必须和元素类型的构造函数相匹配。</li></ul></li><li>insert 返回值是指向添加的元素中第一个元素的迭代器</li><li>添加的都是元素的拷贝，不是元素本身。</li></ul><h3 id=访问元素>访问元素<a hidden class=anchor aria-hidden=true href=#访问元素>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.back()</code></td><td>返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义</td></tr><tr><td><code>c.front()</code></td><td>返回<code>c</code>中头元素的引用。若<code>c</code>为空，函数行为未定义</td></tr><tr><td><code>c[n]</code></td><td>返回<code>c</code>中下标是<code>n</code>的元素的引用，<code>n</code>时候一个无符号整数。若<code>n>=c.size()</code>，则函数行为未定义</td></tr><tr><td><code>c.at(n)</code></td><td>返回下标为<code>n</code>的元素引用。如果下标越界，则抛出<code>out_of_range</code>异常</td></tr></tbody></table><ul><li>访问成员函数返回的是引用。</li></ul><h3 id=删除元素>删除元素<a hidden class=anchor aria-hidden=true href=#删除元素>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.pop_back()</code></td><td>删除<code>c</code>中尾元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td></tr><tr><td><code>c.pop_front()</code></td><td>删除<code>c</code>中首元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td></tr><tr><td><code>c.erase(p)</code></td><td>删除迭代器<code>p</code>指向的元素，返回一个指向被删除元素之后的元素的迭代器，若<code>p</code>本身是尾后迭代器，则函数行为未定义</td></tr><tr><td><code>c.erase(b, e)</code></td><td>删除迭代器<code>[b,e)</code>内的元素，返回指向最后一个被删元素之后元素的迭代器，若<code>e</code>本身就是尾后迭代器，则返回尾后迭代器</td></tr><tr><td><code>c.clear()</code></td><td>删除<code>c</code>中所有元素，返回<code>void</code></td></tr></tbody></table><ul><li>头尾删除返回void，特定位置删除，返回被删除元素之后元素的迭代器</li><li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=dd002dda-960e-9445-3aa0-2abd00fd6c03&amp;page=341&amp;rect=98.640,543.263,241.920,556.097">添加、删除操作可能使迭代器失效</a></li></ul><h3 id=特殊的forward_list操作>特殊的forward_list操作<a hidden class=anchor aria-hidden=true href=#特殊的forward_list操作>¶</a></h3><ul><li>forward_list 是单向链表，添加和删除操作都会同时改变前驱和后继结点</li><li><code>forward_list</code>定义了<code>before_begin()</code>，即【首前（off-the-beginning）迭代器】，允许我们再在首元素之前添加或删除元素。</li><li>前面的insert都是在当前元素之前插入，insert_after插入到当前元素之后</li></ul><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>lst.before_begin()</code></td><td>返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。</td></tr><tr><td><code>lst.cbefore_begin()</code></td><td>同上，但是返回的是常量迭代器。</td></tr><tr><td><code>lst.insert_after(p, t)</code></td><td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象</td></tr><tr><td><code>lst.insert_after(p, n, t)</code></td><td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象，<code>n</code>是数量。若<code>n</code>是0则函数行为未定义</td></tr><tr><td><code>lst.insert_after(p, b, e)</code></td><td>在迭代器<code>p</code>之后插入元素。由迭代器<code>b</code>和<code>e</code>指定范围。</td></tr><tr><td><code>lst.insert_after(p, il)</code></td><td>在迭代器<code>p</code>之后插入元素。由<code>il</code>指定初始化列表。</td></tr><tr><td><code>lst.emplace_after(p, args)</code></td><td>使用<code>args</code>在<code>p</code>之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若<code>p</code>为尾后迭代器，则函数行为未定义。</td></tr><tr><td><code>lst.erase_after(p)</code></td><td>删除<code>p</code>指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若<code>p</code>指向<code>lst</code>的尾元素或者是一个尾后迭代器，则函数行为未定义。</td></tr><tr><td><code>lst.erase_after(b, e)</code></td><td>类似上面，删除对象换成从<code>(b,e)</code>指定的范围。</td></tr></tbody></table><h3 id=改变容器大小>改变容器大小<a hidden class=anchor aria-hidden=true href=#改变容器大小>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.resize(n)</code></td><td>调整<code>c</code>的大小为<code>n</code>个元素，若<code>n&lt;c.size()</code>，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</td></tr><tr><td><code>c.resize(n, t)</code></td><td>调整<code>c</code>的大小为<code>n</code>个元素，任何新添加的元素都初始化为值<code>t</code></td></tr></tbody></table><h3 id=迭代器>迭代器<a hidden class=anchor aria-hidden=true href=#迭代器>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.begin()</code>, <code>c.end()</code></td><td>返回指向<code>c</code>的首元素和尾元素之后位置的迭代器</td></tr><tr><td><code>c.cbegin()</code>, <code>c.cend()</code></td><td>返回<code>const_iterator</code></td></tr><tr><td><code>c.rbegin()</code>, <code>c.rend()</code></td><td>返回指向<code>c</code>的尾元素和首元素之前位置的迭代器</td></tr><tr><td><code>c.crbegin()</code>, <code>c.crend()</code></td><td>返回<code>const_reverse_iterator</code></td></tr></tbody></table><ul><li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=dd002dda-960e-9445-3aa0-2abd00fd6c03&amp;page=341&amp;rect=98.640,543.263,241.920,556.097">添加、删除操作可能使迭代器失效</a><ul><li>在向容器添加元素后：<ul><li>如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。</li><li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。</li><li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器、指针和引用依然有效。</li></ul></li><li>在从一个容器中删除元素后：尾后迭代器总是会失效<ul><li>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器、引用和指针仍然有效。</li><li>对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除<code>deque</code>的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是<code>deque</code>的头元素，这些也不会受影响。</li><li>对于<code>vector</code>和<code>string</code>，指向被删元素之前的迭代器、引用、指针仍然有效。</li></ul></li></ul></li></ul><h2 id=94-vector对象是如何增长的>9.4 vector对象是如何增长的<a hidden class=anchor aria-hidden=true href=#94-vector对象是如何增长的>¶</a></h2><p><code>vector</code>和<code>string</code>在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。</p><h3 id=管理容量的成员函数>管理容量的成员函数<a hidden class=anchor aria-hidden=true href=#管理容量的成员函数>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.shrink_to_fit()</code></td><td>将<code>capacity()</code>减少到和<code>size()</code>相同大小</td></tr><tr><td><code>c.capacity()</code></td><td>不重新分配内存空间的话，<code>c</code>可以保存多少个元素</td></tr><tr><td><code>c.reverse(n)</code></td><td>分配至少能容纳<code>n</code>个元素的内存空间(预分配，而且如果需求容量小于当前容量，什么都不做)</td></tr></tbody></table><ul><li><code>shrink_to_fit</code>只适用于<code>vector</code>、<code>string</code>和<code>deque</code></li><li><code>capacity</code>和<code>reverse</code>只适用于<code>vector</code>和<code>string</code>。</li></ul><h2 id=95-额外的string操作>9.5 额外的string操作<a hidden class=anchor aria-hidden=true href=#95-额外的string操作>¶</a></h2><h3 id=构造string的其他方法>构造string的其他方法<a hidden class=anchor aria-hidden=true href=#构造string的其他方法>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>string s(cp, n)</code></td><td><code>s</code>是<code>cp</code>指向的数组中前<code>n</code>个字符的拷贝，此数组至少有n个字符</td></tr><tr><td><code>string s(s2, pos2)</code></td><td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符到末尾的拷贝。若<code>pos2 > s2.size()</code>，则构造函数的行为未定义。</td></tr><tr><td><code>string s(s2, pos2, len2)</code></td><td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的<code>len2</code>个字符的拷贝。</td></tr></tbody></table><ul><li>最初的构造函数：直接初始化（圆括号初始化）、迭代器范围初始化、列表初始化</li></ul><h3 id=substr操作>substr操作<a hidden class=anchor aria-hidden=true href=#substr操作>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>s.substr(pos, n)</code></td><td>返回一个<code>string</code>，包含<code>s</code>中从<code>pos</code>开始的<code>n</code>个字符的拷贝。</td></tr></tbody></table><h3 id=改变string的其他方法>改变string的其他方法<a hidden class=anchor aria-hidden=true href=#改变string的其他方法>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>s.insert(pos, args)</code></td><td>在<code>pos</code>之前插入<code>args</code>指定的字符。<code>pos</code>可以使是下标或者迭代器。接受下标的版本返回指向<code>s</code>的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td></tr><tr><td><code>s.erase(pos, len)</code></td><td>删除从<code>pos</code>开始的<code>len</code>个字符，如果<code>len</code>被省略，则删除后面所有字符，返回指向<code>s</code>的引用。</td></tr><tr><td><code>s.assign(args)</code></td><td>将<code>s</code>中的字符替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。（args不变）</td></tr><tr><td><code>s.append(args)</code></td><td>将<code>args</code>指定的字符追加到<code>s</code>，返回一个指向<code>s</code>的引用。</td></tr><tr><td><code>s.replace(range, args)</code></td><td>删除<code>s</code>中范围<code>range</code>中的字符，替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td></tr></tbody></table><h3 id=string搜索操作>string搜索操作<a hidden class=anchor aria-hidden=true href=#string搜索操作>¶</a></h3><ul><li><code>string</code>类提供了6个不同的搜索函数，每个函数都有4个重载版本。</li><li>每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。如果搜索失败则返回一个名为<code>string::npos</code>的<code>static</code>成员（类型是<code>string::size_type</code>，初始化值是-1，也就是<code>string</code>最大的可能大小）。</li></ul><table><thead><tr><th>搜索操作</th><th>解释</th></tr></thead><tbody><tr><td><code>s.find(args)</code></td><td>查找<code>s</code>中<code>args</code>第一次出现的位置</td></tr><tr><td><code>s.rfind(args)</code></td><td>查找<code>s</code>中<code>args</code>最后一次出现的位置</td></tr><tr><td><code>s.find_first_of(args)</code></td><td>在<code>s</code>中查找<code>args</code>中任何一个字符第一次出现的位置</td></tr><tr><td><code>s.find_last_of(args)</code></td><td>在<code>s</code>中查找<code>args</code>中任何一个字符最后一次出现的位置</td></tr><tr><td><code>s.find_first_not_of(args)</code></td><td>在<code>s</code>中查找第一个不在<code>args</code>中的字符</td></tr><tr><td><code>s.find_first_not_of(args)</code></td><td>在<code>s</code>中查找最后一个不在<code>args</code>中的字符</td></tr></tbody></table><p>args必须是一下的形式之一：</p><table><thead><tr><th><code>args</code>形式</th><th>解释</th></tr></thead><tbody><tr><td><code>c, pos</code></td><td>从<code>s</code>中位置<code>pos</code>开始查找字符<code>c</code>。<code>pos</code>默认是0</td></tr><tr><td><code>s2, pos</code></td><td>从<code>s</code>中位置<code>pos</code>开始查找字符串<code>s2</code>。<code>pos</code>默认是0</td></tr><tr><td><code>cp, pos</code></td><td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的以空字符结尾的C风格字符串。<code>pos</code>默认是0</td></tr><tr><td><code>cp, pos, n</code></td><td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的前<code>n</code>个字符。<code>pos</code>和<code>n</code>无默认值。</td></tr></tbody></table><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 使用pos循环查找所有str包含的字符的位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span><span class=o>::</span><span class=n>size_type</span> <span class=n>pos</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>((</span><span class=n>pos</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>find_first_of</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=n>pos</span><span class=p>))</span> <span class=o>!=</span> <span class=n>string</span><span class=o>::</span><span class=n>npos</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>pos</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=o>++</span><span class=n>pos</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=scompare的几种参数形式>s.compare的几种参数形式<a hidden class=anchor aria-hidden=true href=#scompare的几种参数形式>¶</a></h3><p>逻辑类似于C标准库的<code>strcmp</code>函数，根据<code>s</code>是等于、大于还是小于参数指定的字符串，<code>s.compare</code>返回0、正数或负数。</p><table><thead><tr><th>参数形式</th><th>解释</th></tr></thead><tbody><tr><td><code>s2</code></td><td>比较<code>s</code>和<code>s2</code></td></tr><tr><td><code>pos1, n1, s2</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td></tr><tr><td><code>pos1, n1, s2, pos2, n2</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code>从pos2开始的n2个字符</td></tr><tr><td><code>cp</code></td><td>比较<code>s</code>和<code>cp</code>指向的以空字符结尾的字符数组</td></tr><tr><td><code>pos1, n1, cp</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的以空字符结尾的字符数组</td></tr><tr><td><code>pos1, n1, cp, n2</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的地址开始<code>n2</code>个字符</td></tr></tbody></table><h3 id=string和数值转换>string和数值转换<a hidden class=anchor aria-hidden=true href=#string和数值转换>¶</a></h3><table><thead><tr><th>转换</th><th>解释</th></tr></thead><tbody><tr><td><code>to_string(val)</code></td><td>一组重载函数，返回数值<code>val</code>的<code>string</code>表示</td></tr><tr><td><code>stoi(s, p, b)</code></td><td>返回<code>s</code>起始子串（表示整数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0，<code>b</code>是转换所用的基数。返回<code>int</code></td></tr></tbody></table><h2 id=96-容器适配器adapter>9.6 容器适配器（adapter）<a hidden class=anchor aria-hidden=true href=#96-容器适配器adapter>¶</a></h2><ul><li><strong>适配器</strong>是使一事物的行为看起来像另一事物的行为的一种机制，例如<code>stack</code>可以使任何一种顺序容器以栈的方式工作。</li><li>默认情况下，stack和queue是基于deque实现的，priority_queue是基于vector实现的，基础容器不能是array和forward_list<ul><li>因此可以直接使用一个deque来初始化stack和queue，使用一个有序vector初始化priority_queue</li><li>也可以指定实现的顺序容器： <code>stack&lt;string, vector&lt;string> > str_stk;</code></li></ul></li></ul><h3 id=适配器的通用操作和类型>适配器的通用操作和类型<a hidden class=anchor aria-hidden=true href=#适配器的通用操作和类型>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>size_type</code></td><td>一种类型，须以保存当前类型的最大对象的大小</td></tr><tr><td><code>value_type</code></td><td>元素类型</td></tr><tr><td><code>container_type</code></td><td>实现适配器的底层容器类型</td></tr><tr><td><code>A a;</code></td><td>创建一个名为<code>a</code>的空适配器</td></tr><tr><td><code>A a(c)</code></td><td>创建一个名为<code>a</code>的适配器，带有容器<code>c</code>的一个拷贝</td></tr><tr><td>关系运算符</td><td>每个适配器都支持所有关系运算符：<code>==</code>、<code>!=</code>、<code>&lt;</code>、 <code>&lt;=</code>、<code>></code>、<code>>=</code>这些运算符返回底层容器的比较结果</td></tr><tr><td><code>a.empty()</code></td><td>若<code>a</code>包含任何元素，返回<code>false</code>;否则返回<code>true</code></td></tr><tr><td><code>a.size()</code></td><td>返回<code>a</code>中的元素数目</td></tr><tr><td><code>swap(a, b)</code></td><td>交换<code>a</code>和<code>b</code>的内容，<code>a</code>和<code>b</code>必须有相同类型，包括底层容器类型也必须相同</td></tr><tr><td><code>a.swap(b)</code></td><td>同上</td></tr></tbody></table><h3 id=stack>stack<a hidden class=anchor aria-hidden=true href=#stack>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>s.pop()</code></td><td>删除栈顶元素，不返回。</td></tr><tr><td><code>s.push(item)</code></td><td>创建一个新元素，压入栈顶，该元素通过拷贝或移动<code>item</code>而来</td></tr><tr><td><code>s.emplace(args)</code></td><td>同上，但元素由<code>args</code>来构造。</td></tr><tr><td><code>s.top()</code></td><td>返回栈顶元素，不删除。</td></tr></tbody></table><ul><li>定义在<code>stack</code>头文件中。</li><li>stack可以基于deque（默认）、list、vector实现</li></ul><h3 id=queue和priority_queue>queue和priority_queue<a hidden class=anchor aria-hidden=true href=#queue和priority_queue>¶</a></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>q.pop()</code></td><td>删除队首元素，但不返回。</td></tr><tr><td><code>q.front()</code></td><td>返回队首元素的值，不删除。</td></tr><tr><td><code>q.back()</code></td><td>返回队尾元素的值，不删除。只适用于<code>queue</code></td></tr><tr><td><code>q.top()</code></td><td>返回具有最高优先级的元素值，不删除。</td></tr><tr><td><code>q.push(item)</code></td><td>在队尾压入一个新元素。</td></tr><tr><td><code>q.emplace(args)</code></td><td></td></tr></tbody></table><ul><li>定义在<code>queue</code>头文件中。</li><li>queue可以基于deque（默认）、list、vector实现，priority_queue可以基于deque（默认）、vector实现</li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://qinganzhang.github.io/posts/cpp-primer/ch10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Ch10 泛型算法</span>
</a><a class=next href=https://qinganzhang.github.io/posts/cpp-primer/ch08-io%E5%BA%93/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Ch08 IO库</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://qinganzhang.github.io/>Paul's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>