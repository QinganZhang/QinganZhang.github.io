<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ch10 泛型算法 | Paul's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="第十章 泛型算法 10.1 泛型算法 泛型算法本身不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作 必要的编程假定：算法（注意是标准库中的算法"><meta name=author content="Paul"><link rel=canonical href=https://qinganzhang.github.io/posts/cpp-primer/ch10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://qinganzhang.github.io/favicon.ico><link rel=apple-touch-icon href=https://qinganzhang.github.io/apple-touch-icon.png><meta name=twitter:title content="Ch10 泛型算法 | Paul's Blog"><meta name=twitter:description content="第十章 泛型算法 10.1 泛型算法 泛型算法本身不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作 必要的编程假定：算法（注意是标准库中的算法"><meta property="og:title" content="Ch10 泛型算法 | Paul's Blog"><meta property="og:description" content="第十章 泛型算法 10.1 泛型算法 泛型算法本身不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作 必要的编程假定：算法（注意是标准库中的算法"><meta property="og:type" content="article"><meta property="og:url" content="https://qinganzhang.github.io/posts/cpp-primer/ch10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T15:57:36+08:00"><meta property="article:modified_time" content="2024-02-27T15:57:36+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://qinganzhang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Ch10 泛型算法","item":"https://qinganzhang.github.io/posts/cpp-primer/ch10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ch10 泛型算法 | Paul's Blog","name":"Ch10 泛型算法","description":"第十章 泛型算法 10.1 泛型算法 泛型算法本身不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作 必要的编程假定：算法（注意是标准库中的算法","keywords":["cpp"],"wordCount":"5032","inLanguage":"en","datePublished":"2024-02-27T15:57:36+08:00","dateModified":"2024-02-27T15:57:36+08:00","author":{"@type":"Person","name":"Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qinganzhang.github.io/posts/cpp-primer/ch10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"},"publisher":{"@type":"Organization","name":"Paul's Blog","logo":{"@type":"ImageObject","url":"https://qinganzhang.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://qinganzhang.github.io/ accesskey=h title="Paul's Blog (Alt + H)">Paul's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://qinganzhang.github.io/posts/ title=Posts class=active>Posts</a></li><li><a href=https://qinganzhang.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://qinganzhang.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://qinganzhang.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://qinganzhang.github.io/categories/ title=Categories>Categories</a></li><li><a href=https://qinganzhang.github.io/about/ title=About>About</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qinganzhang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://qinganzhang.github.io/posts/>Post</a></div><h1 class=post-title>Ch10 泛型算法</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-02-27</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://qinganzhang.github.io/tags/cpp/>cpp</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>5032 words</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>11 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ac%ac%e5%8d%81%e7%ab%a0-%e6%b3%9b%e5%9e%8b%e7%ae%97%e6%b3%95 aria-label="第十章 泛型算法">第十章 泛型算法</a><ul><li><a href=#101-%e6%b3%9b%e5%9e%8b%e7%ae%97%e6%b3%95 aria-label="10.1 泛型算法">10.1 泛型算法</a></li><li><a href=#102-%e5%88%9d%e8%af%86%e6%b3%9b%e5%9e%8b%e7%ae%97%e6%b3%95 aria-label="10.2 初识泛型算法">10.2 初识泛型算法</a><ul><li><a href=#%e5%8f%aa%e8%af%bb%e7%ae%97%e6%b3%95 aria-label=只读算法>只读算法</a></li><li><a href=#%e5%86%99%e5%ae%b9%e5%99%a8%e5%85%83%e7%b4%a0%e7%9a%84%e7%ae%97%e6%b3%95 aria-label=写容器元素的算法>写容器元素的算法</a></li><li><a href=#%e9%87%8d%e6%8e%92%e5%ae%b9%e5%99%a8%e5%85%83%e7%b4%a0%e7%9a%84%e7%ae%97%e6%b3%95 aria-label=重排容器元素的算法>重排容器元素的算法</a></li></ul></li><li><a href=#103-%e5%ae%9a%e5%88%b6%e6%93%8d%e4%bd%9c aria-label="10.3 定制操作">10.3 定制操作</a><ul><li><a href=#%e5%90%91%e7%ae%97%e6%b3%95%e4%bc%a0%e9%80%92%e5%87%bd%e6%95%b0 aria-label=向算法传递函数>向算法传递函数</a></li><li><a href=#lambda%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=lambda表达式>lambda表达式</a></li><li><a href=#lambda%e6%8d%95%e8%8e%b7%e5%92%8c%e8%bf%94%e5%9b%9e aria-label=lambda捕获和返回>lambda捕获和返回</a></li><li><a href=#%e5%8f%82%e6%95%b0%e7%bb%91%e5%ae%9a aria-label=参数绑定>参数绑定</a></li></ul></li><li><a href=#104-%e5%86%8d%e6%8e%a2%e8%bf%ad%e4%bb%a3%e5%99%a8 aria-label="10.4 再探迭代器">10.4 再探迭代器</a><ul><li><a href=#%e6%8f%92%e5%85%a5%e8%bf%ad%e4%bb%a3%e5%99%a8 aria-label=插入迭代器>插入迭代器</a></li><li><a href=#%e6%b5%81%e8%bf%ad%e4%bb%a3%e5%99%a8 aria-label=流迭代器>流迭代器</a></li><li><a href=#%e5%8f%8d%e5%90%91%e8%bf%ad%e4%bb%a3%e5%99%a8 aria-label=反向迭代器>反向迭代器</a></li><li><a href=#%e7%a7%bb%e5%8a%a8%e8%bf%ad%e4%bb%a3%e5%99%a8 aria-label=移动迭代器>移动迭代器</a></li></ul></li><li><a href=#105-%e6%b3%9b%e5%9e%8b%e7%ae%97%e6%b3%95%e7%bb%93%e6%9e%84 aria-label="10.5 泛型算法结构">10.5 泛型算法结构</a><ul><li><a href=#5%e7%b1%bb%e8%bf%ad%e4%bb%a3%e5%99%a8 aria-label=5类迭代器>5类迭代器</a></li><li><a href=#%e7%ae%97%e6%b3%95%e7%9a%84%e5%bd%a2%e5%8f%82%e6%a8%a1%e5%bc%8f aria-label=算法的形参模式>算法的形参模式</a></li><li><a href=#%e7%ae%97%e6%b3%95%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83 aria-label=算法命名规范>算法命名规范</a></li></ul></li><li><a href=#106-%e7%89%b9%e5%ae%9a%e5%ae%b9%e5%99%a8%e7%ae%97%e6%b3%95 aria-label="10.6 特定容器算法">10.6 特定容器算法</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=第十章-泛型算法>第十章 泛型算法<a hidden class=anchor aria-hidden=true href=#第十章-泛型算法>¶</a></h1><h2 id=101-泛型算法>10.1 泛型算法<a hidden class=anchor aria-hidden=true href=#101-泛型算法>¶</a></h2><ul><li>泛型算法本身不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作</li><li>必要的编程假定：算法（注意是标准库中的算法）永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但<strong>不能直接添加或者删除元素</strong>。</li></ul><h2 id=102-初识泛型算法>10.2 初识泛型算法<a hidden class=anchor aria-hidden=true href=#102-初识泛型算法>¶</a></h2><h3 id=只读算法>只读算法<a hidden class=anchor aria-hidden=true href=#只读算法>¶</a></h3><ul><li>最好使用<code>cbegin</code>和<code>cend</code>。</li><li><code>accumulate</code>函数：计算一个序列的和。序列中的元素必须与第三个元素匹配，或者能转换为第三个参数的类型（accumulate函数是模板函数，类型由第三个参数推导而来，此类型决定了使用哪种加法运算符）</li><li><code>find</code>函数：接受一对迭代器范围和目标查找值，如果找到，则返回对应的迭代器，否则返回尾后迭代器</li><li><code>find_if</code>函数：接受一对迭代器范围和一个谓词，对范围内的每个元素调用给定谓词进行判断，返回第一个使谓词返回非零的元素，否则返回尾后迭代器。</li><li><code>find_first_of</code>，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的<code>end</code>迭代器。</li><li><code>equal</code>：确定两个序列是否保存相同的值。（顺序也相同）</li></ul><h3 id=写容器元素的算法>写容器元素的算法<a hidden class=anchor aria-hidden=true href=#写容器元素的算法>¶</a></h3><ul><li>修改算法<ul><li><code>fill</code>： <code>fill(vec.begin(), vec.end(), 0);</code></li><li><code>fill_n</code>： <code>fill_n(vec.begin(), len, 0);</code></li><li><code>for_each</code>函数：接受一对迭代器和一个谓词，对范围内的每个元素调用谓词</li><li><code>transform</code>函数：接受三个迭代器和一个谓词，前两个迭代器指定一个输入序列的范围，第三个迭代器指定目的位置，它对输入序列中的每个元素调用谓词，并将结果写入到目的位置。</li></ul></li><li>拷贝算法<ul><li><code>copy (src.begin(), src.end(), dst.begin());</code>前两个参数指定输入范围，第三个指向目标序列的起始位置。</li><li><code>replace(src.begin(), src.end(), old, new)</code>：将范围内old替换为new</li><li><code>replace_copy(src.begin(), src.end(), dst.begin(), old, new)</code>：基本同replace，但是保留原范围不变，将替换后的结果保存到dst位置</li><li>很多算法都提供copy版本，不会将新元素放回原序列，而是将结果保存到新序列中</li></ul></li><li><h3 id=重排容器元素的算法>重排容器元素的算法<a hidden class=anchor aria-hidden=true href=#重排容器元素的算法>¶</a></h3></li><li>排序算法<code>sort</code>：接受两个迭代器，利用元素的<code>&lt;</code>运算符重排元素</li><li><code>stable_sort</code></li><li>消除重复<code>unique</code>：之前要先调用<code>sort</code>，返回的迭代器指向最后一个不重复元素之后的位置（最后一个不重复元素的尾后位置）；重复的元素在原来容器的后边，并没有真正删除。</li></ul><h2 id=103-定制操作>10.3 定制操作<a hidden class=anchor aria-hidden=true href=#103-定制操作>¶</a></h2><h3 id=向算法传递函数>向算法传递函数<a hidden class=anchor aria-hidden=true href=#向算法传递函数>¶</a></h3><ul><li><a href=https://blog.csdn.net/caroline_wendy/article/details/15378055>谓词</a>（<code>predicate</code>）：是一个<strong>可调用的表达式</strong>，返回结果是一个能用作条件的值</li><li>接受谓词参数的算法会对输入序列中的元素调用谓词，因此序列的元素类型必须能转换为谓词的参数类型</li><li>可以向算法传递四种可调用对象：函数、函数指针、重载了函数调用运算符的类、lambda表达式</li></ul><h3 id=lambda表达式>lambda表达式<a hidden class=anchor aria-hidden=true href=#lambda表达式>¶</a></h3><ul><li>形式：<code>[capture list](parameter list) -> return type {function body}</code>。<ul><li><code>capture list</code>捕获列表是一个由<code>lambda</code>所在函数定义的局部变量的列表（通常为空）。不可忽略。捕获列表只能用于局部非static变量，lambda表达式可以直接使用局部static变量和所在函数之外声明的名字。</li><li><code>return type</code>是返回类型。可忽略（省略返回类型时，可以由return返回表达式的类型推断而来，否则返回类型为void），必须使用尾置返回。</li><li><code>parameter</code>是参数列表。可忽略（等价于指定空参数列表），不能有默认实参。</li><li><code>function body</code>是函数体。不可忽略。</li></ul></li><li>定义一个lambda表达式时，编译器生成一个与lambda对应的未命名的类类型<ul><li>当向函数传递一个lambda时，传递的参数实际上就是这个未命名类的对象。</li><li>[[ch14-重载运算与类型转换#<code>lambda</code>是函数对象|lambda是函数对象]]</li></ul></li></ul><h3 id=lambda捕获和返回>lambda捕获和返回<a hidden class=anchor aria-hidden=true href=#lambda捕获和返回>¶</a></h3><ul><li>捕获：lambda表达式将局部变量包含在捕获列表中，在捕获列表中的参数可以被lambda函数体所使用，<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=882c973c-544f-77c6-5d3d-ae7c1ecb678a&amp;page=378&amp;rect=238.800,400.080,306.010,407.280">lambda 捕获列表</a><ul><li>值捕获：被值捕获的变量的值是在lambda创建时拷贝，而非调用时拷贝。因此在lambda创建后改变被捕获的变量不会影响lambda中对应的值。</li><li>引用捕获：捕获的变量前加<code>&</code>，此时修改局部变量会影响lambda内对应的值，但是必须确保被引用的对象在 lambda 执行时是存在的。</li></ul></li><li>隐式捕获：不显式列出捕获变量，而是编译器进行推断<ul><li><code>&</code>为引用捕获，<code>=</code>为值捕获</li></ul></li><li>混合显式捕获与隐式捕获<ul><li>此时捕获列表第一个元素必须是<code>&</code>或<code>=</code>，指定默认捕获方式，显式捕获的变量必须使用与隐式捕获不同的方式</li></ul></li><li>可变lambda：默认情况下，通过值捕获得到的变量（的拷贝），lambda无法修改其值，如果希望改变，可以在参数列表后加上<code>mutable</code><ul><li>通过引用捕获的变量，取决于变量是否为const</li></ul></li><li>如果lambda中除了return还有其他语句，此时应该指明返回类型；否则可以省略返回类型</li><li>lambda可以作为函数的返回值，此时lambda不能包含引用捕获。<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span><span class=p>,</span> <span class=n>c</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>g</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>]</span> <span class=p>(</span><span class=kt>int</span> <span class=n>c</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>void</span> <span class=p>{</span><span class=n>b</span><span class=o>+=</span><span class=n>c</span><span class=p>;</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>a</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;};</span> <span class=c1>// 隐式的值捕获(a),显式的引用捕获(b)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>f</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>,</span> <span class=n>b</span><span class=p>]</span> <span class=p>(</span><span class=kt>int</span> <span class=n>c</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>void</span> <span class=p>{</span><span class=n>a</span><span class=o>+=</span><span class=n>c</span><span class=p>;};</span> <span class=c1>// 隐式的引用捕获(a),显式的值捕获(b)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>gg</span> <span class=o>=</span> <span class=p>[</span><span class=o>=</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>]</span> <span class=p>(</span><span class=kt>int</span> <span class=n>c</span><span class=p>)</span> <span class=k>mutable</span> <span class=o>-&gt;</span> <span class=kt>void</span> <span class=p>{</span><span class=n>b</span><span class=o>+=</span><span class=n>c</span><span class=p>;</span> <span class=n>a</span><span class=o>+=</span><span class=n>c</span><span class=p>;</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>a</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>ff</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>,</span> <span class=n>b</span><span class=p>]</span> <span class=p>(</span><span class=kt>int</span> <span class=n>c</span><span class=p>)</span> <span class=k>mutable</span> <span class=o>-&gt;</span> <span class=kt>void</span> <span class=p>{</span><span class=n>b</span><span class=o>+=</span><span class=n>c</span><span class=p>;</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;};</span> 
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=参数绑定>参数绑定<a hidden class=anchor aria-hidden=true href=#参数绑定>¶</a></h3><ul><li>例子：找到vector中第一个大于val的元素，即需要将二元谓词包装成一元谓词，可以使用bind绑定第二个参数<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>isBigger</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>val</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>};</span> <span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it</span> <span class=o>=</span> <span class=n>find_if</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>isBigger</span><span class=p>);</span> <span class=c1>// 错误，find_if只能接受一元谓词，但是isBigger是二元谓词，可以使用bind进行参数绑定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it</span> <span class=o>=</span> <span class=n>find_if</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>bind</span><span class=p>(</span><span class=n>isBigger</span><span class=p>,</span> <span class=n>val</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>placeholders</span><span class=o>::</span><span class=n>_1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>find_if</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[</span><span class=n>val</span><span class=p>]</span> <span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>bool</span> <span class=p>{</span><span class=k>return</span> <span class=n>a</span><span class=o>&lt;</span><span class=n>val</span><span class=p>;};</span> <span class=c1>// 可以使用lambda表达式
</span></span></span></code></pre></td></tr></table></div></div></li><li>标准库<code>bind</code>函数：<code>auto newCallable = bind(callable, arg_list);</code><ul><li>定义在头文件<code>functional</code>中，接受一个可调用对象和一些实参，生成一个新的可调用对象</li><li>我们在调用<code>newCallable</code>的时候，<code>newCallable</code>会调用<code>callable</code>并传递给它<code>arg_list</code>中的参数（将绑定的参数拷贝过去）。</li></ul></li><li>参数绑定和重排：<code>std::placeholder::_n</code>表示将<code>newCallable</code>的第n个参数放在占位符<code>_n</code>的位置</li><li>绑定引用参数：<ul><li><code>ref</code>函数接受一个参数，返回一个可以拷贝的对象，该对象含有参数的引用。</li><li><code>cref</code>返回const的引用</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>show</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>,</span> <span class=kt>int</span> <span class=n>c</span><span class=p>,</span> <span class=kt>int</span> <span class=n>d</span><span class=p>,</span> <span class=kt>int</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>a</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>c</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>d</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>e</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>out</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>os</span><span class=p>,</span> <span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>,</span> <span class=kt>int</span> <span class=n>c</span><span class=p>,</span> <span class=kt>int</span> <span class=n>d</span><span class=p>,</span> <span class=kt>int</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span><span class=n>os</span><span class=o>&lt;&lt;</span><span class=n>a</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>b</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>c</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>d</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>e</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span><span class=p>,</span> <span class=n>c</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span> <span class=n>d</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=n>e</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>g</span> <span class=o>=</span> <span class=n>bind</span><span class=p>(</span><span class=n>show</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>placeholders</span><span class=o>::</span><span class=n>_2</span><span class=p>,</span> <span class=n>d</span><span class=p>,</span> <span class=n>placeholders</span><span class=o>::</span><span class=n>_1</span><span class=p>);</span> <span class=c1>// 将g的第一个参数放到placeholders::_1的位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>h</span> <span class=o>=</span> <span class=n>bind</span><span class=p>(</span><span class=n>show</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>placeholders</span><span class=o>::</span><span class=n>_1</span><span class=p>,</span> <span class=n>d</span><span class=p>,</span> <span class=n>placeholders</span><span class=o>::</span><span class=n>_2</span><span class=p>);</span> <span class=c1>// 重排参数顺序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>g</span><span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span> <span class=c1>// 将e放到placeholders::_1的位置，将c放到placeholders::_2的位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>h</span><span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span> <span class=c1>// show(a, b, _1, d, _2), 其中_1是e，_2是c
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span> <span class=o>=</span> <span class=n>cout</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>f</span> <span class=o>=</span> <span class=n>bind</span><span class=p>(</span><span class=n>out</span><span class=p>,</span> <span class=n>ref</span><span class=p>(</span><span class=n>os</span><span class=p>),</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>placeholders</span><span class=o>::</span><span class=n>_2</span><span class=p>,</span> <span class=n>d</span><span class=p>,</span> <span class=n>placeholders</span><span class=o>::</span><span class=n>_1</span><span class=p>);</span> <span class=c1>// 绑定引用参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>f</span><span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>    
</span></span></code></pre></td></tr></table></div></div><h2 id=104-再探迭代器>10.4 再探迭代器<a hidden class=anchor aria-hidden=true href=#104-再探迭代器>¶</a></h2><h3 id=插入迭代器>插入迭代器<a hidden class=anchor aria-hidden=true href=#插入迭代器>¶</a></h3><ul><li>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素，定义在头文件iterator中<ul><li><code>back_inserter</code>：创建一个调用<code>push_back</code>操作的迭代器。<ul><li><code>back_inserter</code>是插入器，<code>back_insert_iterator&lt;vector&lt;int>></code>是插入迭代器类型</li></ul></li><li><code>front_inserter</code>创建一个调用<code>push_front</code>操作的迭代器。</li><li><code>inserter</code>创建一个调用<code>insert</code>操作的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被插入到迭代器所指向的元素之前。<ul><li>随着插入过程，inserter永远指向指定的元素，而不是永远指向某个特定的位置</li></ul></li></ul></li><li>每向插入器赋值一次就相当于调用一次相关操作，<code>*it, ++it, it++</code>等操作虽然存在，但不会有任何作用（仍返回it）</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>deque</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>back_insert_iterator</span><span class=o>&lt;</span><span class=n>deque</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>biter</span> <span class=o>=</span> <span class=n>back_inserter</span><span class=p>(</span><span class=n>v</span><span class=p>);</span> <span class=c1>// 相当于永远指向尾后位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>front_insert_iterator</span><span class=o>&lt;</span><span class=n>deque</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>fiter</span> <span class=o>=</span> <span class=n>front_inserter</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 每赋值一次就相当于调用一次相关操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>biter</span> <span class=o>=</span> <span class=mi>6</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=n>biter</span> <span class=o>=</span> <span class=mi>7</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fiter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fiter</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>for_each</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[]</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>void</span> <span class=p>{</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>i</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=p>;});</span>  
</span></span></code></pre></td></tr></table></div></div><h3 id=流迭代器>流迭代器<a hidden class=anchor aria-hidden=true href=#流迭代器>¶</a></h3><ul><li>流迭代器将对应的流当作一个特定类型的元素序列来处理<ul><li><code>istream_iterator</code>：读取输入流<ul><li>可以不绑定到流，相当于尾后迭代器</li><li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=636cee62-4cbc-5f60-573a-a6e6aeb138c7&amp;page=386&amp;rect=230.650,377.520,312.490,384.480">istream_iterator 操作</a>：没有赋值操作，解引用操作相当于返回输入流中读取的值，需要递增操作</li><li><code>istream_iterator</code>允许使用懒惰求值，即标准库不保证迭代器可以立即从输入流中获取数据，但是保证迭代器第一次解引用操作之前，从流中读取数据的操作已经完成。</li></ul></li><li><code>ostream_iterator</code>：向输出流中写入数据<ul><li><code>ostream_iterator</code>必须绑定到一个指定的流，不允许空的或者尾后位置</li><li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=eccda81b-26b3-f633-d17a-d366513c237b&amp;page=387&amp;rect=216.870,462.809,302.170,472.183">ostream_iterator 操作</a>：赋值操作相当于输出流的输出操作，递增、解引用操作没有意义</li><li>向ostream_iterator赋值时，可以省略解引用和递增运算（实际上解引用和递增操作不会对ostream_iterator做任何事情）。但是不推荐省略，可以保持迭代器行为的一致性，便于修改。</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>istream_iterator</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>int_iter</span><span class=p>(</span><span class=n>cin</span><span class=p>);</span> <span class=c1>// 可以将流迭代器绑定到一个流（输入流读取操作 就相当于 从流迭代器中取出值，流迭代器累加），
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>istream_iterator</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>int_eof</span><span class=p>;</span> <span class=c1>// 默认初始化相当于尾后迭代器或eof
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ostream_iterator</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>out_iter</span><span class=p>(</span><span class=n>cout</span><span class=p>,</span> <span class=s>&#34; &#34;</span><span class=p>);</span> <span class=c1>// 必须将ostream_iterator绑定到一个指定的流, 每个值后面跟着一个C风格字符串str
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 原始方式，注意输入时Ctrl+Z表示eof
</span></span></span><span class=line><span class=cl><span class=c1>// vector&lt;int&gt; v;
</span></span></span><span class=line><span class=cl><span class=c1>// for(; int_iter != int_eof; ++int_iter){
</span></span></span><span class=line><span class=cl><span class=c1>//     v.push_back(*int_iter);
</span></span></span><span class=line><span class=cl><span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>(</span><span class=n>int_iter</span><span class=p>,</span> <span class=n>int_eof</span><span class=p>);</span> <span class=c1>// 等价方式，更能体现流迭代器的特点
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// for(int i: v){
</span></span></span><span class=line><span class=cl><span class=c1>//     *(out_iter++) = i; // 原始方式（先后置递增，返回旧值，再解引用），但是更推荐
</span></span></span><span class=line><span class=cl><span class=c1>//     // out_iter = i; // 等价方式，更简略
</span></span></span><span class=line><span class=cl><span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>copy</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>out_iter</span><span class=p>);</span> <span class=c1>// 最简单的写法，将序列范围直接复制到输出迭代器中
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// copy(int_iter, int_eof, out_iter); // 直接将输入进行输出  
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=反向迭代器>反向迭代器<a hidden class=anchor aria-hidden=true href=#反向迭代器>¶</a></h3><ul><li>递增会移动到前一个元素</li><li>调用反向迭代器的base函数可以获得其对应的正向迭代器<ul><li>rbegin()指向的是最后一个元素，而end()指向的是尾后元素；对应的，【反向迭代器】与【其调用base函数得到的正向迭代器】的关系类似于rbegin()与end()，指向的不是相同元素。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=e161d353-c64d-530c-5ed0-8bbc3f7bbdd0&amp;page=389&amp;rect=76.800,427.920,341.280,435.600">图示</a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>reverse_iterator</span> <span class=n>riter</span> <span class=o>=</span> <span class=n>v</span><span class=p>.</span><span class=n>rbegin</span><span class=p>();</span> <span class=c1>// 5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=c1>// 尾后位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=o>&lt;&lt;*</span><span class=n>riter</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;*</span><span class=p>(</span><span class=o>--</span><span class=n>iter</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// 5 5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=o>&lt;&lt;*</span><span class=p>(</span><span class=o>++</span><span class=n>riter</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;*</span><span class=n>riter</span><span class=p>.</span><span class=n>base</span><span class=p>()</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// 4 5  
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><h3 id=移动迭代器>移动迭代器<a hidden class=anchor aria-hidden=true href=#移动迭代器>¶</a></h3><h2 id=105-泛型算法结构>10.5 泛型算法结构<a hidden class=anchor aria-hidden=true href=#105-泛型算法结构>¶</a></h2><h3 id=5类迭代器>5类迭代器<a hidden class=anchor aria-hidden=true href=#5类迭代器>¶</a></h3><ul><li>算法所要求的迭代器操作可以分为 5 类，C++ 标准指明了泛型算法的每个迭代器参数的最小类别。</li><li><code>vector&lt;int>::iterator</code>迭代器是随机访问迭代器，<code>list&lt;int>::iteraotr</code>迭代器是双向迭代器</li></ul><table><thead><tr><th style=text-align:center>迭代器类别</th><th style=text-align:center>解释</th><th style=text-align:center>支持的操作</th></tr></thead><tbody><tr><td style=text-align:center>输入迭代器</td><td style=text-align:center>只读，不写；单遍扫描，只能递增</td><td style=text-align:center><code>==</code>,<code>!=</code>,<code>++</code>,<code>*</code>,<code>-></code></td></tr><tr><td style=text-align:center>输出迭代器</td><td style=text-align:center>只写，不读；单遍扫描，只能递增</td><td style=text-align:center><code>++</code>,<code>*</code></td></tr><tr><td style=text-align:center>前向迭代器</td><td style=text-align:center>可读写；多遍扫描，只能递增</td><td style=text-align:center><code>==</code>,<code>!=</code>,<code>++</code>,<code>*</code>,<code>-></code></td></tr><tr><td style=text-align:center>双向迭代器</td><td style=text-align:center>可读写；多遍扫描，可递增递减</td><td style=text-align:center><code>==</code>,<code>!=</code>,<code>++</code>,<code>--</code>,<code>*</code>,<code>-></code></td></tr><tr><td style=text-align:center>随机访问迭代器</td><td style=text-align:center>可读写，多遍扫描，支持全部迭代器运算</td><td style=text-align:center><code>==</code>,<code>!=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>></code>,<code>>=</code>,<code>++</code>,<code>--</code>,<code>+</code>,<code>+=</code>,<code>-</code>,<code>-=</code>,<code>*</code>,<code>-></code>,<code>iter[n]</code>==<code>*(iter[n])</code></td></tr></tbody></table><h3 id=算法的形参模式>算法的形参模式<a hidden class=anchor aria-hidden=true href=#算法的形参模式>¶</a></h3><ul><li><code>alg(beg, end, other args);</code></li><li><code>alg(beg, end, dest, other args);</code></li><li><code>alg(beg, end, beg2, other args);</code></li><li><code>alg(beg, end, beg2, end2, other args);</code>
其中，<code>alg</code>是算法名称，<code>beg</code>和<code>end</code>表示算法所操作的输入范围。<code>dest</code>表示输出范围或输出流迭代器，<code>beg2</code>、<code>end2</code>表示第二个输入范围</li></ul><h3 id=算法命名规范>算法命名规范<a hidden class=anchor aria-hidden=true href=#算法命名规范>¶</a></h3><ul><li>一些算法使用重载形式传递一个谓词，来代替<code>&lt;</code>或<code>==</code>，比如sort</li><li>接受谓词参数的算法都有附加的<code>_if</code>后缀，没有的一般都是接受元素值</li><li>将执行结果写入额外目的空间的算法都有<code>_copy</code>后缀（即拷贝版本）</li></ul><h2 id=106-特定容器算法>10.6 特定容器算法<a hidden class=anchor aria-hidden=true href=#106-特定容器算法>¶</a></h2><ul><li>对于<code>list</code>和<code>forward_list</code>，优先使用【成员函数版本的算法】而不是通用算法。</li><li>list和forward_list成员函数版本的算法：</li></ul><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>lst.merge(lst2)</code></td><td>将来自<code>lst2</code>的元素合并入<code>lst</code>，二者都必须是有序的，元素将从<code>lst2</code>中删除。</td></tr><tr><td><code>lst.merge(lst2, comp)</code></td><td>同上，给定比较操作。</td></tr><tr><td><code>lst.remove(val)</code></td><td>调用<code>erase</code>删除掉与给定值相等(<code>==</code>)的每个元素</td></tr><tr><td><code>lst.remove_if(pred)</code></td><td>调用<code>erase</code>删除掉令一元谓词为真的每个元素</td></tr><tr><td><code>lst.reverse()</code></td><td>反转<code>lst</code>中元素的顺序</td></tr><tr><td><code>lst.sort()</code></td><td>使用<code>&lt;</code>排序元素</td></tr><tr><td><code>lst.sort(comp)</code></td><td>使用给定比较操作排序元素</td></tr><tr><td><code>lst.unique()</code></td><td>调用<code>erase</code>删除同一个值的连续拷贝。使用<code>==</code>。</td></tr><tr><td><code>lst.unique(pred)</code></td><td>调用<code>erase</code>删除同一个值的连续拷贝。使用给定的二元谓词。</td></tr></tbody></table><ul><li>上面的操作都返回<code>void</code></li><li>链表特有版本的算法操作会改变底层容器<ul><li>list和forward_list的splice函数可以进行容器合并，使用<code>lst.splice(args)</code>或<code>flst.splice_after(args)</code></li></ul></li></ul><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td><code>(p, lst2)</code></td><td><code>p</code>是一个指向<code>lst</code>中元素的迭代器，或者一个指向<code>flst</code>首前位置的迭代器。函数将<code>lst2</code>中的所有元素移动到<code>lst</code>中<code>p</code>之前的位置或是<code>flst</code>中<code>p</code>之后的位置。将元素从<code>lst2</code>中删除。<code>lst2</code>的类型必须和<code>lst</code>相同，而且不能是同一个链表。</td></tr><tr><td><code>(p, lst2, p2)</code></td><td>同上，<code>p2</code>是一个指向<code>lst2</code>中位置的有效的迭代器，将<code>p2</code>指向的元素移动到<code>lst</code>中，或将<code>p2</code>之后的元素移动到<code>flst</code>中。<code>lst2</code>可以是与<code>lst</code>或<code>flst</code>相同的链表。</td></tr><tr><td><code>(p, lst2, b, e)</code></td><td><code>b</code>和<code>e</code>表示<code>lst2</code>中的合法范围。将给定范围中的元素从<code>lst2</code>移动到<code>lst</code>或<code>first</code>中。<code>lst2</code>与<code>lst</code>可以使相同的链表，但<code>p</code>不能指向给定范围中的元素。</td></tr></tbody></table></div><footer class=post-footer><nav class=paginav><a class=prev href=https://qinganzhang.github.io/posts/cpp-primer/ch11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Ch11 关联容器</span>
</a><a class=next href=https://qinganzhang.github.io/posts/cpp-primer/ch09-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Ch09 顺序容器</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://qinganzhang.github.io/>Paul's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>