<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ch15 面向对象程序设计 | Paul's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="第十五章 面向对象程序设计 OOP的核心思想是多态性（polymorphism）。 多态即具有继承关系的多个类型 引用或指针的静态类型与动态类型不同"><meta name=author content="Paul"><link rel=canonical href=https://qinganzhang.github.io/posts/cpp-primer/ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://qinganzhang.github.io/favicon.ico><link rel=apple-touch-icon href=https://qinganzhang.github.io/apple-touch-icon.png><meta name=twitter:title content="Ch15 面向对象程序设计 | Paul's Blog"><meta name=twitter:description content="第十五章 面向对象程序设计 OOP的核心思想是多态性（polymorphism）。 多态即具有继承关系的多个类型 引用或指针的静态类型与动态类型不同"><meta property="og:title" content="Ch15 面向对象程序设计 | Paul's Blog"><meta property="og:description" content="第十五章 面向对象程序设计 OOP的核心思想是多态性（polymorphism）。 多态即具有继承关系的多个类型 引用或指针的静态类型与动态类型不同"><meta property="og:type" content="article"><meta property="og:url" content="https://qinganzhang.github.io/posts/cpp-primer/ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T15:58:30+08:00"><meta property="article:modified_time" content="2024-02-27T15:58:30+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://qinganzhang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Ch15 面向对象程序设计","item":"https://qinganzhang.github.io/posts/cpp-primer/ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ch15 面向对象程序设计 | Paul's Blog","name":"Ch15 面向对象程序设计","description":"第十五章 面向对象程序设计 OOP的核心思想是多态性（polymorphism）。 多态即具有继承关系的多个类型 引用或指针的静态类型与动态类型不同","keywords":["cpp"],"wordCount":"7015","inLanguage":"en","datePublished":"2024-02-27T15:58:30+08:00","dateModified":"2024-02-27T15:58:30+08:00","author":{"@type":"Person","name":"Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qinganzhang.github.io/posts/cpp-primer/ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},"publisher":{"@type":"Organization","name":"Paul's Blog","logo":{"@type":"ImageObject","url":"https://qinganzhang.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://qinganzhang.github.io/ accesskey=h title="Paul's Blog (Alt + H)">Paul's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://qinganzhang.github.io/posts/ title=Posts class=active>Posts</a></li><li><a href=https://qinganzhang.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://qinganzhang.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://qinganzhang.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://qinganzhang.github.io/categories/ title=Categories>Categories</a></li><li><a href=https://qinganzhang.github.io/about/ title=About>About</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qinganzhang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://qinganzhang.github.io/posts/>Post</a></div><h1 class=post-title>Ch15 面向对象程序设计</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-02-27</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://qinganzhang.github.io/tags/cpp/>cpp</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>7015 words</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>15 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ac%ac%e5%8d%81%e4%ba%94%e7%ab%a0-%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1 aria-label="第十五章 面向对象程序设计">第十五章 面向对象程序设计</a><ul><li><a href=#151-oop%e6%a6%82%e8%bf%b0 aria-label="15.1 OOP：概述">15.1 OOP：概述</a></li><li><a href=#152-%e5%ae%9a%e4%b9%89%e5%9f%ba%e7%b1%bb%e5%92%8c%e6%b4%be%e7%94%9f%e7%b1%bb aria-label="15.2 定义基类和派生类">15.2 定义基类和派生类</a><ul><li><a href=#%e5%ae%9a%e4%b9%89%e5%9f%ba%e7%b1%bb aria-label=定义基类>定义基类</a></li><li><a href=#%e5%ae%9a%e4%b9%89%e6%b4%be%e7%94%9f%e7%b1%bb aria-label=定义派生类>定义派生类</a></li><li><a href=#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e4%b8%8e%e7%bb%a7%e6%89%bf aria-label=类型转换与继承>类型转换与继承</a></li></ul></li><li><a href=#153-%e8%99%9a%e5%87%bd%e6%95%b0 aria-label="15.3 虚函数">15.3 虚函数</a></li><li><a href=#154-%e6%8a%bd%e8%b1%a1%e5%9f%ba%e7%b1%bb aria-label="15.4 抽象基类">15.4 抽象基类</a></li><li><a href=#155-%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e4%b8%8e%e7%bb%a7%e6%89%bf aria-label="15.5 访问控制与继承">15.5 访问控制与继承</a></li><li><a href=#156-%e7%bb%a7%e6%89%bf%e4%b8%ad%e7%9a%84%e7%b1%bb%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label="15.6 继承中的类作用域">15.6 继承中的类作用域</a></li><li><a href=#157-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%8e%e6%8b%b7%e8%b4%9d%e6%8e%a7%e5%88%b6 aria-label="15.7 构造函数与拷贝控制">15.7 构造函数与拷贝控制</a><ul><li><a href=#%e8%99%9a%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0 aria-label=虚析构函数>虚析构函数</a></li><li><a href=#%e5%90%88%e6%88%90%e7%9a%84%e6%8b%b7%e8%b4%9d%e6%8e%a7%e5%88%b6%e4%b8%8e%e7%bb%a7%e6%89%bf aria-label=合成的拷贝控制与继承>合成的拷贝控制与继承</a></li><li><a href=#%e6%b4%be%e7%94%9f%e7%b1%bb%e7%9a%84%e6%8b%b7%e8%b4%9d%e6%8e%a7%e5%88%b6%e6%88%90%e5%91%98 aria-label=派生类的拷贝控制成员>派生类的拷贝控制成员</a></li><li><a href=#%e7%bb%a7%e6%89%bf%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=继承的构造函数>继承的构造函数</a></li></ul></li><li><a href=#158-%e5%ae%b9%e5%99%a8%e4%b8%8e%e7%bb%a7%e6%89%bf aria-label="15.8 容器与继承">15.8 容器与继承</a></li><li><a href=#159-%e6%96%87%e6%9c%ac%e6%9f%a5%e8%af%a2%e7%a8%8b%e5%ba%8f%e5%86%8d%e6%8e%a2 aria-label="15.9 文本查询程序再探">15.9 文本查询程序再探</a><ul><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=面向对象的解决方案>面向对象的解决方案</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=第十五章-面向对象程序设计>第十五章 面向对象程序设计<a hidden class=anchor aria-hidden=true href=#第十五章-面向对象程序设计>¶</a></h1><p>OOP的核心思想是多态性（polymorphism）。</p><ul><li>多态即具有继承关系的多个类型</li><li>引用或指针的静态类型与动态类型不同是C++支持多态的根本</li></ul><p>本章内容：</p><ul><li>基类与派生类语法及其类型转换</li><li>虚函数、纯虚函数、抽象基类</li><li>访问控制：成员访问控制、派生访问控制、using声明</li><li>继承过程中的函数解析和作用域</li><li>继承过程中的构造函数和（合成）拷贝控制成员</li></ul><h2 id=151-oop概述>15.1 OOP：概述<a hidden class=anchor aria-hidden=true href=#151-oop概述>¶</a></h2><ul><li>基类，派生类、类派生列表</li><li>[[ch15-面向对象程序设计#15.3 虚函数|虚函数]]：基类将函数声明为虚函数，派生类定义适合自己的版本</li><li><strong>动态绑定</strong>（dynamic binding，又称运行时绑定）：<ul><li>使用基类的引用或指针调用一个虚函数时将发生动态绑定（即在运行时，根据传入参数的类型选择函数版本）</li></ul></li></ul><h2 id=152-定义基类和派生类>15.2 定义基类和派生类<a hidden class=anchor aria-hidden=true href=#152-定义基类和派生类>¶</a></h2><h3 id=定义基类>定义基类<a hidden class=anchor aria-hidden=true href=#定义基类>¶</a></h3><ul><li>如果函数希望被派生类覆盖，则基类将其定义为虚函数；否则基类中的函数希望派生类直接继承而且不要改变</li><li>基类中的虚函数 ^ae3c55<ul><li>基类通常都应该定义一个【虚析构函数】，即使该函数不执行任何实际操作。</li><li>除构造函数之外的任何非静态函数都可以定义为虚函数</li><li>如果基类把一个函数声明为虚函数，则该函数在派生类中隐式的也是虚函数</li></ul></li><li>[[ch15-面向对象程序设计#^8deb68|访问控制]]</li></ul><h3 id=定义派生类>定义派生类<a hidden class=anchor aria-hidden=true href=#定义派生类>¶</a></h3><ul><li>【类派生列表中的访问说明符】用于控制【派生类从基类继承而来的成员】是否【对派生类的对象】可见<ul><li>派生类必须将继承而来的成员函数中需要覆盖的那些重新声明</li><li>如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分，因此可以将派生类类型的对象绑定到基类的指针或引用上</li></ul></li><li>派生类中的虚函数 ^91e48b<ul><li>如果派生类没有覆盖基类中的某个虚函数，则派生类会直接继承其在基类中的版本</li><li>派生类必须在其内部对所有重新定义的虚函数进行声明，virtual关键字可加可不加</li><li>派生类中覆盖虚函数时，形参类型和返回值类型必须相同<ul><li>返回值不相同只有一个例外：虚函数返回类型是类本身的指针或引用，比如类Base派生出类Derived，则基类Base的虚函数返回值可以返回<code>*Base</code>，而派生类Derived中覆盖的虚函数可以返回<code>*Derived</code></li></ul></li><li>C++11使用<code>override</code>显式指明重新定义虚函数（<code>override</code>放在引用限定符之后）</li></ul></li><li>派生类到基类的类型转换<ul><li>基类与派生类之间的[[#类型转换与继承]]</li><li>[[ch15-面向对象程序设计#^ec492b|派生类向基类转换的可访问性]]</li></ul></li><li>派生类构造函数：每个类控制自己的成员初始化过程<ul><li>派生类必须使用【基类的构造函数】来初始化它的基类部分，【派生类的构造函数】通过【[[ch07-类#^742596|构造函数初始值列表]]】来将实参传递给【基类构造函数】，同时在【构造函数初始值列表】初始化自己的数据成员</li><li>遵循基类的接口，尽管从语法上可以在派生类中给基类的公有成员直接进行赋值</li><li>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化</li><li>顺序：先初始化基类部分，在按声明顺序依次初始化派生类的成员</li></ul></li><li>静态成员<ul><li>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一实例。</li><li>静态成员遵循通用的访问控制规则</li></ul></li><li>派生类的声明中不包含它的派生列表，派生列表必须于派生类的定义一起出现</li><li>如果想用某个类作为基类，该类必须已经定义而非仅仅声明<ul><li>一个类不能派生它本身</li><li>直接基类与间接基类：派生类构造函数只初始化它的直接基类</li></ul></li><li>防止继承：在类名后面跟一个关键字<code>final</code>。<ul><li>final关键字除了防止继承，还可以防止函数被覆盖</li></ul></li></ul><h3 id=类型转换与继承>类型转换与继承<a hidden class=anchor aria-hidden=true href=#类型转换与继承>¶</a></h3><ul><li>可以将【指向基类的指针/引用】绑定到派生类对象上，因此【指向基类的指针/引用】的静态类型与动态类型可能不一致<ul><li>静态类型：变量或表达式类型在编译时已知</li><li>动态类型：变量或表达式类型在运行时才可知，是指针指向的内存中对象的类型</li></ul></li><li>编译器自动将【指向派生类的指针/引用】转换为【指向基类的指针/引用】</li><li>不存在【指向基类的指针/引用】隐式转换到【指向派生类的指针/引用】<ul><li>除了使用强制类型转换：使用<code>dynamic_cast</code>，将【指向基类的指针/引用】安全的转换成【指向派生类的指针/引用】，将在运行期进行安全检查</li><li>如果已知某个基类到派生类的转换是安全的，可以使用<code>static_cast</code>强制覆盖掉编译器的检查工作</li></ul></li><li>派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。<ul><li>如果表达式不是引用/指针，则它的静态类型与动态类型永远一致</li><li>有时确实希望将派生类对象转换成基类类型，派生类的部分被切掉(sliced down)了</li></ul></li></ul><h2 id=153-虚函数>15.3 虚函数<a hidden class=anchor aria-hidden=true href=#153-虚函数>¶</a></h2><ul><li>[[ch15-面向对象程序设计#^ae3c55|基类中的虚函数]]</li><li>[[ch15-面向对象程序设计#^91e48b|派生类中的虚函数]]</li><li>virtual关键字只能出现在类内部的声明语句，而不能用于类外部的函数定义</li><li>必须为每一个虚函数提供定义，不管是否被用到（因为编译器也无法确定哪个虚函数会被使用）</li><li>默认实参<ul><li>如果虚函数中有默认实参，则默认实参的值由本次调用的指针/引用的静态类型决定</li><li>因此可能使用的是基类中的默认实参，但是实际运行的是派生类的虚函数版本</li><li>最好基类和派生类中的默认实参一致</li></ul></li><li>回避虚函数：对虚函数的调用不要进行动态绑定，而强迫执行虚函数的某个版本<ul><li>使用<strong>作用域运算符</strong>（<code>::</code>）来回避虚函数</li><li>通常，只有成员函数（或友元）中才需要使用使用回避虚函数的机制，比如一个派生类的虚函数调用它覆盖的基类的虚函数版本（如果不使用回避机制，在运行时该调用将被解析为派生类版本自身的调用，导致无限循环递归）</li><li>例子：<code>Derived* p = Derived(); p->Base::func();</code></li></ul></li></ul><h2 id=154-抽象基类>15.4 抽象基类<a hidden class=anchor aria-hidden=true href=#154-抽象基类>¶</a></h2><ul><li>纯虚函数：一个没有意义的虚函数<ul><li>纯虚函数无需定义，或者也可以提供定义，但是函数体必须定义在类的外部</li><li>声明时末尾加上<code>=0</code>将函数声明为纯虚函数，且只能出现在类内部的函数声明中</li></ul></li><li>抽象基类<ul><li>含有（或未经覆盖直接继承）纯虚函数的类<ul><li>如果派生类不覆盖抽象基类中的纯虚函数，则该派生类仍然是抽象基类</li></ul></li><li>抽象基类负责定义接口，后续的其他类可以覆盖该接口</li><li>不能创建抽象基类的对象。</li></ul></li></ul><h2 id=155-访问控制与继承>15.5 访问控制与继承<a hidden class=anchor aria-hidden=true href=#155-访问控制与继承>¶</a></h2><ul><li>派生类中继承而来的成员的访问权限受到两个因素影响：基类中成员的访问控制（<strong>成员访问说明符</strong>）、类派生列表中的访问控制（<strong>派生访问说明符</strong>）<ul><li>基类中成员的访问控制 ^8deb68<ul><li><code>public</code>：基类本身、派生类、友元、类对象都可以访问</li><li><code>protected</code> ： 基类本身、派生类、友元可以访问，类对象无法访问<ul><li>派生类和友元可以通过派生类对象访问基类的protected成员，但是不能直接通过基类对象来访问。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=af2c58f1-ba76-b811-d0dc-29291dabce5c&amp;page=569&amp;rect=166.478,559.210,246.731,566.890">例子</a>。</li></ul></li><li><code>private</code> ： 基类本身、友元可以访问，其他都无法访问</li></ul></li><li>类派生列表中的访问控制：基类中public/protected的成员，在派生类中的访问说明符<ul><li>如果继承是public的，则成员遵循原来的访问说明符</li><li>如果继承是private的，则派生类中【从基类中继承而来的成员】是private的</li><li>如果继承是protected的，则派生类中【从基类中继承而来的成员】是protected的</li></ul></li></ul></li><li>派生类向基类转换的可访问性 ^ec492b<ul><li>总体原则：对于继承树中的某个节点，如果基类的共有成员是可以访问的，则派生类可以向基类进行类型转换；反之则不行。<a href=https://blog.csdn.net/monster_acm/article/details/81200777>示例说明</a>。</li><li>只有当继承是public的时，派生类才能转换到基类（基类指针指向派生类对象）</li><li>不管D以什么方式继承B，【D的成员函数和友元函数】中【派生类D可以转换到直接基类B】</li><li>如果D继承B的方式是public的或protected的，则【D派生类的成员和友元】可以使用【D向B的类型转换】；反之如果是私有的，则不能使用</li></ul></li><li>友元关系是单向的，不具有传递性，且不能继承<ul><li>如果Pal是基类Base的友元，则Pal可以访问Base的对象的成员和派生类Derived中属于Base部分的成员</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=k>class</span> <span class=nc>Pal</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>protected_val</span><span class=p>;</span> <span class=c1>// 每个类负责控制自己成员的访问权限，protected_val访问权限由Base控制（即使Base是内嵌在派生类对象中）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=k>class</span> <span class=nc>PPal</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>de_protected_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Pal</span><span class=p>{</span> <span class=c1>// 基类的友元
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>f</span><span class=p>(</span><span class=n>Derived</span> <span class=n>d</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=n>d</span><span class=p>.</span><span class=n>protected_val</span><span class=p>;}</span> <span class=c1>// protected_val的访问控制权限由Baes控制，这种可访问性包括了Base对象内嵌在其派生类对象中的情况
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>g</span><span class=p>(</span><span class=n>Derived</span> <span class=n>d</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=n>d</span><span class=p>.</span><span class=n>de_protected_val</span><span class=p>;}</span> <span class=c1>// error: 基类的友元不能随便访问派生类的成员
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DPal</span><span class=o>:</span> <span class=k>public</span> <span class=n>Pal</span><span class=p>{</span> <span class=c1>// 【基类友元】的派生类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>k</span><span class=p>(</span><span class=n>Derived</span> <span class=n>d</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=n>d</span><span class=p>.</span><span class=n>protected_val</span><span class=p>;}</span> <span class=c1>// error：友元关系不能继承
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PPal</span><span class=p>{</span> <span class=c1>// 派生类的友元
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>h</span><span class=p>(</span><span class=n>Derived</span> <span class=n>d</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=n>d</span><span class=p>.</span><span class=n>protected_val</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li><li>改变派生类个别成员的可访问性：使用<code>using</code>。 ^f2ba1c<ul><li>将基类的public/protected成员使用using进行标记，放在派生类public/protected/private的位置，就获得了相应的访问级别</li><li>派生类只能针对基类的public/protected成员使用using声明改变可访问性（因为派生类无法访问基类的private成员）</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>pub_func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nf>pub_func</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>pro</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>pri</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>private</span> <span class=n>Base</span><span class=p>{</span> <span class=c1>// Derived中从基类Base中继承而来的成员默认都是private的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>Base</span><span class=o>::</span><span class=n>pub_func</span><span class=p>;</span> <span class=c1>// 使用using声明，两个重载的pub_func现在都被添加，都是public的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>Base</span><span class=o>::</span><span class=n>pro</span><span class=p>;</span> <span class=c1>// 使用using声明，pro现在是protected的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 派生类无法访问到基类的private成员    
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><code>class</code>与<code>struct</code><ul><li>默认使用<code>clas</code>定义的类成员是private的，使用<code>struct</code>定义的类成员是public的</li><li>默认使用<code>class</code>定义的派生类是私有继承的，使用<code>struct</code>定义的派生类是公有继承的。</li><li>除此之外再无不同</li></ul></li></ul><h2 id=156-继承中的类作用域>15.6 继承中的类作用域<a hidden class=anchor aria-hidden=true href=#156-继承中的类作用域>¶</a></h2><ul><li>派生类的作用域嵌套在其基类的作用域之内</li><li>函数调用的解析过程：<code>p->mem()</code>或者<code>obj.mem()</code><ol><li>确定p或obj的静态类型</li><li>名字查找：在该静态类型对应的类中查找mem，如果找不到，则依次在直接继承中不断查找，直到继承链的顶端</li><li>类型检查：假如找到mem，进行常规的类型检查，以确认本次调用是否合法</li><li>假如合法，编译器根据调用的是否为虚函数产生不同的代码：<ul><li>mem是虚函数且通过指针或引用来调用：编译器产生的代码将在运行时确定到底是运行该虚函数的哪个版本，依据是对象的动态类型</li><li>mem不是虚函数或者通过对象进行调用：产生一个常规的函数调用</li></ul></li></ol></li><li>函数调用的解析过程导致的现象：<ul><li>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的<ul><li>比如将基类指针绑定到派生类，基类指针静态类型是指向基类（因此无法调用派生类特有的成员），但是动态类型是指向派生类</li></ul></li><li>派生类的成员将隐藏同名的基类成员，即使成员函数形参列表不同<ul><li>可以使用域运算符<code>::</code>使用被隐藏的基类成员</li><li>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</li><li>派生类中继承来的虚函数要保持相同的参数列表，否则派生类定义的是一个新函数，该新函数不是虚函数</li></ul></li><li>虚函数解析过程：<ul><li>在编译期，基类指针在静态类型中进行名字查找和类型检查</li><li>在运行期，根据动态类型决定运行虚函数的哪个版本</li></ul></li></ul></li><li>覆盖重载的函数：<ul><li>派生类可以覆盖重载函数的0个或多个版本</li><li>如果派生类希望所有的重载版本对它来说都是可见的，那么就需要覆盖所有的版本，或者一个也不覆盖（因此到基类中寻找名字）</li><li>如果像重写一部分而非全部，可以使用using声明将同名的重载版本都添加到派生类作用域中，然后再重写</li><li>根本原因还是相应静态类型中查找到名字后但是类型不匹配，如果只覆盖一部分相当于重载版本变少了</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdio&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>f</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;Base 1&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;Base 2&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;Base 3&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>D1</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>f</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;D1 &#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// 只覆盖一个
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>D2</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 一个都不覆盖
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>D3</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>Base</span><span class=o>::</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;D3 2&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>D1</span> <span class=n>d1</span><span class=p>;</span> <span class=n>D2</span> <span class=n>d2</span><span class=p>;</span> <span class=n>D3</span> <span class=n>d3</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=c1>//  d1.f(1); // 报错：因为d1静态类型为D1，D1中有函数f，但是类型检查失败
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d2</span><span class=p>.</span><span class=n>f</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// Base 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d3</span><span class=p>.</span><span class=n>f</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// D3 2
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//  D1* p = &amp;d1; // 这样定义就错，原因同上
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Base</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>d1</span><span class=p>;</span> <span class=c1>// p的静态类型为Base，Base中有函数f(int)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>f</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// Base 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li>重载、重写（覆盖）与隐藏，<a href=https://www.cnblogs.com/sunbines/p/9130227.html>参考</a><ul><li>重载：同一作用域内的几个函数同名但是形参列表不同</li><li>隐藏：派生类中的函数屏蔽了与其同名的基类函数，不管参数列表是否相同</li><li>重写（覆盖）：虚函数重写</li></ul></li></ul><h2 id=157-构造函数与拷贝控制>15.7 构造函数与拷贝控制<a hidden class=anchor aria-hidden=true href=#157-构造函数与拷贝控制>¶</a></h2><h3 id=虚析构函数>虚析构函数<a hidden class=anchor aria-hidden=true href=#虚析构函数>¶</a></h3><ul><li>基类通常应该定义一个虚析构函数，这样最终执行动态类型版本的析构函数</li><li>一般来说，如果一个类需要析构函数，那么它也需要拷贝和赋值操作，但是基类的析构函数不遵循该规则</li><li>虚析构函数将阻止使用合成的移动操作，即使使用<code>=default</code>显式声明</li></ul><h3 id=合成的拷贝控制与继承>合成的拷贝控制与继承<a hidden class=anchor aria-hidden=true href=#合成的拷贝控制与继承>¶</a></h3><ul><li>派生类的合成拷贝控制成员，通过调用基类的合成拷贝控制成员，来对基类部分进行相应的拷贝、移动、销毁等操作</li><li>某些定义基类的方式可能导致部分派生类成员成为被删除的函数：<ul><li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或者不可访问的函数，则派生类中对应的成员也会是被删除的。</li><li>如果基类的析构函数是被删除的或者不可访问的，则派生类中合成的默认和拷贝构造函数也会是被删除的。</li><li>如果基类的移动操作是删除的，则派生类中对应的函数也是删除的。</li><li>在实际编程中，如果基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。</li></ul></li><li>移动操作与继承<ul><li>大多数基类都会定义一个虚析构函数，因此基类通常没有合成的移动操作</li><li>如果需要移动操作，首先在基类中定义，之后派生类会自动合成移动操作</li></ul></li></ul><h3 id=派生类的拷贝控制成员>派生类的拷贝控制成员<a hidden class=anchor aria-hidden=true href=#派生类的拷贝控制成员>¶</a></h3><ul><li>当派生类定义了拷贝或移动操作时，该操作通过调用基类的对应成员，来拷贝或移动包括基类在内的整个对象。</li><li>与拷贝和移动操作不同，派生类的析构函数只负责销毁由派生类自己分配的资源，对象销毁的顺序与创建顺序相反</li><li>在构造函数和析构函数中尽量不要调用虚函数：<a href="https://zhuanlan.zhihu.com/p/424508028#:~:text=%E9%A6%96%E5%85%88%E7%BB%99%E5%87%BA%E7%AD%94%E6%A1%88%EF%BC%9A%20%E5%9C%A8C%2B%2B,primer%E4%B8%AD%E8%AF%B4%E5%88%B0%E8%BF%87%E6%98%AF%E6%9C%80%E5%A5%BD%20%E4%B8%8D%E8%A6%81%E8%B0%83%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%AF%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%EF%BC%8C%20%E6%89%80%E4%BB%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B7%9F%E8%99%9A%E6%9E%84%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%E9%83%BD%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E4%BC%9A%E6%8A%A5%E9%94%99%E3%80%82">例子</a>。<ul><li>比如在进行基类的初始化时，调用了派生类版本的虚函数，但是此时派生类还未进行初始化</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>()</span> <span class=p>{</span> <span class=n>func</span><span class=p>();</span> <span class=p>}</span> <span class=c1>// 构造函数中调用虚函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Base</span><span class=p>(</span><span class=k>const</span> <span class=n>Base</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span><span class=k>default</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=p>(</span><span class=n>Base</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span><span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=n>Base</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span><span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Base</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span> <span class=p>(</span><span class=n>Base</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span><span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Base</span><span class=p>()</span> <span class=o>=</span><span class=k>default</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>func</span><span class=p>()</span> <span class=p>{</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;Base&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Derived</span><span class=p>()</span><span class=o>:</span> <span class=n>Base</span><span class=p>()</span> <span class=p>{</span> <span class=n>func</span><span class=p>();</span> <span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=n>Derived</span><span class=p>(</span><span class=k>const</span> <span class=n>Derived</span><span class=o>&amp;</span> <span class=n>d</span><span class=p>)</span><span class=o>:</span> <span class=n>Base</span><span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// 使用基类的构造函数初始化对象的基类部分
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Derived</span><span class=p>(</span><span class=n>Derived</span><span class=o>&amp;&amp;</span> <span class=n>d</span><span class=p>)</span><span class=o>:</span> <span class=n>Base</span><span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>Derived</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=n>Derived</span><span class=o>&amp;</span> <span class=n>d</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>Base</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>d</span><span class=p>);</span> <span class=c1>// 使用基类的拷贝赋值运算符赋值对象的基类部分
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=cm>/* do something*/</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Derived</span><span class=p>()</span> <span class=p>{</span> <span class=cm>/*销毁派生类自己分配的资源*/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>func</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;Derived&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Derived</span> <span class=n>d</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=c1>// 先构造基类部分，此时派生类部分还未创建，基类构造函数中使用的是Base::func()
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=继承的构造函数>继承的构造函数<a hidden class=anchor aria-hidden=true href=#继承的构造函数>¶</a></h3><ul><li>背景<ul><li>如果基类有多个不同的构造函数，那么派生类也需要相应实现多个构造函数，<a href=https://blog.csdn.net/K346K346/article/details/81703914>参考</a></li><li>派生类不能继承默认、拷贝、移动构造函数，派生类如果没有直接定义这些构造函数，编译器会为派生类合成</li></ul></li><li>派生类可以使用using声明重用基类的构造函数，编译器在派生类中生成一个形参列表完全相同的构造函数，派生类自己的数据成员被默认初始化<ul><li>和普通的using声明不一样（可以[[ch15-面向对象程序设计#^f2ba1c|改变派生类个别成员的可访问性]]），构造函数的using声明不会改变构造函数的访问声明符</li><li>如果基类构造函数是<code>explict</code>的或<code>constexpr</code>的，则重用的构造函数也拥有相同的属性</li><li>如果一个基类构造函数含有默认实参，这些实参并不会被直接继承，派生类会获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。</li><li>基类有几个构造函数，派生类会重用所有的这些构造函数，除了两个例外：<ul><li>派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本：如果派生类定义的构造函数与重用基类的构造函数具有相同的参数列表，则派生类中的构造函数将替换重用的基类构造函数</li><li>默认、拷贝和移动构造函数不会被继承，这些构造函数按照正常规则被合成</li></ul></li></ul></li></ul><h2 id=158-容器与继承>15.8 容器与继承<a hidden class=anchor aria-hidden=true href=#158-容器与继承>¶</a></h2><ul><li>当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式，即在容器中放置（智能）指针而非对象，否则派生类对象的部分会被切掉</li></ul><h2 id=159-文本查询程序再探>15.9 文本查询程序再探<a hidden class=anchor aria-hidden=true href=#159-文本查询程序再探>¶</a></h2><ul><li>使系统支持：单词查询、逻辑非查询、逻辑或查询、逻辑与查询。</li></ul><h3 id=面向对象的解决方案>面向对象的解决方案<a hidden class=anchor aria-hidden=true href=#面向对象的解决方案>¶</a></h3><ul><li>将几种不同的查询建模成相互独立的类，这些类共享一个公共基类：<ul><li><code>WordQuery</code></li><li><code>NotQuery</code></li><li><code>OrQuery</code></li><li><code>AndQuery</code></li></ul></li><li>这些类包含两个操作：<ul><li><code>eval</code>：接受一个<code>TextQuery</code>对象并返回一个<code>QueryResult</code>。</li><li><code>rep</code>：返回基础查询的<code>string</code>表示形式。</li></ul></li><li>继承和组合：<ul><li>当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（Is A）”的关系。</li><li>类型之间另一种常见的关系是“有一个（Has A）”的关系。</li></ul></li><li>对于面向对象编程的新手来说，想要理解一个程序，最困难的部分往往是理解程序的设计思路。一旦掌握了设计思路，接下来的实现也就水到渠成了。
<strong>Query程序设计</strong>:</li></ul><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>Query</code>程序接口类和操作</td><td></td></tr><tr><td><code>TextQuery</code></td><td>该类读入给定的文件并构建一个查找图。包含一个<code>query</code>操作，它接受一个<code>string</code>实参，返回一个<code>QueryResult</code>对象；该<code>QueryResult</code>对象表示<code>string</code>出现的行。</td></tr><tr><td><code>QueryResult</code></td><td>该类保存一个<code>query</code>操作的结果。</td></tr><tr><td><code>Query</code></td><td>是一个接口类，指向<code>Query_base</code>派生类的对象。</td></tr><tr><td><code>Query q(s)</code></td><td>将<code>Query</code>对象<code>q</code>绑定到一个存放着<code>string s</code>的新<code>WordQuery</code>对象上。</td></tr><tr><td><code>q1 & q2</code></td><td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q1</code>和<code>q2</code>的新<code>AndQuery</code>对象上。</td></tr><tr><td>`q1</td><td>q2`</td></tr><tr><td><code>~q</code></td><td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q</code>的新<code>NotQuery</code>对象上。</td></tr><tr><td><code>Query</code>程序实现类</td><td></td></tr><tr><td><code>Query_base</code></td><td>查询类的抽象基类</td></tr><tr><td><code>WordQuery</code></td><td><code>Query_base</code>的派生类，用于查找一个给定的单词</td></tr><tr><td><code>NotQuery</code></td><td><code>Query_base</code>的派生类，用于查找一个给定的单词</td></tr><tr><td><code>BinaryQuery</code></td><td><code>Query_base</code>的派生类，查询结果是<code>Query</code>运算对象没有出现的行的集合</td></tr><tr><td><code>OrQuery</code></td><td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的并集</td></tr><tr><td><code>AndQuery</code></td><td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的交集</td></tr></tbody></table></div><footer class=post-footer><nav class=paginav><a class=prev href=https://qinganzhang.github.io/posts/cpp-primer/ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Ch16 模板和泛型编程</span>
</a><a class=next href=https://qinganzhang.github.io/posts/cpp-primer/ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Ch14 重载运算与类型转换</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://qinganzhang.github.io/>Paul's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>