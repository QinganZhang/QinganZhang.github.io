<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ch18 用于大型程序的工具 | Paul's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="第十八章 用于大型程序的工具 18.1 异常处理 18.2 命名空间 命名空间定义 语法相关： 只要能出现在全局作用域的声明就能置于命名空间中 命名空间不能定义在函数或类"><meta name=author content="Paul"><link rel=canonical href=https://qinganzhang.github.io/posts/cpp-primer/ch18-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://qinganzhang.github.io/favicon.ico><link rel=apple-touch-icon href=https://qinganzhang.github.io/apple-touch-icon.png><meta name=twitter:title content="Ch18 用于大型程序的工具 | Paul's Blog"><meta name=twitter:description content="第十八章 用于大型程序的工具 18.1 异常处理 18.2 命名空间 命名空间定义 语法相关： 只要能出现在全局作用域的声明就能置于命名空间中 命名空间不能定义在函数或类"><meta property="og:title" content="Ch18 用于大型程序的工具 | Paul's Blog"><meta property="og:description" content="第十八章 用于大型程序的工具 18.1 异常处理 18.2 命名空间 命名空间定义 语法相关： 只要能出现在全局作用域的声明就能置于命名空间中 命名空间不能定义在函数或类"><meta property="og:type" content="article"><meta property="og:url" content="https://qinganzhang.github.io/posts/cpp-primer/ch18-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T15:58:59+08:00"><meta property="article:modified_time" content="2024-02-27T15:58:59+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://qinganzhang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Ch18 用于大型程序的工具","item":"https://qinganzhang.github.io/posts/cpp-primer/ch18-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ch18 用于大型程序的工具 | Paul's Blog","name":"Ch18 用于大型程序的工具","description":"第十八章 用于大型程序的工具 18.1 异常处理 18.2 命名空间 命名空间定义 语法相关： 只要能出现在全局作用域的声明就能置于命名空间中 命名空间不能定义在函数或类","keywords":["cpp"],"wordCount":"3230","inLanguage":"en","datePublished":"2024-02-27T15:58:59+08:00","dateModified":"2024-02-27T15:58:59+08:00","author":{"@type":"Person","name":"Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qinganzhang.github.io/posts/cpp-primer/ch18-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/"},"publisher":{"@type":"Organization","name":"Paul's Blog","logo":{"@type":"ImageObject","url":"https://qinganzhang.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://qinganzhang.github.io/ accesskey=h title="Paul's Blog (Alt + H)">Paul's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://qinganzhang.github.io/posts/ title=Posts class=active>Posts</a></li><li><a href=https://qinganzhang.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://qinganzhang.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://qinganzhang.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://qinganzhang.github.io/categories/ title=Categories>Categories</a></li><li><a href=https://qinganzhang.github.io/about/ title=About>About</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qinganzhang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://qinganzhang.github.io/posts/>Post</a></div><h1 class=post-title>Ch18 用于大型程序的工具</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-02-27</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://qinganzhang.github.io/tags/cpp/>cpp</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>3230 words</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>7 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ac%ac%e5%8d%81%e5%85%ab%e7%ab%a0-%e7%94%a8%e4%ba%8e%e5%a4%a7%e5%9e%8b%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%b7%a5%e5%85%b7 aria-label="第十八章 用于大型程序的工具">第十八章 用于大型程序的工具</a><ul><li><a href=#181-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86 aria-label="18.1 异常处理">18.1 异常处理</a></li><li><a href=#182-%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4 aria-label="18.2 命名空间">18.2 命名空间</a><ul><li><a href=#%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e5%ae%9a%e4%b9%89 aria-label=命名空间定义>命名空间定义</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e6%88%90%e5%91%98 aria-label=使用命名空间成员>使用命名空间成员</a></li><li><a href=#%e7%b1%bb%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e4%b8%8e%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label=类、命名空间与作用域>类、命名空间与作用域</a></li><li><a href=#%e9%87%8d%e8%bd%bd%e4%b8%8e%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4 aria-label=重载与命名空间>重载与命名空间</a></li></ul></li><li><a href=#183-%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf%e4%b8%8e%e8%99%9a%e7%bb%a7%e6%89%bf aria-label="18.3 多重继承与虚继承">18.3 多重继承与虚继承</a><ul><li><a href=#%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf aria-label=多重继承>多重继承</a></li><li><a href=#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e4%b8%8e%e5%a4%9a%e4%b8%aa%e5%9f%ba%e7%b1%bb aria-label=类型转换与多个基类>类型转换与多个基类</a></li><li><a href=#%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf%e4%b8%8b%e7%9a%84%e7%b1%bb%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label=多重继承下的类作用域>多重继承下的类作用域</a></li><li><a href=#%e8%99%9a%e7%bb%a7%e6%89%bf aria-label=虚继承>虚继承</a></li><li><a href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%8e%e8%99%9a%e7%bb%a7%e6%89%bf aria-label=构造函数与虚继承>构造函数与虚继承</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=第十八章-用于大型程序的工具>第十八章 用于大型程序的工具<a hidden class=anchor aria-hidden=true href=#第十八章-用于大型程序的工具>¶</a></h1><h2 id=181-异常处理>18.1 异常处理<a hidden class=anchor aria-hidden=true href=#181-异常处理>¶</a></h2><h2 id=182-命名空间>18.2 命名空间<a hidden class=anchor aria-hidden=true href=#182-命名空间>¶</a></h2><h3 id=命名空间定义>命名空间定义<a hidden class=anchor aria-hidden=true href=#命名空间定义>¶</a></h3><ul><li>语法相关：<ul><li>只要能出现在全局作用域的声明就能置于命名空间中</li><li>命名空间不能定义在函数或类内部</li><li>每个命名空间是一个作用域。</li><li>命名空间可以不连续，即同一命名空间可以定义为几个不同的部分，在多处出现<ul><li>在头文件中声明命名空间中的成员，在源文件中定义命名空间中的成员</li></ul></li><li>通常不将<code>#include</code>放在命名空间中，否则会将该头文件中的所有名字定义为该命名空间中的成员</li></ul></li><li>几种命名空间<ul><li>全局命名空间：使用<code>::</code>显式指明</li><li>嵌套命名空间</li><li>内联命名空间：无需使用该命名空间的前缀，通过外层命名空间就可以直接访问。<ul><li>inline必须出现在命名空间第一次定义的地方，后续打开命名空间时可以不加inline</li><li>程序代码更新版本时经常使用内联空间，当前版本放在内联空间中，历史版本放在非内联空间中，<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* 文件名：FifthEd.h */</span> 
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=k>namespace</span> <span class=n>FifthEd</span><span class=p>{</span> <span class=c1>//定义第五版命名空间，是内联，使用时不需显式指定该空间的名字 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>class</span> <span class=nc>Query_base</span><span class=p>{</span><span class=cm>/* 类的定义 */</span><span class=p>};</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* 文件名：FourthEd.h */</span> 
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>FourthEd</span><span class=p>{</span> <span class=c1>//定义第四版命名空间 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>class</span> <span class=nc>Query_base</span><span class=p>{</span><span class=cm>/* 类的定义 */</span><span class=p>};</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=cm>/* 文件名：cplusplus_primer.h */</span> 
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>cplusplus_primer</span><span class=p>{</span> <span class=c1>//将上面两个命名空间嵌套进外层空间 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cp>#include&#34;FifthEd.h&#34; </span><span class=c1>//引入头文件中的所有名字 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cp>#include&#34;FourthEd.h&#34; 
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=cm>/* 文件名：main.cc */</span> 
</span></span><span class=line><span class=cl><span class=cp>#include&#34;cplusplus_primer.h&#34; 
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=n>cplusplus_primer</span><span class=o>::</span><span class=n>Query_base</span><span class=p>;</span> <span class=c1>//默认使用第五版中的成员 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>cplusplus_primer</span><span class=o>::</span><span class=n>FourthEd</span><span class=o>::</span><span class=n>Query_base</span><span class=p>;</span> <span class=c1>//手动指定第四版中的成员
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li>未命名的命名空间<ul><li>未命名的命名空间可以在一个文件内不连续（是同一个命名空间），但是不可跨越文件（否则是两个无关的命名空间）</li><li>未命名的命名空间中定义的变量拥有静态的声明周期：在第一次使用前创建，直到程序结束才销毁。</li><li>如果头文件中定义了未命名的命名空间，则不同源文件中包含了该头文件后，该空间中的名字对应不同实体</li><li>未命名的命名空间中的名字可以跨越到上一次作用域，因此定义在未命名的命名空间中的名字可以直接使用，不能对未命名的命名空间的成员使用作用域算符</li><li>应用：未命名的命名空间取代文件中的静态声明<ul><li>原来将全局变量声明为<code>static</code>以转变为内部变量（C方式）</li><li>现在将全局变量放在未命名的命名空间中（C++方式，原因见上述语法），但是此时全局变量仍然是外部的，</li></ul></li></ul></li></ul></li></ul><h3 id=使用命名空间成员>使用命名空间成员<a hidden class=anchor aria-hidden=true href=#使用命名空间成员>¶</a></h3><ul><li>命名空间的别名：<code>namespace new_name = old_name1::old_name2;</code><ul><li>一个命名空间可以有多个别名，但不能在未定义命名空间之前就声明别名</li></ul></li><li><code>using</code>声明：<code>using my_namespace::mem;</code><ul><li>一次只能引入命名空间的一个成员</li><li>声明的名字的作用域与using语句本身的作用域一致</li><li>在类作用域中<code>using</code>声明只能声明基类成员</li></ul></li><li><code>using</code>指示：<code>using nemespace my_namespace;</code><ul><li>引入命名空间中所有名字</li><li>using指示将命名空间注入到外层作用域，即将命名空间中所有名字出现在最近的外层作用域中（相当于using声明的外层作用域）</li><li>不可出现在类作用域</li></ul></li><li>命名空间污染：<ul><li>使用了多个命名空间的using指示后，外层作用域中来自不同命名空间的名字可能发生冲突，这种冲突允许存在，但是使用时需要使用<code>::</code>明确指定版本</li><li>在头文件中，不要在全局作用域中使用using声明/指示，最多在函数、命名空间中使用</li><li>using指示引发的二义性错误只有在使用冲突名字的地方才会被发现，难以定位bug</li><li>尽量使用using声明而非using指示</li></ul></li></ul><h3 id=类命名空间与作用域>类、命名空间与作用域<a hidden class=anchor aria-hidden=true href=#类命名空间与作用域>¶</a></h3><ul><li>名字查找的例外：给函数传递类类型对象/引用/指针时，先在常规的作用域中查找函数名，随后还会在实参类（及其基类）所属的命名空间中查找函数名。<ul><li>这个规则使得概念上作为接口一部分的非成员函数不需单独using声明就可被程序使用</li><li>例子：<code>std::cin>>str;</code>表达式中，作用域中没有声明<code>operator>>()</code>函数，但是仍可以使用，这是因为在<code>istream</code>（实参<code>std::cin</code>所属类）和<code>string</code>（实参<code>str</code>所属类）所在的命名空间中进行了查找。否则需要显式声明：<code>using std::operator>></code>，使用<code>operator>>(std::cin, str);</code></li></ul></li><li>友元相关：<ul><li>当类声明友元时，还需要在类外给出友元的正式声明</li><li>一个未声明的类/函数若第一次出现在友元声明中，则认为它是最近的外层命名空间的成员。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>A</span><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>C</span><span class=p>{</span> <span class=c1>//这2个友元声明时还没有正式声明，认为它是最近的外层空间的成员，即隐式声明为空间A的成员 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>friend</span> <span class=kt>void</span> <span class=nf>f2</span><span class=p>();</span> <span class=c1>//没有形参 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>friend</span> <span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=k>const</span> <span class=n>C</span> <span class=o>&amp;</span><span class=p>);</span> <span class=c1>//接受C类型对象作为实参 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span> 
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=o>::</span><span class=n>C</span> <span class=n>cobj</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>(</span><span class=n>cobj</span><span class=p>);</span> <span class=c1>//对，f被隐式声明为A的成员，且实参决定会在A中查找函数f 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>f2</span><span class=p>();</span> <span class=c1>//错，虽然f2被隐式声明为A的成员，但未显式指明 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=重载与命名空间>重载与命名空间<a hidden class=anchor aria-hidden=true href=#重载与命名空间>¶</a></h3><ul><li><code>using</code>声明<ul><li><code>using</code>声明语句声明的是一个名字，而非特定的函数，也就是包括该函数的所有版本，都被引入到当前作用域中。</li><li><code>using</code>声明引入的函数将重载该声明语句所属作用域中已有的同名函数。</li></ul></li><li><code>using</code>指示<ul><li>若命名空间中函数名与外层作用域中函数同名，即使函数同名同参也不会报错，只需要使用时指明版本</li></ul></li></ul><h2 id=183-多重继承与虚继承>18.3 多重继承与虚继承<a hidden class=anchor aria-hidden=true href=#183-多重继承与虚继承>¶</a></h2><h3 id=多重继承>多重继承<a hidden class=anchor aria-hidden=true href=#多重继承>¶</a></h3><ul><li>可以从多个基类中继承构造函数，但是这些构造函数必须形参列表不同<ul><li>如果相同，则派生类必须为这种形参列表的构造函数定义自己的版本</li></ul></li></ul><h3 id=类型转换与多个基类>类型转换与多个基类<a hidden class=anchor aria-hidden=true href=#类型转换与多个基类>¶</a></h3><ul><li>在派生类向基类的转换中，如果有多个基类，编译器不会进行比较，转换到任何基类一样好</li><li>对象的指针/引用的静态类型决定了哪些成员可见</li></ul><h3 id=多重继承下的类作用域>多重继承下的类作用域<a hidden class=anchor aria-hidden=true href=#多重继承下的类作用域>¶</a></h3><ul><li>在派生类中使用了某个名字，则程序并行的在多个基类中查找名字<ul><li>派生类继承多个基类的同名成员合法，只是使用时需要<code>::</code>指明版本</li><li>派生类只是引入潜在的二义性，如果不调用该重名的对象，则不会报错</li></ul><ul><li>只有使用该重名对象时，才会产生二义性报错<ul><li>该名字在多个基类中是形参列表不同的函数</li><li>该名字在一个基类中是private，而在另一个基类中是public/protected</li><li>该名字在一个基类中直接找到，而在另一个基类的间接基类中找到</li></ul></li><li>避免这种二义性的方法是在派生类中再定义一次这个名字，覆盖基类名字，避免在基类中查找</li></ul></li><li>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。</li></ul><h3 id=虚继承>虚继承<a hidden class=anchor aria-hidden=true href=#虚继承>¶</a></h3><ul><li>背景：菱形继承中，间接基类应该只有一个，如果不使用虚继承，则间接基类在派生类对象中有两个部分</li><li>虚继承：令某个类做出声明，承诺愿意共享它的基类。被共享的基类子对象称为<strong>虚基类</strong>，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。<ul><li>经常并不知道一个类是否会被继承多次，因此不知道由它而来的派生是否应该是虚派生</li><li>实际编程中，位于中间层次的类将其继承基类的方式声明为虚继承并不会出问题。虚派生只影响从虚基类的派生类中进一步派生出的类，它不影响虚基类的派生类。</li></ul></li><li>语法相关：<ul><li>在派生列表中添加<code>virtual</code>，表示后续的派生类共享虚基类的同一份实例</li><li>菱形继承：类B定义了成员x，D1和D2由B虚继承得到，D继承自D1和D2，则在D的作用域中，x通过两个基类都可见。若通过D的对象使用x，有几种可能：<ul><li>若D1和D2中都未定义x，则x被解析为B的成员，不存在二义性。因为只在虚基类中有定义</li><li>若D1或D2其中之一定义了x，则x被解析为D1或D2的成员，不存在二义性。因为D1和D2是派生类，位于内层作用域，优先级更高</li><li>若D1和D2中都定义了x，则直接访问x时是二义性。因为D1和D2的优先级相同</li></ul></li><li>解决二义性最好的方法就是在派生类中为成员自定义新的实例</li></ul></li></ul><h3 id=构造函数与虚继承>构造函数与虚继承<a hidden class=anchor aria-hidden=true href=#构造函数与虚继承>¶</a></h3><ul><li>在虚派生中，虚基类由最终的派生类在其构造函数初值列表中初始化（越过了继承链），而非由其直接派生类初始化，否则被重复初始化</li><li>只要创建了虚基类的派生类对象，该派生类的构造函数就会越过继承链初始化虚基类</li><li>含有虚基类的对象的构造顺序：<ul><li>首先使用提供给最终派生类构造函数的初值来初始化虚基类（否则虚基类默认初始化）</li><li>一个类可有多个虚基类，这些虚基类的初始化顺序是它们在派生列表中的顺序</li><li>然后按照直接基类在派生列表中的顺序初始化非虚基类</li></ul></li><li>构造派生类时，编译器按照直接基类的声明顺序对其依次检查，若基类中含有虚基类，则先构造虚基类，然后按照声明顺序逐一构造其他非虚基类</li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://qinganzhang.github.io/posts/cpp-primer/ch19-%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Ch19 特殊工具与技术</span>
</a><a class=next href=https://qinganzhang.github.io/posts/cpp-primer/ch17-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Ch17 标准库特殊设施</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://qinganzhang.github.io/>Paul's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>