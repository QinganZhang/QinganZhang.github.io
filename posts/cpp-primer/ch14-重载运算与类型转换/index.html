<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ch14 重载运算与类型转换 | Paul's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="第十四章 重载运算与类型转换 14.1 基本概念 语法相关： 重载的运算符必须是某个类的成员或至少拥有一个类类型的运算对象 重载运算符函数的参数数量和该运算符"><meta name=author content="Paul"><link rel=canonical href=https://qinganzhang.github.io/posts/cpp-primer/ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://qinganzhang.github.io/favicon.ico><link rel=apple-touch-icon href=https://qinganzhang.github.io/apple-touch-icon.png><meta name=twitter:title content="Ch14 重载运算与类型转换 | Paul's Blog"><meta name=twitter:description content="第十四章 重载运算与类型转换 14.1 基本概念 语法相关： 重载的运算符必须是某个类的成员或至少拥有一个类类型的运算对象 重载运算符函数的参数数量和该运算符"><meta property="og:title" content="Ch14 重载运算与类型转换 | Paul's Blog"><meta property="og:description" content="第十四章 重载运算与类型转换 14.1 基本概念 语法相关： 重载的运算符必须是某个类的成员或至少拥有一个类类型的运算对象 重载运算符函数的参数数量和该运算符"><meta property="og:type" content="article"><meta property="og:url" content="https://qinganzhang.github.io/posts/cpp-primer/ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T15:58:22+08:00"><meta property="article:modified_time" content="2024-02-27T15:58:22+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://qinganzhang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Ch14 重载运算与类型转换","item":"https://qinganzhang.github.io/posts/cpp-primer/ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ch14 重载运算与类型转换 | Paul's Blog","name":"Ch14 重载运算与类型转换","description":"第十四章 重载运算与类型转换 14.1 基本概念 语法相关： 重载的运算符必须是某个类的成员或至少拥有一个类类型的运算对象 重载运算符函数的参数数量和该运算符","keywords":["cpp"],"wordCount":"3819","inLanguage":"en","datePublished":"2024-02-27T15:58:22+08:00","dateModified":"2024-02-27T15:58:22+08:00","author":{"@type":"Person","name":"Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qinganzhang.github.io/posts/cpp-primer/ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},"publisher":{"@type":"Organization","name":"Paul's Blog","logo":{"@type":"ImageObject","url":"https://qinganzhang.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://qinganzhang.github.io/ accesskey=h title="Paul's Blog (Alt + H)">Paul's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://qinganzhang.github.io/posts/ title=Posts class=active>Posts</a></li><li><a href=https://qinganzhang.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://qinganzhang.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://qinganzhang.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://qinganzhang.github.io/categories/ title=Categories>Categories</a></li><li><a href=https://qinganzhang.github.io/about/ title=About>About</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qinganzhang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://qinganzhang.github.io/posts/>Post</a></div><h1 class=post-title>Ch14 重载运算与类型转换</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-02-27</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://qinganzhang.github.io/tags/cpp/>cpp</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>3819 words</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>8 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ac%ac%e5%8d%81%e5%9b%9b%e7%ab%a0-%e9%87%8d%e8%bd%bd%e8%bf%90%e7%ae%97%e4%b8%8e%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label="第十四章 重载运算与类型转换">第十四章 重载运算与类型转换</a><ul><li><a href=#141-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="14.1 基本概念">14.1 基本概念</a></li><li><a href=#142-%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd aria-label="14.2 运算符重载">14.2 运算符重载</a><ul><li><a href=#1421-%e9%87%8d%e8%bd%bd%e8%be%93%e5%87%ba%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="14.2.1 重载输出运算符&amp;lt;&amp;lt;">14.2.1 重载输出运算符<code>&lt;&lt;</code></a></li><li><a href=#1422-%e9%87%8d%e8%bd%bd%e8%be%93%e5%85%a5%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="14.2.2 重载输入运算符&amp;gt;&amp;gt;">14.2.2 重载输入运算符<code>>></code></a></li><li><a href=#1423-%e9%87%8d%e8%bd%bd%e7%ae%97%e6%95%b0%e8%bf%90%e7%ae%97%e7%ac%a6- aria-label="14.2.3 重载算数运算符+、-、*、/">14.2.3 重载算数运算符<code>+、-、*、/</code></a></li><li><a href=#1424-%e7%9b%b8%e7%ad%89%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="14.2.4 相等运算符==">14.2.4 相等运算符<code>==</code></a></li><li><a href=#1425-%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="14.2.5 关系运算符&amp;lt;">14.2.5 关系运算符<code>&lt;</code></a></li><li><a href=#1426-%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="14.2.6 赋值运算符=">14.2.6 赋值运算符<code>=</code></a></li><li><a href=#1427-%e4%b8%8b%e6%a0%87%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="14.2.7 下标运算符[]">14.2.7 下标运算符<code>[]</code></a></li><li><a href=#1428-%e9%80%92%e5%a2%9e%e5%92%8c%e9%80%92%e5%87%8f%e8%bf%90%e7%ae%97%e7%ac%a6-- aria-label="14.2.8 递增和递减运算符++、--">14.2.8 递增和递减运算符<code>++、--</code></a></li><li><a href=#1429-%e6%88%90%e5%91%98%e8%ae%bf%e9%97%ae%e8%bf%90%e7%ae%97%e7%ac%a6- aria-label="14.2.9 成员访问运算符*、-&amp;gt;">14.2.9 成员访问运算符<code>*、-></code></a></li><li><a href=#14210-%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="14.2.10 函数调用运算符()">14.2.10 函数调用运算符<code>()</code></a></li></ul></li><li><a href=#148-%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="14.8 函数调用运算符">14.8 函数调用运算符</a><ul><li><a href=#lambda%e6%98%af%e5%87%bd%e6%95%b0%e5%af%b9%e8%b1%a1 aria-label=lambda是函数对象><code>lambda</code>是函数对象</a></li><li><a href=#%e6%a0%87%e5%87%86%e5%ba%93%e5%ae%9a%e4%b9%89%e7%9a%84%e5%87%bd%e6%95%b0%e5%af%b9%e8%b1%a1 aria-label=标准库定义的函数对象>标准库定义的函数对象</a><ul><ul><ul><li><a href=#%e6%a0%87%e5%87%86%e5%ba%93%e5%87%bd%e6%95%b0%e5%af%b9%e8%b1%a1 aria-label=标准库函数对象>标准库函数对象</a></li></ul></ul></ul></li><li><a href=#%e5%8f%af%e8%b0%83%e7%94%a8%e5%af%b9%e8%b1%a1%e4%b8%8efunction aria-label=可调用对象与function>可调用对象与function</a></li></ul></li><li><a href=#149-%e9%87%8d%e8%bd%bd%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="14.9 重载、类型转换、运算符">14.9 重载、类型转换、运算符</a><ul><li><a href=#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=类型转换运算符>类型转换运算符</a></li><li><a href=#%e9%81%bf%e5%85%8d%e6%9c%89%e4%ba%8c%e4%b9%89%e6%80%a7%e7%9a%84%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label=避免有二义性的类型转换>避免有二义性的类型转换</a></li><li><a href=#%e9%87%8d%e8%bd%bd%e4%b8%8e%e5%87%bd%e6%95%b0%e5%8c%b9%e9%85%8d aria-label=重载与函数匹配>重载与函数匹配</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=第十四章-重载运算与类型转换>第十四章 重载运算与类型转换<a hidden class=anchor aria-hidden=true href=#第十四章-重载运算与类型转换>¶</a></h1><h2 id=141-基本概念>14.1 基本概念<a hidden class=anchor aria-hidden=true href=#141-基本概念>¶</a></h2><ul><li>语法相关：<ul><li>重载的运算符必须是某个类的成员或至少拥有一个类类型的运算对象</li><li>重载运算符函数的参数数量和该运算符作用的运算对象数量一样多，左侧运算对象传递给第一个参数，右侧传递给第二个，除了重载函数调用符<code>()</code>，其他重载运算符不能有默认实参，调用方式：<code>operator+(data1, data2)</code></li><li>如果一个重载的运算符是成员函数，<strong><code>this</code>指向左侧运算对象</strong>，因此定义成员运算符时的参数数量比运算符的运算对象少一个，调用方式：<code>data1.operator+=(data2)</code></li><li>重载运算符的优先级和结合律跟对应的内置运算符保持一致。</li></ul></li><li>使用：<ul><li>一些运算符通常一起进行重载，比如重载了<code>==</code>也应该重载<code>!=</code>，重载了<code>&lt;</code>也应该重载其他关系操作，重载了算数运算符或位运算符，也应该重载对应的复合赋值运算符</li><li>考虑定义为成员函数还是普通函数<ul><li>赋值（<code>=</code>）、下标（<code>[]</code>）、调用（<code>()</code>）和成员访问箭头（<code>-></code>）运算符必须是成员。</li><li>递增、递减、解引用、复合赋值运算符一般是成员</li><li>具有对称性的运算符如算术、相等性、关系和位运算符等，通常是非成员函数。</li><li>IO运算符应该声明为类的友元</li></ul></li></ul></li></ul><h2 id=142-运算符重载>14.2 运算符重载<a hidden class=anchor aria-hidden=true href=#142-运算符重载>¶</a></h2><h3 id=1421-重载输出运算符>14.2.1 重载输出运算符<code>&lt;&lt;</code><a hidden class=anchor aria-hidden=true href=#1421-重载输出运算符>¶</a></h3><ul><li><code>ostream& operator&lt;&lt; (ostream &amp;os, const T &amp;t);</code></li><li>第一个形参通常是一个非常量的<code>ostream</code>对象的引用，第二个形参是要打印类型的常量引用</li><li>输出运算符应该尽量减少格式化操作（比如不应该打印换行符）</li></ul><h3 id=1422-重载输入运算符>14.2.2 重载输入运算符<code>>></code><a hidden class=anchor aria-hidden=true href=#1422-重载输入运算符>¶</a></h3><ul><li><code>istream& operator>> (istream& is, T &amp;t);</code></li><li>第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用。</li><li>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。<ul><li>如果读取失败，输入运算符应该负责从错误中恢复，主要是将输入对象重置为合法状态，一般为未输入前的状态。</li></ul></li></ul><h3 id=1423-重载算数运算符->14.2.3 重载算数运算符<code>+、-、*、/</code><a hidden class=anchor aria-hidden=true href=#1423-重载算数运算符->¶</a></h3><ul><li>一般设置为非成员函数，形参一般为常量引用，返回值不为引用（因为返回值一般是局部变量的拷贝）</li><li>一般都是先定义复合赋值运算符（成员函数），在基于此实现算数运算符（普通函数）</li></ul><h3 id=1424-相等运算符>14.2.4 相等运算符<code>==</code><a hidden class=anchor aria-hidden=true href=#1424-相等运算符>¶</a></h3><ul><li>如果定义了<code>operator==</code>，则这个类也应该定义<code>operator!=</code>。</li><li>相等运算符和不等运算符的一个应该把工作委托给另一个</li></ul><h3 id=1425-关系运算符>14.2.5 关系运算符<code>&lt;</code><a hidden class=anchor aria-hidden=true href=#1425-关系运算符>¶</a></h3><ul><li>如果两个对象是!=的，则一个对象应该<code>&lt;</code>另一个对象</li></ul><h3 id=1426-赋值运算符>14.2.6 赋值运算符<code>=</code><a hidden class=anchor aria-hidden=true href=#1426-赋值运算符>¶</a></h3><ul><li>赋值运算符和复合赋值运算符应该返回左侧运算对象的引用。</li></ul><h3 id=1427-下标运算符>14.2.7 下标运算符<code>[]</code><a hidden class=anchor aria-hidden=true href=#1427-下标运算符>¶</a></h3><ul><li>一般会定义两个版本：<ul><li>返回普通引用：<code>T& operator[]();</code></li><li>是类的常量成员，并返回常量引用：<code>const T& operator[] const;</code></li></ul></li></ul><h3 id=1428-递增和递减运算符-->14.2.8 递增和递减运算符<code>++、--</code><a hidden class=anchor aria-hidden=true href=#1428-递增和递减运算符-->¶</a></h3><ul><li>应该同时定义前置版本和后置版本，而且通常为类的成员。<ul><li>前置运算符应该返回递增或递减后对象的引用：<code>string& operator++();</code></li><li>后置运算符应该返回递增或递减前对象的值，而不是引用：<code>T operator++(int);</code><ul><li>后置版本接受一个额外的、不被使用的<code>int</code>类型的形参，且无需命名，编译器提供一个值为0的实参。该形参唯一的作用就是区分前置和后置递增。</li><li>如果想通过函数调用的方式使用后置递增，需要为这个int形参传递一个值（比如0）</li></ul></li><li>后置版本可以通过调用前置版本来实现。</li></ul></li></ul><h3 id=1429-成员访问运算符->14.2.9 成员访问运算符<code>*、-></code><a hidden class=anchor aria-hidden=true href=#1429-成员访问运算符->¶</a></h3><ul><li>箭头运算符必须是类的成员，解引用运算符通常也是类的成员，且通常为const的成员函数，而且箭头运算符一般通过调用解引用运算符来实现</li></ul><h3 id=14210-函数调用运算符>14.2.10 函数调用运算符<code>()</code><a hidden class=anchor aria-hidden=true href=#14210-函数调用运算符>¶</a></h3><h2 id=148-函数调用运算符>14.8 函数调用运算符<a hidden class=anchor aria-hidden=true href=#148-函数调用运算符>¶</a></h2><ul><li>如果类定义了调用运算符，则该类的对象称作【<strong>函数对象</strong>】。<ul><li>函数对象可以被调用，同时因为函数对象可以存储状态（即数据成员），所以与普通函数相比更加灵活，通常作为泛型算法的实参</li></ul></li><li>C++中的【可调用对象】：函数、函数指针、lambda表达式、bind创建的对象、函数对象（或者说重载了调用运算符的类）<ul><li>【可调用对象的类型】：lambda表达式有他自己唯一（未命名）的类类型，函数、函数指针的类型由返回值类型和实参类型决定</li><li>【调用形式】：指明了调用返回的类型和传递给调用的实参类型，比如<code>int(int,int)</code><ul><li>不同类型的可调用对象可以共享同一种调用形式，但它们并不是同一类型。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=29b2448c-5e82-8903-6155-e45a101f91f1&amp;page=538&amp;rect=58.810,599.770,427.200,622.320">例子</a>。</li></ul></li></ul></li></ul><h3 id=lambda是函数对象><code>lambda</code>是函数对象<a hidden class=anchor aria-hidden=true href=#lambda是函数对象>¶</a></h3><ul><li>编译器将[[ch10-泛型算法#lambda表达式|lambda表达式]]转换成一个未命名类的未命名对象（即类中重载了函数调用运算符）<ul><li>这个未命名类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认的拷贝/移动构造函数，通常视捕获变量的类型而定</li></ul></li><li>lambda默认不能改变它捕获的变量，此时未命名类中的函数调用运算符是一个const成员函数；如果lambda被声明为可变的，则调用运算符就不再是const成员函数<ul><li>如果进行引用捕获，编译器直接使用该引用而无须在产生的类中相应存储为数据成员（由程序确保该引用绑定的对象确实存在）</li><li>如果进行值捕获，产生的类必须为捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化相应的数据成员</li></ul></li></ul><h3 id=标准库定义的函数对象>标准库定义的函数对象<a hidden class=anchor aria-hidden=true href=#标准库定义的函数对象>¶</a></h3><h6 id=标准库函数对象>标准库函数对象<a hidden class=anchor aria-hidden=true href=#标准库函数对象>¶</a></h6><table><thead><tr><th>算术</th><th>关系</th><th>逻辑</th></tr></thead><tbody><tr><td><code>plus&lt;Type></code></td><td><code>equal_to&lt;Type></code></td><td><code>logical_and&lt;Type></code></td></tr><tr><td><code>minus&lt;Type></code></td><td><code>not_equal_to&lt;Type></code></td><td><code>logical_or&lt;Type></code></td></tr><tr><td><code>multiplies&lt;Type></code></td><td><code>greater&lt;Type></code></td><td><code>logical_not&lt;Type></code></td></tr><tr><td><code>divides&lt;Type></code></td><td><code>greater_equal&lt;Type></code></td><td></td></tr><tr><td><code>modulus&lt;Type></code></td><td><code>less&lt;Type></code></td><td></td></tr><tr><td><code>negate&lt;Type></code></td><td><code>less_equal&lt;Type></code></td><td></td></tr></tbody></table><ul><li>一组表示算数运算符、关系运算符和逻辑运算符的模板类，每个类中重载了调用运算符来实现相应的命名操作</li><li>标准库函数对象经常用来替换算法中的默认运算符</li><li>如果想根据指针（或者说内存地址）进行排序，Type可以是指针类型，但是无法通过自定义的函数来进行内存地址的比较</li></ul><h3 id=可调用对象与function>可调用对象与function<a hidden class=anchor aria-hidden=true href=#可调用对象与function>¶</a></h3><ul><li>调用形式相同的可调用对象，其类型不一定相同</li><li><code>function</code>封装了相同调用形式、但是不同类型的可调用对象<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>i</span> <span class=o>+</span> <span class=n>j</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>mod</span> <span class=o>=</span> <span class=p>[](</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=n>i</span> <span class=o>%</span> <span class=n>j</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=n>function</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>f1</span> <span class=o>=</span> <span class=n>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>function</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>f2</span> <span class=o>=</span> <span class=n>mod</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=n>function</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=p>)</span><span class=o>&gt;&gt;</span> <span class=n>mp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>.</span><span class=n>insert</span><span class=p>({</span><span class=s>&#34;+&#34;</span><span class=p>,</span> <span class=n>add</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>.</span><span class=n>insert</span><span class=p>({</span><span class=s>&#34;%&#34;</span><span class=p>,</span> <span class=n>mod</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>[</span><span class=s>&#34;+&#34;</span><span class=p>](</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>);</span> <span class=c1>// 将不同可调用类型的可调用对象存储在一起    
</span></span></span></code></pre></td></tr></table></div></div></li><li>不能直接将重载函数的名字存入<code>function</code>类型的对象中，因为会产生二义性，消除二义性的方法是使用lambda或者函数指针而非函数名字<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=n>i</span> <span class=o>+</span> <span class=n>j</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=nf>add</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>,</span> <span class=n>string</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=n>s</span> <span class=o>+</span> <span class=n>t</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=n>function</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span><span class=o>&gt;&gt;</span> <span class=n>mp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>.</span><span class=n>insert</span><span class=p>({</span><span class=s>&#34;+&#34;</span><span class=p>,</span> <span class=n>add</span><span class=p>});</span> <span class=c1>// error: which add?
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=o>=</span> <span class=n>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>.</span><span class=n>insert</span><span class=p>({</span><span class=s>&#34;+&#34;</span><span class=p>,</span> <span class=n>fp</span><span class=p>});</span> 
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>.</span><span class=n>insert</span><span class=p>({</span><span class=s>&#34;+&#34;</span><span class=p>,</span> <span class=p>[](</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=nf>add</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>);};</span> <span class=c1>// 另一种写法
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=149-重载类型转换运算符>14.9 重载、类型转换、运算符<a hidden class=anchor aria-hidden=true href=#149-重载类型转换运算符>¶</a></h2><p>类类型转换（或者称用户定义的类型转换）：转换构造函数（从其他类型转换到类类型）+类型转换运算符（从类类型转换到其他类型）</p><h3 id=类型转换运算符>类型转换运算符<a hidden class=anchor aria-hidden=true href=#类型转换运算符>¶</a></h3><ul><li>一般类型：<code>operator type() const;</code></li><li>语法相关：<ul><li>可以转换到任意类型（除了void），只要该类型能作为函数的返回类型</li><li>必须是类的成员函数，不能声明返回类型（但是函数返回一个对应类型的值），形参列表为空，一般为const成员函数</li></ul></li><li>使用：<ul><li>类型转换运算符不需要显式调用，在执行运算时会隐式的执行</li><li>尽量确保类型转换是有意义的，避免过度使用</li><li>尽管编译器一次只能执行一个【用户定义的类型转换】，但是隐式的【用户定义的类型转换】可以置于一个标准内置类型转换之前或之后</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>smallInt</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>smallInt</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span><span class=o>:</span> <span class=n>val</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span><span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&lt;</span><span class=mi>0</span> <span class=o>||</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>255</span><span class=p>)</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;bad value&#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>        <span class=k>operator</span> <span class=nf>int</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span><span class=k>return</span> <span class=o>-</span><span class=n>val</span><span class=p>;}</span> <span class=c1>// 为了说明类型转换运算符的效果
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>smallInt</span> <span class=n>s</span> <span class=o>=</span> <span class=mf>2.1</span><span class=p>;</span> <span class=c1>// 先将double转换为int，再使用转换构造函数将int转换为smallInt
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>s</span> <span class=o>+</span> <span class=mf>2.1</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>  <span class=c1>// 使用【类型转换运算符】将s隐式地转换为int，再转换为double相加
</span></span></span></code></pre></td></tr></table></div></div></li><li>显式的类型转换运算符（C++11）：<code>explicit operator type() const;</code><ul><li>需要使用<code>static_cast&lt;type></code>进行显式的类型转换<ul><li>例外：当表达式被用作条件时，显式的类型转换将被隐式的执行</li></ul></li><li>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的。</li></ul></li></ul><h3 id=避免有二义性的类型转换>避免有二义性的类型转换<a hidden class=anchor aria-hidden=true href=#避免有二义性的类型转换>¶</a></h3><ul><li>必须确保在类类型和目标类型之间只存在唯一一种转换方式，否则很可能有二义性</li><li>两种情况会产生多重转换路径：<ul><li>【用A的转换构造函数还是B的类型转换运算符】：A类定义了一个参数为B类的转换构造函数，B类定义了一个目标类型为A类的类型转换运算符，此时可以显式指定调用哪一种<ul><li>无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>B</span><span class=p>;</span>    
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>()</span> <span class=o>=</span><span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(</span><span class=k>const</span> <span class=o>&amp;</span><span class=n>B</span><span class=p>);</span> <span class=c1>// 转换构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>B</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=nf>A</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span> <span class=c1>// 类型转换运算符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=nf>f</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span><span class=p>);</span> <span class=c1>// 定义一个函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>B</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span> <span class=o>=</span> <span class=n>f</span><span class=p>(</span><span class=n>b</span><span class=p>);</span> <span class=c1>// 二义性：使用B的【类型转换运算符】，还是使用A的【转换构造函数】
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>a1</span> <span class=o>=</span> <span class=n>f</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=k>operator</span> <span class=n>A</span><span class=p>());</span> <span class=c1>// 使用B的类型转换运算符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>A</span> <span class=n>a2</span> <span class=o>=</span> <span class=n>f</span><span class=p>(</span><span class=n>A</span><span class=p>(</span><span class=n>b</span><span class=p>));</span> <span class=c1>// 使用A的转换构造函数
</span></span></span></code></pre></td></tr></table></div></div></li><li>【有多个类型转换运算符，用哪个】：类定义了多个类型转换规则，转换目标为内置类型，且转换级别一致<ul><li>标准类型转换的级别决定编译器如何选择最佳匹配，转换级别一致就会出现二义性</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>A</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>(</span><span class=kt>double</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=nf>int</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=nf>double</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>long</span> <span class=kt>double</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> <span class=c1>// 二义性错误：a转换成int还是转换成double，再提升为long double
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>short</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=nf>a2</span><span class=p>(</span><span class=n>s</span><span class=p>);</span> <span class=c1>// 不会产生二义性错误，因为short类型提升为int优先于short类型提升为double
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li>经验：尽量避免定义类型转换，且限制非显式构造函数<ul><li>不要令两个类执行相同的类型转换</li><li>避免转换目标是内置算数类型的类型转换，特别是已经定义了一个转换成算数类型的类型转换</li></ul></li></ul><h3 id=重载与函数匹配>重载与函数匹配<a hidden class=anchor aria-hidden=true href=#重载与函数匹配>¶</a></h3><ul><li>[[ch06-函数#6.6 函数匹配|函数匹配]]</li><li>重载函数与转换构造函数<ul><li>当调用重载函数时，如果两个或多个类型转换都提供了同一种可行匹配，则这些类型转换一样好</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>C</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>C</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>D</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>D</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=k>const</span> <span class=n>C</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=k>const</span> <span class=n>D</span><span class=o>&amp;</span><span class=p>);</span> <span class=c1>// 重载函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>func</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span> <span class=c1>// 二义性错误：
</span></span></span></code></pre></td></tr></table></div></div></li><li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=efa03877-7c33-c199-b557-f956b4531c90&amp;page=546&amp;rect=70.080,407.290,216.481,415.930">重载函数与用户定义的类型转换</a></li><li>重载运算符与函数匹配<ul><li>如果既定义了类型转换运算符（转换到内置类型），又将运算符进行重载，会遇到二义性问题<ul><li>如果<code>a</code>是一种类类型，则表达式<code>a sym b</code>可能是：<ul><li><code>a.operatorsym(b);</code> 成员函数</li><li><code>operatorsym(a,b);</code> 普通函数</li></ul></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>T</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=n>T</span> <span class=k>operator</span><span class=o>+</span> <span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>);</span> <span class=c1>// 转换构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>operator</span> <span class=nf>int</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>  <span class=c1>// 类型转换运算符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>t</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 二义性：可以将t转换成int进行内置加法，或者将1转换成类型T进行重载加法
</span></span></span></code></pre></td></tr></table></div></div></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://qinganzhang.github.io/posts/cpp-primer/ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Ch15 面向对象程序设计</span>
</a><a class=next href=https://qinganzhang.github.io/posts/cpp-primer/ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Ch13 拷贝控制</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://qinganzhang.github.io/>Paul's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>