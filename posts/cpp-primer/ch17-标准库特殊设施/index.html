<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ch17 标准库特殊设施 | Paul's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="第十六章 模板和泛型编程 16.1 定义模板 模板参数列表：<> 模板参数（也称(模板)类型参数）：T typename或class（作用相同），"><meta name=author content="Paul"><link rel=canonical href=https://qinganzhang.github.io/posts/cpp-primer/ch17-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://qinganzhang.github.io/favicon.ico><link rel=apple-touch-icon href=https://qinganzhang.github.io/apple-touch-icon.png><meta name=twitter:title content="Ch17 标准库特殊设施 | Paul's Blog"><meta name=twitter:description content="第十六章 模板和泛型编程 16.1 定义模板 模板参数列表：<> 模板参数（也称(模板)类型参数）：T typename或class（作用相同），"><meta property="og:title" content="Ch17 标准库特殊设施 | Paul's Blog"><meta property="og:description" content="第十六章 模板和泛型编程 16.1 定义模板 模板参数列表：<> 模板参数（也称(模板)类型参数）：T typename或class（作用相同），"><meta property="og:type" content="article"><meta property="og:url" content="https://qinganzhang.github.io/posts/cpp-primer/ch17-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T15:58:50+08:00"><meta property="article:modified_time" content="2024-02-27T15:58:50+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://qinganzhang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Ch17 标准库特殊设施","item":"https://qinganzhang.github.io/posts/cpp-primer/ch17-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ch17 标准库特殊设施 | Paul's Blog","name":"Ch17 标准库特殊设施","description":"第十六章 模板和泛型编程 16.1 定义模板 模板参数列表：\u0026lt;\u0026gt; 模板参数（也称(模板)类型参数）：T typename或class（作用相同），","keywords":["cpp"],"wordCount":"8091","inLanguage":"en","datePublished":"2024-02-27T15:58:50+08:00","dateModified":"2024-02-27T15:58:50+08:00","author":{"@type":"Person","name":"Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qinganzhang.github.io/posts/cpp-primer/ch17-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/"},"publisher":{"@type":"Organization","name":"Paul's Blog","logo":{"@type":"ImageObject","url":"https://qinganzhang.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://qinganzhang.github.io/ accesskey=h title="Paul's Blog (Alt + H)">Paul's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://qinganzhang.github.io/posts/ title=Posts class=active>Posts</a></li><li><a href=https://qinganzhang.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://qinganzhang.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://qinganzhang.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://qinganzhang.github.io/categories/ title=Categories>Categories</a></li><li><a href=https://qinganzhang.github.io/about/ title=About>About</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qinganzhang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://qinganzhang.github.io/posts/>Post</a></div><h1 class=post-title>Ch17 标准库特殊设施</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-02-27</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://qinganzhang.github.io/tags/cpp/>cpp</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>8091 words</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>17 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ac%ac%e5%8d%81%e5%85%ad%e7%ab%a0-%e6%a8%a1%e6%9d%bf%e5%92%8c%e6%b3%9b%e5%9e%8b%e7%bc%96%e7%a8%8b aria-label="第十六章 模板和泛型编程">第十六章 模板和泛型编程</a><ul><li><a href=#161-%e5%ae%9a%e4%b9%89%e6%a8%a1%e6%9d%bf aria-label="16.1 定义模板">16.1 定义模板</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf aria-label=函数模板>函数模板</a></li><li><a href=#%e7%b1%bb%e6%a8%a1%e6%9d%bf aria-label=类模板>类模板</a></li><li><a href=#%e6%a8%a1%e6%9d%bf%e5%8f%82%e6%95%b0 aria-label=模板参数>模板参数</a></li><li><a href=#%e6%88%90%e5%91%98%e6%a8%a1%e6%9d%bf aria-label=成员模板>成员模板</a></li><li><a href=#%e6%98%be%e5%bc%8f%e5%ae%9e%e4%be%8b%e5%8c%96 aria-label=显式实例化>显式实例化</a></li><li><a href=#%e6%95%88%e7%8e%87%e4%b8%8e%e7%81%b5%e6%b4%bb%e6%80%a7 aria-label=效率与灵活性>效率与灵活性</a></li></ul></li><li><a href=#162-%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e5%ae%9e%e5%8f%82%e6%8e%a8%e6%96%ad aria-label="16.2 函数模板实参推断">16.2 函数模板实参推断</a><ul><li><a href=#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e4%b8%8e%e6%a8%a1%e6%9d%bf%e7%b1%bb%e5%9e%8b%e5%8f%82%e6%95%b0 aria-label=类型转换与模板类型参数>类型转换与模板类型参数</a></li><li><a href=#%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e6%98%be%e5%bc%8f%e5%ae%9e%e5%8f%82 aria-label=函数模板显式实参>函数模板显式实参</a></li><li><a href=#%e5%b0%be%e7%bd%ae%e8%bf%94%e5%9b%9e%e7%b1%bb%e5%9e%8b%e4%b8%8e%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label=尾置返回类型与类型转换>尾置返回类型与类型转换</a><ul><li><a href=#%e5%b0%be%e7%bd%ae%e8%bf%94%e5%9b%9e%e7%b1%bb%e5%9e%8b aria-label=尾置返回类型>尾置返回类型</a></li><li><a href=#%e5%b0%be%e7%bd%ae%e8%bf%94%e5%9b%9e%e7%b1%bb%e5%9e%8b%e5%90%8e%e8%bf%9b%e8%a1%8c%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label=尾置返回类型后进行类型转换>尾置返回类型后进行类型转换</a></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88%e5%92%8c%e5%ae%9e%e5%8f%82%e6%8e%a8%e6%96%ad aria-label=函数指针和实参推断>函数指针和实参推断</a></li><li><a href=#%e6%a8%a1%e6%9d%bf%e5%ae%9e%e5%8f%82%e6%8e%a8%e6%96%ad%e5%92%8c%e5%bc%95%e7%94%a8 aria-label=模板实参推断和引用>模板实参推断和引用</a><ul><li><a href=#%e6%a8%a1%e6%9d%bf%e5%8f%82%e6%95%b0t%e7%9a%84%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad aria-label=模板参数T&amp;amp;的类型推断>模板参数<code>T&</code>的类型推断</a></li><li><a href=#%e5%bc%95%e7%94%a8%e6%8a%98%e5%8f%a0 aria-label=引用折叠>引用折叠</a></li><li><a href=#stdmove aria-label=std::move><code>std::move</code></a></li></ul></li><li><a href=#%e8%bd%ac%e5%8f%91 aria-label=转发>转发</a></li></ul></li><li><a href=#163-%e9%87%8d%e8%bd%bd%e4%b8%8e%e6%a8%a1%e6%9d%bf aria-label="16.3 重载与模板">16.3 重载与模板</a></li><li><a href=#164-%e5%8f%af%e5%8f%98%e5%8f%82%e6%95%b0%e6%a8%a1%e6%9d%bf aria-label="16.4 可变参数模板">16.4 可变参数模板</a><ul><li><a href=#%e7%bc%96%e5%86%99%e5%8f%af%e5%8f%98%e5%8f%82%e6%95%b0%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf aria-label=编写可变参数函数模板>编写可变参数函数模板</a></li><li><a href=#%e5%8c%85%e6%89%a9%e5%b1%95 aria-label=包扩展>包扩展</a></li><li><a href=#%e8%bd%ac%e5%8f%91%e5%8f%82%e6%95%b0%e5%8c%85 aria-label=转发参数包>转发参数包</a></li></ul></li><li><a href=#165-%e6%a8%a1%e6%9d%bf%e7%89%b9%e4%be%8b%e5%8c%96specializations aria-label="16.5 模板特例化（Specializations）">16.5 模板特例化（Specializations）</a><ul><li><a href=#%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e7%89%b9%e4%be%8b%e5%8c%96 aria-label=定义函数模板特例化>定义函数模板特例化</a></li><li><a href=#%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd%e4%b8%8e%e6%a8%a1%e6%9d%bf%e7%89%b9%e4%be%8b%e5%8c%96 aria-label=函数重载与模板特例化>函数重载与模板特例化</a></li><li><a href=#%e7%b1%bb%e6%a8%a1%e6%9d%bf%e7%89%b9%e4%be%8b%e5%8c%96 aria-label=类模板特例化>类模板特例化</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=第十六章-模板和泛型编程>第十六章 模板和泛型编程<a hidden class=anchor aria-hidden=true href=#第十六章-模板和泛型编程>¶</a></h1><h2 id=161-定义模板>16.1 定义模板<a hidden class=anchor aria-hidden=true href=#161-定义模板>¶</a></h2><ul><li>模板参数列表：<code>&lt;></code></li><li>模板参数（也称(模板)类型参数）：<code>T</code><ul><li><code>typename</code>或<code>class</code>（作用相同），用来表示模板参数</li></ul></li><li>模板非类型参数：模板参数列表中表示一个值而非一个类型</li></ul><h3 id=函数模板>函数模板<a hidden class=anchor aria-hidden=true href=#函数模板>¶</a></h3><ul><li>模板实例化时，可以使用[[ch16-模板和泛型编程#函数模板显式实参|显式实参]]，根据实参[[ch16-模板和泛型编程#类型转换与模板类型参数|隐式推断模板参数类型]]</li><li>模板非类型参数：<ul><li>可以是一个整型、指针或左值引用</li><li>实例化时，整型实参必须是常量表达式，指针/引用指向的对象必须有静态的生存周期（即对象不能是非static局部变量或动态对象），这样做可以使编译器在编译时实例化模板</li><li>使用场景：比如数组类型作为模板参数时大小固定，但是使用模板非类型参数就不必固定<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>N</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>M</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>T</span> <span class=n>compare</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>r1</span><span class=p>)[</span><span class=n>N</span><span class=p>],</span> <span class=k>const</span> <span class=kt>char</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>r2</span><span class=p>)[</span><span class=n>M</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>strcmp</span><span class=p>(</span><span class=n>r1</span><span class=p>,</span> <span class=n>r2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li><code>inline</code>或<code>constexpr</code>的函数模板：模板参数列表之后，返回类型之前</li><li>模板编译<ul><li>只有模板实例化时，编译器才生成代码</li><li>通常将类定义和函数声明放在头文件中，其实现放在源文件中；但是，函数模板和类模板成员函数的实现通常也放在头文件中。因为编译器知道模板的完整定义后才能进行实例化</li><li>大多数模板的编译错误在实例化期间才报告</li></ul></li></ul><h3 id=类模板>类模板<a hidden class=anchor aria-hidden=true href=#类模板>¶</a></h3><ul><li>使用类模板必须提供显式模板参数列表，编译器不能推断模板参数类型</li><li>一个类模板的成员函数只有当程序用到它时，才进行<span id=类模板的实例化>实例化</span></li><li>使用类模板类型时必须提供模板参数，只有在类模板作用域内部才可以只使用模板名而不提供实参</li><li>友元相关，<a href=https://blog.csdn.net/caroline_wendy/article/details/16916441>例子</a><ul><li>如果一个类模板包含一个非模板友元，则友元可以访问该类模板的所有实例</li><li>如果一个类模板包含一个模板友元，则类可以授权给所有友元模板实例，也可以只授权给特定实例<ul><li>一对一友好关系：友好关系被限定在相同类型的友元和类本身之间<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Fri</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>MyClass</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span> <span class=p>(</span><span class=k>const</span> <span class=n>MyClass</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>MyClass</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>MyClass</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=k>class</span> <span class=nc>Fri</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// 比如Fri&lt;int&gt;实例可以访问MyClass&lt;int&gt;实例
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=k>const</span> <span class=n>MyClass</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span> <span class=k>const</span> <span class=n>MyClass</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>);</span> <span class=c1>// 友元函数，重载==
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>MyClass</span><span class=p>()</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=n>MyClass</span><span class=p>(</span><span class=k>const</span> <span class=n>MyClass</span><span class=o>&amp;</span> <span class=n>m</span><span class=p>)</span><span class=o>:</span> <span class=n>v</span><span class=p>(</span><span class=n>m</span><span class=p>.</span><span class=n>v</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=nf>push_back</span><span class=p>(</span><span class=n>T</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span> <span class=n>v</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>val</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>MyClass</span> <span class=nf>clone</span><span class=p>();</span> <span class=c1>// 处于类模板作用域中，编译器会将MyClass当作是MyClass&lt;T&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=n>MyClass</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>MyClass</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>clone</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=nf>MyClass</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Fri</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	  <span class=c1>// 一对一友好关系，Fri&lt;T&gt;是MyClass&lt;T&gt;的友元
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span> <span class=n>size</span><span class=p>(</span><span class=n>MyClass</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>m</span><span class=p>.</span><span class=n>v</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	  <span class=c1>// 但是Fri&lt;T&gt;就不是MyClass&lt;K&gt;的友元(T!=K)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=n>MyClass</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>m</span><span class=p>.</span><span class=n>v</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>MyClass</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span> <span class=n>char_class</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>MyClass</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>int_class</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>Fri</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span> <span class=n>fri</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fri</span><span class=p>.</span><span class=n>size</span><span class=p>(</span><span class=n>char_class</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// fri.func(int_class);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>    
</span></span></code></pre></td></tr></table></div></div></li><li>通用和特定的模板友好关系：一个类可以将另一个模板的每个实例都声明为为自己的友元，或者限定特定的实例为友元<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Fri</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Common</span><span class=p>{</span> <span class=c1>// 普通类
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>K</span><span class=o>&gt;</span> <span class=k>friend</span> <span class=k>class</span> <span class=nc>Pal</span><span class=p>;</span> <span class=c1>// 【Pal的所有实例】都是类Common的友元，此时Fri可以不用提前声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>MyClass</span><span class=p>{</span> <span class=c1>// 模板类
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>friend</span> <span class=k>class</span> <span class=nc>Fri</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// 一对一友元
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>K</span><span class=o>&gt;</span> <span class=k>friend</span> <span class=k>class</span> <span class=nc>MyFri</span><span class=p>;</span> <span class=c1>// 【MyPal的所有实例】都是MyClass每个实例的友元，此时MyPal可以不用提前声明，且声明中使用了不同的模板参数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>friend</span> <span class=k>class</span> <span class=nc>Commom_fri</span><span class=p>;</span> <span class=c1>// 普通类作为模板类的友元，此时不需要提前声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>      
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li>虽然友元通常是类或函数，但是允许将模板类型参数<code>T</code>作为友元，因此类型<code>T</code>的对象可以访问类模板的private成员。<a href=https://blog.csdn.net/craftsman1970/article/details/81748184>例子</a>。<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>MyClass</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=n>T</span><span class=p>;</span> <span class=c1>// 类型T是MyClass的友元
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>private_func</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=s>&#34;private func of MyClass &#34;</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Test</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>func</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>		<span class=n>test</span><span class=p>.</span><span class=n>private_func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>MyClass</span><span class=o>&lt;</span><span class=n>Test</span><span class=o>&gt;</span> <span class=n>test</span><span class=p>;</span> <span class=c1>// 类型Test是MyClass的友元，Test类型的对象可以访问【类模板MyClass基于Test类型的实例】的private成员
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Test</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>t</span><span class=p>.</span><span class=n>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li>模板类型别名<ul><li>为类模板的实例创建别名：<code>typedef MyClass&lt;int> MC;</code></li><li>为类模板定义别名：<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>K</span><span class=p>,</span> <span class=k>typename</span> <span class=n>V</span><span class=o>&gt;</span> <span class=k>using</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>K</span><span class=o>&gt;</span> <span class=k>using</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// 固定一个类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>using</span> <span class=n>p</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span><span class=p>;</span>  
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li>类模板的static成员<ul><li>相同类型类模板的实例的static成员是共享的，不同类型之间类模板的实例的static成员是不同的</li></ul></li></ul><h3 id=模板参数>模板参数<a hidden class=anchor aria-hidden=true href=#模板参数>¶</a></h3><ul><li>模板内不能重用模板参数名，且同一个模板参数名<code>T</code>在同一个模板参数列表中只能出现一次</li><li>声明中的模板参数不必与定义中的模板参数相同，且模板声明通常一起放在文件开始位置（使用模板的代码之前）</li><li>使用<code>T::mem</code>，无法判断mem是类型T的static成员还是类型T的类型成员<ul><li>普通类中编译器已知类的定义因此可以判断</li><li>默认<code>T::mem</code>访问的是static成员</li><li>使用<code>typename</code>显式说明访问的是类型<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>using</span> <span class=n>age</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>;</span> <span class=c1>// 类型成员
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>;</span> <span class=c1>// static成员
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>Person</span><span class=o>::</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;zhang&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>MyClass</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>typename</span> <span class=n>T</span><span class=o>::</span><span class=n>age</span> <span class=n>func</span><span class=p>(){</span> <span class=c1>// 显式说明T::age是一个类型而非static成员
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>T</span><span class=o>::</span><span class=n>name</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// 默认T::name是static成员
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>typename</span> <span class=n>T</span><span class=o>::</span><span class=n>age</span> <span class=n>myAge</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=n>myAge</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>  
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li>默认模板实参：默认模板实参都在最右侧，对函数模板和类模板都可以提供默认模板实参</li></ul><h3 id=成员模板>成员模板<a hidden class=anchor aria-hidden=true href=#成员模板>¶</a></h3><ul><li>成员模板：普通类或模板类的成员函数是模板函数，成员模板不能是虚函数</li><li>普通类的成员模板<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span><span class=p>{</span> <span class=c1>// 普通类中包含成员模板
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 普通类中的成员模板
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>MyClass</span><span class=o>::</span><span class=n>func</span><span class=p>(</span><span class=n>T</span> <span class=n>t</span><span class=p>){</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>t</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Test</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=n>T</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 对比模板类中的普通成员函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>Test</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>func</span><span class=p>(</span><span class=n>T</span> <span class=n>t</span><span class=p>){</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>t</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>MyClass</span> <span class=n>myClass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>myClass</span><span class=p>.</span><span class=n>func</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=c1>// 普通类中的成员模板
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Test</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>test</span><span class=p>.</span><span class=n>func</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> <span class=c1>// 模板类中的普通函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li>类模板的成员模板<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>MyClass</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>MyClass</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>K</span><span class=o>&gt;</span> <span class=n>MyClass</span><span class=p>(</span><span class=n>K</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=k>typeid</span><span class=p>(</span><span class=n>T</span><span class=p>).</span><span class=n>name</span><span class=p>()</span><span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span> <span class=k>typeid</span><span class=p>(</span><span class=n>K</span><span class=p>).</span><span class=n>name</span><span class=p>()</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>		<span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>H</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=n>H</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=c1>// 类模板的模板参数列表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>H</span><span class=o>&gt;</span> <span class=c1>// 类模板的成员模板的模板参数列表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>MyClass</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>func</span><span class=p>(</span><span class=n>H</span> <span class=n>h</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=k>typeid</span><span class=p>(</span><span class=n>T</span><span class=p>).</span><span class=n>name</span><span class=p>()</span><span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span> <span class=k>typeid</span><span class=p>(</span><span class=n>H</span><span class=p>).</span><span class=n>name</span><span class=p>()</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>    
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>MyClass</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>myClass</span><span class=p>(</span><span class=sc>&#39;k&#39;</span><span class=p>);</span> <span class=c1>// 显式提供T=int, 隐式推断K=char
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>myClass</span><span class=p>.</span><span class=n>func</span><span class=p>(</span><span class=mf>3.14</span><span class=p>);</span> <span class=c1>// 隐式推断H=double
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>myClass</span><span class=p>.</span><span class=n>func</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;str&#34;</span><span class=p>);</span> <span class=c1>// 显式提供H=string
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=显式实例化>显式实例化<a hidden class=anchor aria-hidden=true href=#显式实例化>¶</a></h3><ul><li>背景：模板只有使用时才被实例化，因此相同的实例可能出现在多个文件中，造成额外开销</li><li>显式实例化<ul><li>当编译器遇到<code>extern</code>模板声明时，不会在本文件中生成模板的实例化代码，表示使用其他位置的实例化代码</li><li><code>extern</code>声明必须出现在使用此实例化版本的代码之前，否则编译器进行实例化，起不到外部定义的效果</li><li>显式实例化定义会实例化所有成员</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 在a.cpp中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>template</span> <span class=k>class</span> <span class=nc>MyClass</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// 实例化声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>template</span> <span class=kt>int</span> <span class=n>compare</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span><span class=o>&amp;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 在b.cpp中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=k>class</span> <span class=nc>MyClass</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// 实例化定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=kt>int</span> <span class=nf>compare</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=效率与灵活性>效率与灵活性<a hidden class=anchor aria-hidden=true href=#效率与灵活性>¶</a></h3><ul><li>shared_ptr在运行时绑定删除器，因此删除器保存为一个指针而不是一个成员，因此删除器的类型直到运行时才直到，而且可以随时改变删除器的类型<ul><li>需要间接调用删除器，但是用户重载删除器的操作更加便捷（只需要传入一个可调用对象）</li></ul></li><li>unique_ptr在编译期绑定删除器，删除器的类型是类类型的一部分（因此删除器类型在编译器是已知的），从而删除器可以直接保存在成员中<ul><li>避免了间接调用删除器的运行时开销</li></ul></li></ul><h2 id=162-函数模板实参推断>16.2 函数模板实参推断<a hidden class=anchor aria-hidden=true href=#162-函数模板实参推断>¶</a></h2><ul><li>可以[[ch16-模板和泛型编程#类型转换与模板类型参数|基于实参推导模板参数类型]]，也可以[[ch16-模板和泛型编程#函数指针和实参推断|函数指针指向函数模板推导模板参数类型]]</li><li>有时比如返回值类型无法推导出来，可以指定[[ch16-模板和泛型编程#函数模板显式实参|模板显式实参]]，也可以使用[[ch16-模板和泛型编程#尾置返回类型与类型转换|尾置返回类型]]（同时可以[[ch16-模板和泛型编程#尾置返回类型后进行类型转换|去除引用]]）</li><li>当模板类型<code>T</code>为引用时，需要依据实参是左值/右值来判断T的引用类型，而且可以使用完美转发保持实参的类型不变</li></ul><h3 id=类型转换与模板类型参数>类型转换与模板类型参数<a hidden class=anchor aria-hidden=true href=#类型转换与模板类型参数>¶</a></h3><ul><li>模板实参推断：根据实参类型推断出模板参数<code>T</code>的类型<ul><li>一般<code>T</code>就是实参类型</li><li>编译器会对以下几种实参进行类型转换，得到的<code>T</code>并不完全是实参类型<ul><li>顶层<code>const</code>会被忽略</li><li>可以将非const对象的指针或引用传递给一个const的指针或引用形参</li><li>如果形参不是引用类型，数组名/函数名转换为指针类型</li></ul></li></ul></li><li><code>template&lt;typename T> void func(T a, T b);</code>中，a和b推断的类型必须相同</li></ul><h3 id=函数模板显式实参>函数模板显式实参<a hidden class=anchor aria-hidden=true href=#函数模板显式实参>¶</a></h3><ul><li>背景：类型<code>T</code>只出现在返回值/函数体，不在形参列表中时，编译器无法推断出模板实参的类型：</li><li>函数模板显式实参从左到右进行对应，如果模板参数可以推导出来，放在模板参数列表右侧，实例化时可以进行推导</li><li>当显式指定实参时，对实参可以使用正常的类型转换</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T2</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T3</span><span class=o>&gt;</span> <span class=n>T1</span> <span class=n>sum</span><span class=p>(</span><span class=n>T2</span><span class=p>,</span> <span class=n>T3</span><span class=p>);</span> <span class=c1>// T1在返回值中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=kt>double</span> <span class=o>=</span> <span class=mf>2.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>sum</span><span class=o>&lt;</span><span class=kt>long</span> <span class=kt>long</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span> <span class=c1>// T1类型是long long, T2、T3类型可以推导出来，放在右侧
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>test</span> <span class=o>=</span> <span class=n>sum</span><span class=o>&lt;</span><span class=kt>long</span> <span class=kt>long</span><span class=p>,</span> <span class=kt>long</span> <span class=kt>long</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span> <span class=c1>// T2类型显式指定为long long，因此将a转换为long long型
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>int</span> <span class=n>compare</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>cmp</span> <span class=o>=</span> <span class=n>compare</span><span class=o>&lt;</span><span class=kt>long</span> <span class=kt>long</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span> <span class=c1>// 使用显式模板实参，a、b都转换为long long类型
</span></span></span></code></pre></td></tr></table></div></div><h3 id=尾置返回类型与类型转换>尾置返回类型与类型转换<a hidden class=anchor aria-hidden=true href=#尾置返回类型与类型转换>¶</a></h3><h4 id=尾置返回类型>尾置返回类型<a hidden class=anchor aria-hidden=true href=#尾置返回类型>¶</a></h4><ul><li>背景：有时函数模板的返回值类型不能由实参推导而来，比如[[ch16-模板和泛型编程#函数模板显式实参|函数模板显式实参]]的背景<ul><li>可以使用函数模板显式实参进行指定，也可以<strong>使用尾置返回类型自动推导</strong></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Iter</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>func</span><span class=p>(</span><span class=n>Iter</span> <span class=n>beg</span><span class=p>,</span> <span class=n>Iter</span> <span class=n>end</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=k>decltype</span><span class=p>(</span><span class=o>*</span><span class=n>beg</span><span class=p>){</span> <span class=c1>// 从局部变量中推导出返回类型
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=o>*</span><span class=n>beg</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=尾置返回类型后进行类型转换>尾置返回类型后进行类型转换<a hidden class=anchor aria-hidden=true href=#尾置返回类型后进行类型转换>¶</a></h4><ul><li>背景：通过模板显式实参可以指定返回值类型，但是通过尾置返回类型推导得到的类型可能不是想要的，比如有时不希望得到引用类型</li><li><strong>标准库的类型转换模板</strong><ul><li>定义在头文件<code>type_traits</code>中，常用于模板元程序设计</li><li>Mod是一个类模板，将类型<code>T</code>转换为类型<code>type</code>；如果无法转化，则类型<code>type</code></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Iter</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>func</span><span class=p>(</span><span class=n>Iter</span> <span class=n>beg</span><span class=p>,</span> <span class=n>Iter</span> <span class=n>end</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=k>typename</span> <span class=n>remove_reference</span><span class=o>&lt;</span><span class=k>decltype</span><span class=p>(</span><span class=o>*</span><span class=n>beg</span><span class=p>)</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>{</span> <span class=c1>// 表明type是一个类型而非一个static成员
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=o>*</span><span class=n>beg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th><code>Mod</code></th><th><code>T</code></th><th><code>Mod&lt;T>::type</code></th></tr></thead><tbody><tr><td><code>remove_reference</code></td><td><code>X&</code>或<code>X&&</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>add_const</code></td><td><code>X&</code>或<code>const X</code>或函数</td><td><code>T</code></td></tr><tr><td></td><td>否则</td><td><code>const T</code></td></tr><tr><td><code>add_lvalue_reference</code></td><td><code>X&</code></td><td><code>T</code></td></tr><tr><td></td><td><code>X&&</code></td><td><code>X&</code></td></tr><tr><td></td><td>否则</td><td><code>T&</code></td></tr><tr><td><code>add_rvalue_reference</code></td><td><code>X&</code>或<code>X&&</code></td><td><code>T</code></td></tr><tr><td></td><td>否则</td><td><code>T&&</code></td></tr><tr><td><code>remove_pointer</code></td><td><code>X*</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>add_pointer</code></td><td><code>X&</code>或<code>X&&</code></td><td><code>X*</code></td></tr><tr><td></td><td>否则</td><td><code>T*</code></td></tr><tr><td><code>make_signed</code></td><td><code>unsigned X</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>make_unsigned</code></td><td>带符号类型</td><td><code>unsigned X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>remove_extent</code></td><td><code>X[n]</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>remove_all_extents</code></td><td><code>X[n1][n2]...</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr></tbody></table><h3 id=函数指针和实参推断>函数指针和实参推断<a hidden class=anchor aria-hidden=true href=#函数指针和实参推断>¶</a></h3><ul><li>将函数模板赋值给函数指针：<ul><li>函数指针指向函数模板的一个实例</li><li>使用函数指针的类型来推断模板实参</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>int</span> <span class=n>compare</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>f</span><span class=p>)(</span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=n>compare</span><span class=p>;</span>  <span class=c1>// T是int，f指向函数模板的实例compare(const int&amp;, const int&amp;)
</span></span></span></code></pre></td></tr></table></div></div></li><li>如果函数func的形参是函数指针，实参可以传入函数模板，这样函数指针指向一个模板实例且进行了参数推断<ul><li>但是当func有多个重载的版本时（接受不同类型的函数指针），传入函数模板可能产生歧义，此时可以指定【显式模板实参】</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>int</span> <span class=n>compare</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)(</span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span><span class=p>));</span> <span class=c1>// 重载
</span></span></span><span class=line><span class=cl><span class=c1>// func(compare); // 歧义：函数模板compare实例化为哪一种函数指针？
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>func</span><span class=p>(</span><span class=n>compare</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>  
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=模板实参推断和引用>模板实参推断和引用<a hidden class=anchor aria-hidden=true href=#模板实参推断和引用>¶</a></h3><h4 id=模板参数t的类型推断>模板参数<code>T&</code>的类型推断<a hidden class=anchor aria-hidden=true href=#模板参数t的类型推断>¶</a></h4><table><thead><tr><th style=text-align:center>模板类型参数</th><th style=text-align:center>实参要求</th><th style=text-align:center>例子</th></tr></thead><tbody><tr><td style=text-align:center><code>T&</code></td><td style=text-align:center>必须传递一个左值</td><td style=text-align:center>实参为<code>int</code>，<code>T</code>为<code>int</code>;实参为<code>const int</code>，<code>T</code>为<code>const int</code></td></tr><tr><td style=text-align:center><code>const T&</code></td><td style=text-align:center>可以传递左值或右值</td><td style=text-align:center>实参为<code>int, const int, const int&&</code>，<code>T</code>都为<code>int</code></td></tr><tr><td style=text-align:center><code>T&&</code></td><td style=text-align:center>必须传递一个右值</td><td style=text-align:center>实参为<code>int&&</code>， <code>T</code>为<code>int</code></td></tr><tr><td style=text-align:center><code>T&&</code></td><td style=text-align:center>例外：传递一个类型为<code>type</code>的左值，推导<code>T</code>为<code>type&</code>类型</td><td style=text-align:center>实参为<code>int&</code>,<code>T</code>为<code>int&</code></td></tr></tbody></table><h4 id=引用折叠>引用折叠<a hidden class=anchor aria-hidden=true href=#引用折叠>¶</a></h4><ul><li>背景：基于上面这个例外，创造出了引用的引用，或者通过类型别名也可以创造出引用的引用，可以将多个引用折叠为一个引用</li><li>引用折叠规则：<ul><li><code>type& &、 type& &&、 type&& &</code>折叠为<code>type &</code></li><li><code>type&& &&</code>折叠为<code>T&&</code></li></ul></li><li>使用：<ul><li>若函数形参是<code>T&&</code>，则可以传递一个左值（实参的const属性可以保持，因为是底层const）</li><li>如果传入的是左值<code>type&</code>，推导出<code>T=type&</code></li><li>万能引用（或称为模板类型参数右值引用）：函数形参为<code>T&&</code>时，传递左值/右值均可<ul><li>使用万能引用导致只有在运行时才能确定形参是左值还是右值，使得模板的编写变得困难</li><li>通常在两种情况中使用万能引用：模板转发实参，模板重载</li><li>使用万能引用的形参通常重载为两个版本：<ul><li>拷贝版本：<code>template&lt;typename T> void f(const T&)</code> 绑定到左值和const右值</li><li>移动版本：<code>template&lt;typename T> void f(T&&)</code> 绑定到非const右值</li></ul></li></ul></li></ul></li></ul><h4 id=stdmove><code>std::move</code><a hidden class=anchor aria-hidden=true href=#stdmove>¶</a></h4><ul><li>[[ch13-拷贝控制#^d3a2a0|std::move函数]]的定义：<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>typename</span> <span class=n>remove_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>&amp;&amp;</span> <span class=n>move</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>remove_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>type</span><span class=o>&amp;&amp;&gt;</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li>可以使用<code>static_cast</code>显式地将左值转换为右值引用</li></ul><h3 id=转发>转发<a hidden class=anchor aria-hidden=true href=#转发>¶</a></h3><ul><li>背景：比如函数f内部调用函数g时，可能需要将f的实参传递给g，而且同时要求保持实参性质不变（比如const属性，左值/右值属性）<ul><li>即希望达到这样的效果：将实参传递给f，再传递给g，与实参直接传递给g，的效果等价</li><li>例子一：f形参类型是非引用，g形参类型是左值引用，传入一个左值引用，则此时f转发参数给g时会使用自己的拷贝而非原来的引用</li><li>例子二：f形参类型是万能引用<code>T&&</code>，g形参类型是右值引用，f可以接受右值（或左值），此时f转发参数给g时，使用的右值引用本身是一个左值，不能传参给g的右值引用</li></ul></li><li>比较：都是定义在<code>utility</code>中的函数模板，最好显式指明是<code>std::</code>中的<ul><li><code>std::forward</code>：可指定模板参数，并且可以对返回值使用引用折叠来保留左右值属性</li><li><code>std::move</code>：返回值一定是右值引用</li></ul></li><li>使用：完美转发<ul><li>通过万能引用在传入外层f时保留实参的全部属性</li><li>通过<code>std::forward</code>在传入内层函数g时再次保留实参的全部属性</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;&amp;</span><span class=n>arg</span><span class=p>){</span> <span class=c1>// 万能引用
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>g</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>arg</span><span class=p>));</span> <span class=c1>// std::forward&lt;T&gt;的返回类型是T&amp;&amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>如果实参是左值，推导出<code>T=type&</code>，<code>std::forward&lt;T></code>的返回类型<code>T&&</code>折叠为<code>type&</code></li><li>如果实参是右值，推导出<code>T=type</code>，<code>std::forward&lt;T></code>的返回类型即为<code>type&&</code></li></ul></li><li>例子：<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;utility&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>F</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>K</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>flip</span><span class=p>(</span><span class=n>F</span> <span class=n>f</span><span class=p>,</span> <span class=n>T</span> <span class=o>&amp;&amp;</span><span class=n>t</span><span class=p>,</span> <span class=n>K</span> <span class=o>&amp;&amp;</span><span class=n>k</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>f</span><span class=p>(</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>K</span><span class=o>&gt;</span><span class=p>(</span><span class=n>k</span><span class=p>),</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span><span class=p>)</span> <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>K</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>g</span><span class=p>(</span><span class=n>K</span><span class=o>&amp;&amp;</span> <span class=n>k</span><span class=p>,</span> <span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=k>typeid</span><span class=p>(</span><span class=n>K</span><span class=p>).</span><span class=n>name</span><span class=p>()</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=k>typeid</span><span class=p>(</span><span class=n>T</span><span class=p>).</span><span class=n>name</span><span class=p>()</span><span class=o>&lt;&lt;</span><span class=s>&#34;  &#34;</span><span class=o>&lt;&lt;</span><span class=n>k</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>t</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;&amp;</span><span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>k</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>t</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>flip</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span> <span class=c1>// F=void(*)(int&amp;&amp;, int&amp;), T=int&amp;, K=int
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>flip</span><span class=p>(</span><span class=n>g</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&amp;&gt;</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span> <span class=c1>// F=void(*)(int&amp;&amp;, int&amp;), T=int&amp;, K=int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=163-重载与模板>16.3 重载与模板<a hidden class=anchor aria-hidden=true href=#163-重载与模板>¶</a></h2><ul><li>函数模板可以被另一个函数模板或普通函数重载<ul><li>[[ch06-函数#6.6 函数匹配|函数的重载与匹配]]：有一些重载的函数，根据实参情况，调用时用哪个函数？</li><li>函数模板的重载与匹配：有一些重载的函数模板和普通函数，根据实参情况（函数模板进行函数模板实参推断），实例化并调用哪个函数模板</li></ul></li><li>到函数模板的函数匹配规则（[[ch06-函数#6.6 函数匹配|普通函数匹配的拓展]]）<ul><li>确定候选函数：同名的函数，包括实参推断成功的函数模板实例</li><li>确定可行函数：参数类型和数量都匹配，<ul><li>候选的函数模板实例都是可行的，因为实参推断会排除掉不可行的模板</li></ul></li><li>按照类型转换进行排序，寻找最佳匹配（普通函数和函数模板实例都可能发生类型转换，只是应用于函数模板的[[ch16-模板和泛型编程#类型转换与模板类型参数|类型转换]]十分有限）<ul><li>若恰有一个函数提供比其他函数都好的匹配，则选择它</li><li>如果多个函数都提供相同级别的匹配<ul><li>非模板和模板重载：如果只有一个是非模板函数，选择非模板函数</li><li>多个可行模板：如果没有非模板函数（有多个函数模板），选择最特例化的函数模板（特例化：比如<code>T&</code>可以匹配任意类型，<code>T*</code>只能匹配指针类型）</li><li>调用有歧义，失败</li></ul></li></ul></li></ul></li><li>最佳实践：在定义重载函数之前，应该先声明所有重载的版本，否则可能重载一个模板函数进行实例化（因为没有找到想使用的版本，使用函数模板进行实例化），编译期不会报错，但是运行期会调用不期望使用的版本</li></ul><h2 id=164-可变参数模板>16.4 可变参数模板<a hidden class=anchor aria-hidden=true href=#164-可变参数模板>¶</a></h2><ul><li><strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类，可变数目的参数被称为<strong>参数包</strong><ul><li>模板参数包：表示零个或多个模板参数（模板类型参数或模板非类型参数）<ul><li><code>typename</code>后跟<code>...</code>表示模板类型参数包</li><li>类型名后跟<code>...</code>表示模板非类型参数包</li></ul></li><li>函数参数包：表示零个或多个函数参数。</li></ul></li><li><code>sizeof...</code>运算符：返回参数包中的元素数量，且不会对其实参求值（类似于sizeof）<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span> <span class=c1>// 模板参数包：Args是模板类型参数包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>,</span> <span class=k>const</span> <span class=n>Args</span><span class=o>&amp;</span> <span class=p>...</span> <span class=n>rest</span><span class=p>){</span>  <span class=c1>// 函数参数包：rest是函数参数包（其类型是模板参数包Args）
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span><span class=o>&lt;&lt;</span><span class=k>sizeof</span><span class=p>...(</span><span class=n>Args</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=k>sizeof</span><span class=p>...(</span><span class=n>rest</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=编写可变参数函数模板>编写可变参数函数模板<a hidden class=anchor aria-hidden=true href=#编写可变参数函数模板>¶</a></h3><ul><li>[[ch06-函数#可变形参|可变形参]]<code>initializer_list</code>可以接受可变数目实参，但是需要是相同类型的</li><li>可变参数函数通常是递归的<ul><li>第一步调用处理参数包中的第一个实参，然后用剩余实参调用自身</li><li>还需要定义一个非可变参数的函数（因为函数匹配时会使用这个更加特例化的版本，而不是使用0个参数的可变参数模板的实例），来处理参数包中最后一个实参</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>print</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>)</span> <span class=c1>// 打印最后一个元素，用来终止递归，必须在可变参数版本的print定义之前声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>t</span><span class=p>;</span>   
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>print</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>,</span> <span class=k>const</span> <span class=n>Args</span><span class=o>&amp;</span><span class=p>...</span> <span class=n>rest</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>t</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, &#34;</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>print</span><span class=p>(</span><span class=n>os</span><span class=p>,</span> <span class=n>rest</span><span class=p>...);</span>   <span class=c1>// 递归调用，实参是将除了第一个，剩余的参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=包扩展>包扩展<a hidden class=anchor aria-hidden=true href=#包扩展>¶</a></h3><ul><li>扩展<code>...</code>：将参数包分解为单个元素，每个元素应用模式，得到拓展后的列表</li><li>常用情况：<ul><li><code>const Args& ...</code>：将模板参数包<code>Args</code>中所有类型<code>T</code>都扩展为<code>const T&</code></li><li><code>args...</code>：将函数参数包<code>args</code>扩展为参数列表</li><li><code>f(args)...</code>：对函数参数包<code>args</code>中每个元素调用函数<code>f</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>msg</span><span class=p>(</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Args</span><span class=o>&amp;</span><span class=p>...</span> <span class=n>rest</span><span class=p>){</span> <span class=c1>// 扩展模板参数包
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nf>print</span><span class=p>(</span><span class=n>os</span><span class=p>,</span> <span class=n>debug_reg</span><span class=p>(</span><span class=n>rest</span><span class=p>)...);</span> <span class=c1>// 扩展函数参数包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=转发参数包>转发参数包<a hidden class=anchor aria-hidden=true href=#转发参数包>¶</a></h3><ul><li>组合使用可变参数模板和<code>forward</code>机制，实现将可变参数的完美转发，例子：<code>emplace_back</code></li><li>如果同时存在模板参数包和函数参数包，则同时拓展：<ul><li><code>f&lt;Args>(args)...</code>等价于<code>f&lt;Args1>(args1), f&lt;Args2>(args2), ...</code></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>work</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=165-模板特例化specializations>16.5 模板特例化（Specializations）<a hidden class=anchor aria-hidden=true href=#165-模板特例化specializations>¶</a></h2><ul><li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=03b4a1a4-b85a-ef1b-901a-178f5542609b&amp;page=650&amp;rect=86.880,83.040,255.996,90.480">背景和例子</a>：对于某个类型，不想用（对特定类型可以做优化）或者不能用（对特定类型的使用并非预期）模板</li></ul><h3 id=定义函数模板特例化>定义函数模板特例化<a hidden class=anchor aria-hidden=true href=#定义函数模板特例化>¶</a></h3><ul><li>必须为原模板中每个模板参数都提供实参（全特例化）</li><li>关键字<code>template</code>后面跟一个空尖括号对（<code>&lt;></code>），表示所有模板参数都已被指定</li><li>特例化版本的参数类型必须与一个先前声明的模板中对应的类型相匹配。<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>compare</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>compare</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=o>&amp;</span><span class=p>);</span> <span class=c1>// T为const char*
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=函数重载与模板特例化>函数重载与模板特例化<a hidden class=anchor aria-hidden=true href=#函数重载与模板特例化>¶</a></h3><ul><li>特例化的本质是实例化一个模板，而不是重载它。因此特例化不影响[[ch16-模板和泛型编程#16.3 重载与模板|函数的匹配规则]]，即非模板函数先，再是特例化版本的函数（模板的实例化），最后是函数模板的实例</li><li>最佳实践：模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是特例化版本。<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>compare</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>l</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>compare</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=o>&amp;</span><span class=n>l</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>);</span> <span class=c1>// 特例化版本，T为const char*
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>compare</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=o>&amp;</span><span class=n>l</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>);</span> <span class=c1>// 普通函数
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=类模板特例化>类模板特例化<a hidden class=anchor aria-hidden=true href=#类模板特例化>¶</a></h3><ul><li>必须在原模板定义所在的命名空间中进行类模板特例化</li><li>类模板可以进行部分特例化（偏特例化），得到的是模板；也可以全部特例化（全特例化），得到的是实例</li><li>类模板的部分特例化<ul><li>未完全确定类型的模板参数仍放在<code>&lt;></code>中，即偏特化的模板参数列表非空。使用时也需提供模板实参，这些实参与原始模板中的参数按位置对应</li><li>部分特例化的模板参数列表是原始模板参数列表的一个子集或者特例化版本</li><li>例子：标准库remove_reference类型是通过一系列的特例化版本来完成其功能的<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//原始的、最通用的版本，可用于任意类型实例化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>remove_reference</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>T</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//部分特例化版本
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>remove_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&amp;&gt;</span> <span class=p>{</span>  <span class=c1>//针对于左值引用的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>typedef</span> <span class=n>T</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>remove_reference</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&amp;&amp;&gt;</span> <span class=p>{</span> <span class=c1>//针对于右值引用的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>typedef</span> <span class=n>T</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//调用原始模板
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>remove_reference</span><span class=o>&lt;</span><span class=k>decltype</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>a</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//decltype(i)==int&amp;，调用第一个（T&amp;）部分特例化版本
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>remove_reference</span><span class=o>&lt;</span><span class=k>decltype</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>b</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//decltype(std::move(i))==int&amp;&amp;，调用第二个（T&amp;&amp;）部分特例化版本
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>remove_reference</span><span class=o>&lt;</span><span class=k>decltype</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>i</span><span class=p>))</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>c</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//a、b、c均为int
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li>特例化成员函数而不是整个类<ul><li>使用模板的实例调用成员时，若该实例的模板实参与特化该成员时的参数一致，则调用特化版本的成员</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>t</span> <span class=o>=</span> <span class=n>T</span><span class=p>())</span> <span class=o>:</span><span class=n>mem</span><span class=p>(</span><span class=n>t</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=nf>Bar</span><span class=p>()</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;}</span> <span class=c1>//通用的Bar()函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>T</span> <span class=n>mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//特例化Foo&lt;int&gt;版本的的成员Bar
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Foo</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>Bar</span><span class=p>()</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=mi>2</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Foo</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>fs</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>	<span class=n>fs</span><span class=p>.</span><span class=n>Bar</span><span class=p>();</span>       <span class=c1>//使用Foo&lt;string&gt;的通用的Bar()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>Foo</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>fi</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>	<span class=n>fi</span><span class=p>.</span><span class=n>Bar</span><span class=p>();</span>       <span class=c1>//使用Foo&lt;int&gt;的特例化的Bar()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://qinganzhang.github.io/posts/cpp-primer/ch18-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Ch18 用于大型程序的工具</span>
</a><a class=next href=https://qinganzhang.github.io/posts/cpp-primer/ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Ch16 模板和泛型编程</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://qinganzhang.github.io/>Paul's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>