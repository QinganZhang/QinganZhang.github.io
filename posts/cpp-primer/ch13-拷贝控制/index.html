<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ch13 拷贝控制 | Paul's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="第十三章 拷贝控制 一些术语 构造函数： （合成的）[[ch07-类#^15282e|默认构造函数]]：编译器创建或是使用=default修饰的构造"><meta name=author content="Paul"><link rel=canonical href=https://qinganzhang.github.io/posts/cpp-primer/ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://qinganzhang.github.io/favicon.ico><link rel=apple-touch-icon href=https://qinganzhang.github.io/apple-touch-icon.png><meta name=twitter:title content="Ch13 拷贝控制 | Paul's Blog"><meta name=twitter:description content="第十三章 拷贝控制 一些术语 构造函数： （合成的）[[ch07-类#^15282e|默认构造函数]]：编译器创建或是使用=default修饰的构造"><meta property="og:title" content="Ch13 拷贝控制 | Paul's Blog"><meta property="og:description" content="第十三章 拷贝控制 一些术语 构造函数： （合成的）[[ch07-类#^15282e|默认构造函数]]：编译器创建或是使用=default修饰的构造"><meta property="og:type" content="article"><meta property="og:url" content="https://qinganzhang.github.io/posts/cpp-primer/ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T15:58:13+08:00"><meta property="article:modified_time" content="2024-02-27T15:58:13+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://qinganzhang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Ch13 拷贝控制","item":"https://qinganzhang.github.io/posts/cpp-primer/ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ch13 拷贝控制 | Paul's Blog","name":"Ch13 拷贝控制","description":"第十三章 拷贝控制 一些术语 构造函数： （合成的）[[ch07-类#^15282e|默认构造函数]]：编译器创建或是使用=default修饰的构造","keywords":["cpp"],"wordCount":"5239","inLanguage":"en","datePublished":"2024-02-27T15:58:13+08:00","dateModified":"2024-02-27T15:58:13+08:00","author":{"@type":"Person","name":"Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qinganzhang.github.io/posts/cpp-primer/ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"},"publisher":{"@type":"Organization","name":"Paul's Blog","logo":{"@type":"ImageObject","url":"https://qinganzhang.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://qinganzhang.github.io/ accesskey=h title="Paul's Blog (Alt + H)">Paul's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://qinganzhang.github.io/posts/ title=Posts class=active>Posts</a></li><li><a href=https://qinganzhang.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://qinganzhang.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://qinganzhang.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://qinganzhang.github.io/categories/ title=Categories>Categories</a></li><li><a href=https://qinganzhang.github.io/about/ title=About>About</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qinganzhang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://qinganzhang.github.io/posts/>Post</a></div><h1 class=post-title>Ch13 拷贝控制</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-02-27</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://qinganzhang.github.io/tags/cpp/>cpp</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>5239 words</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>11 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ac%ac%e5%8d%81%e4%b8%89%e7%ab%a0-%e6%8b%b7%e8%b4%9d%e6%8e%a7%e5%88%b6 aria-label="第十三章 拷贝控制">第十三章 拷贝控制</a><ul><li><a href=#%e4%b8%80%e4%ba%9b%e6%9c%af%e8%af%ad aria-label=一些术语>一些术语</a></li><li><a href=#131-%e6%8b%b7%e8%b4%9d%e8%b5%8b%e5%80%bc%e5%92%8c%e9%94%80%e6%af%81 aria-label="13.1 拷贝、赋值和销毁">13.1 拷贝、赋值和销毁</a><ul><li><a href=#%e6%8b%b7%e8%b4%9d%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=拷贝构造函数>拷贝构造函数</a></li><li><a href=#%e6%8b%b7%e8%b4%9d%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=拷贝赋值运算符>拷贝赋值运算符</a></li><li><a href=#%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0 aria-label=析构函数>析构函数</a></li><li><a href=#%e4%b8%89%e4%ba%94%e6%b3%95%e5%88%99 aria-label=三/五法则>三/五法则</a></li><li><a href=#%e6%98%be%e5%bc%8f%e5%90%88%e6%88%90default aria-label="显式合成=default">显式合成<code>=default</code></a></li><li><a href=#%e9%98%bb%e6%ad%a2%e6%8b%b7%e8%b4%9ddelete aria-label="阻止拷贝=delete">阻止拷贝<code>=delete</code></a></li></ul></li><li><a href=#132-%e6%8b%b7%e8%b4%9d%e6%8e%a7%e5%88%b6%e5%92%8c%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86 aria-label="13.2 拷贝控制和资源管理">13.2 拷贝控制和资源管理</a><ul><ul><li><a href=#%e8%a1%8c%e4%b8%ba%e5%83%8f%e5%80%bc aria-label=行为像值>行为像值</a></li><li><a href=#%e8%a1%8c%e4%b8%ba%e5%83%8f%e6%8c%87%e9%92%88 aria-label=行为像指针>行为像指针</a></li></ul></ul></li><li><a href=#133-%e4%ba%a4%e6%8d%a2%e6%93%8d%e4%bd%9c aria-label="13.3 交换操作">13.3 交换操作</a></li><li><a href=#134-%e6%8b%b7%e8%b4%9d%e6%8e%a7%e5%88%b6%e7%a4%ba%e4%be%8b aria-label="13.4 拷贝控制示例">13.4 拷贝控制示例</a></li><li><a href=#135-%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%b1%bb aria-label="13.5 动态内存管理类">13.5 动态内存管理类</a></li><li><a href=#136-%e5%af%b9%e8%b1%a1%e7%a7%bb%e5%8a%a8 aria-label="13.6 对象移动">13.6 对象移动</a><ul><li><a href=#%e5%b7%a6%e5%80%bc%e4%b8%8e%e5%8f%b3%e5%80%bc aria-label=左值与右值>左值与右值</a></li><li><a href=#%e7%a7%bb%e5%8a%a8%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%92%8c%e7%a7%bb%e5%8a%a8%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=移动构造函数和移动赋值运算符>移动构造函数和移动赋值运算符</a></li><li><a href=#%e5%bc%95%e7%94%a8%e9%99%90%e5%ae%9a%e7%ac%a6 aria-label=引用限定符>引用限定符</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=第十三章-拷贝控制>第十三章 拷贝控制<a hidden class=anchor aria-hidden=true href=#第十三章-拷贝控制>¶</a></h1><h2 id=一些术语>一些术语<a hidden class=anchor aria-hidden=true href=#一些术语>¶</a></h2><ul><li>构造函数：<ul><li>（合成的）[[ch07-类#^15282e|默认构造函数]]：编译器创建或是使用<code>=default</code>修饰的构造函数</li><li>一般的构造函数</li><li>拷贝构造函数</li><li>转换构造函数（或称为[[ch07-类#隐式的类型转换|隐式的类型转换]]）</li><li>移动构造函数</li><li>[[ch07-类#委托构造函数 （delegating constructor）|委托构造函数]]</li></ul></li><li>初始化类型：<ul><li>默认初始化：<code>int* a = new int;</code></li><li>值初始化：<code>int *a = new int(); // 默认a=0</code></li><li>直接初始化：<code>int *a = new int(1);</code></li><li>拷贝初始化：<code>=</code></li><li>列表初始化：<code>{}</code></li></ul></li><li><strong>拷贝控制操作</strong>（copy control）（或者称为拷贝控制成员）:一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值、和销毁操作<ul><li>拷贝构造函数（copy constructor）</li><li>拷贝赋值运算符（copy-assignment operator）</li><li>移动构造函数（move constructor）</li><li>移动赋值函数（move-assignement operator）</li><li>析构函数（destructor）</li></ul></li></ul><h2 id=131-拷贝赋值和销毁>13.1 拷贝、赋值和销毁<a hidden class=anchor aria-hidden=true href=#131-拷贝赋值和销毁>¶</a></h2><h3 id=拷贝构造函数>拷贝构造函数<a hidden class=anchor aria-hidden=true href=#拷贝构造函数>¶</a></h3><ul><li>拷贝构造函数：<ul><li>第一个参数是自身类型的引用（而且一般是const引用，否则导致无限递归，因为传递实参本身就是拷贝），且其他参数都有默认值</li><li>通常不会声明为explicit的</li></ul></li><li>合成的拷贝构造函数：<ul><li>编译器将参数的非static成员逐个拷贝到正在创建的对象中。</li><li>对于某些类，合成的拷贝构造函数使用<code>=delete</code>来禁止对该类型对象的拷贝</li></ul></li><li>拷贝初始化：<ul><li>通常使用拷贝构造函数完成，但也可能使用移动构造函数</li><li>出现场景：<ul><li>用<code>=</code>定义变量时。</li><li>将一个对象作为实参传递给一个非引用类型的形参。</li><li>从一个返回类型为非引用类型的函数返回一个对象。</li><li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。</li></ul></li></ul></li></ul><h3 id=拷贝赋值运算符>拷贝赋值运算符<a hidden class=anchor aria-hidden=true href=#拷贝赋值运算符>¶</a></h3><ul><li>重载赋值运算符：<ul><li>通常返回一个指向其左侧运算对象（即自身）的引用：<code>return *this;</code></li></ul></li><li>合成拷贝赋值运算符：<ul><li>将右侧运算对象的每个非<code>static</code>成员赋予左侧运算对象的对应成员，之后返回左侧对象的引用</li><li>对于某些类，合成的拷贝赋值运算符使用<code>=delete</code>来禁止对该类型对象的赋值</li></ul></li></ul><h3 id=析构函数>析构函数<a hidden class=anchor aria-hidden=true href=#析构函数>¶</a></h3><ul><li>析构顺序：<ul><li>先执行析构函数体：因为销毁指针并不会delete它所指的对象，因此需要手动释放空间</li><li>再执行析构部分，按初始化顺序的逆序销毁非static的数据成员</li></ul></li></ul><h3 id=三五法则>三/五法则<a hidden class=anchor aria-hidden=true href=#三五法则>¶</a></h3><ul><li>背景：一个类通常需要拷贝构造函数、拷贝赋值运算符、析构函数（和移动构造函数、移动赋值运算符），虽然通常不会全部自定义，但是有时需要将这些拷贝控制成员看作一个整体</li><li>三五法则：<ul><li>一个需要自定义析构函数的类，一定也需要一个拷贝构造函数和拷贝赋值运算符（比如类中有一个指向动态内存的指针，使用合成版本的构造函数只会复制指针的值）</li><li>一个需要自定义拷贝构造函数的类，也一定需要一个拷贝赋值运算符，反之亦然；但是未必需要析构函数（比如每个类需要有一个唯一id）</li></ul></li></ul><h3 id=显式合成default>显式合成<code>=default</code><a hidden class=anchor aria-hidden=true href=#显式合成default>¶</a></h3><ul><li>可以通过将拷贝控制成员定义为<code>=default</code>来显式地要求编译器生成合成的版本。<ul><li>只能对具有合成版本的成员函数（即默认构造函数或拷贝控制成员）使用=default</li><li>在类内部使用=default修饰成员声明时，合成的函数是隐式内联的；如果不希望合成的是内联函数，应该只对成员的类外定义使用=default</li></ul></li></ul><h3 id=阻止拷贝delete>阻止拷贝<code>=delete</code><a hidden class=anchor aria-hidden=true href=#阻止拷贝delete>¶</a></h3><ul><li>删除的函数<code>=delete</code>：虽然声明了该函数，但是不能使用它们</li><li>语法相关：<ul><li><code>=delete</code>只能出现在函数第一次声明的地方（即告诉编译器不定义这些函数）</li><li>可以对任何函数（除了析构函数，否则动态分配了对象后无法释放）使用</li><li>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的构造、拷贝、复制、析构函数被定义为删除的。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=87750c2e-2368-c105-88dd-7f6d8e702f15&amp;page=476&amp;rect=90.240,157.210,339.610,165.130">原文</a>。<ul><li>如果类的某个数据成员的析构函数是删除的或不可访问的（如 private 的），则该类的合成析构函数、合成拷贝构造函数和默认构造函数被定义为删除的</li><li>如果类的某个数据成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。</li><li>如果类的某个数据成员的拷贝赋值运算符是删除的或不可访问的，则类的合成拷贝赋值运算符被定义为删除的。</li><li>如果类有一个 const 成员或引用成员，则类的合成拷贝赋值运算符被定义为删除的。（但是拷贝构造函数在初始化时执行）</li><li>如果类有一个没有类内初始化器且未显式定义默认构造函数的 const 成员或没有类内初始化器的引用成员，则该类的默认构造函数被定义为删除的</li></ul></li></ul></li><li>老版本的阻止拷贝<ul><li>将拷贝控制成员设置为<code>private</code>，阻止普通用户拷贝对象（编译期报错）</li><li>将拷贝控制成员只声明不定义，友元和成员函数调用时报错（链接时报错）</li></ul></li></ul><h2 id=132-拷贝控制和资源管理>13.2 拷贝控制和资源管理<a hidden class=anchor aria-hidden=true href=#132-拷贝控制和资源管理>¶</a></h2><ul><li>通常管理类外资源的类必须定义拷贝控制成员</li><li>类的行为可以像一个值，也可以像一个指针，主要是依据拷贝指针成员的行为<ul><li>不允许拷贝和赋值的类，行为既不像值，也不像指针</li></ul></li></ul><h4 id=行为像值>行为像值<a hidden class=anchor aria-hidden=true href=#行为像值>¶</a></h4><ul><li>对象有自己的状态，副本和原对象是完全独立的，需要定义一个拷贝构造函数、一个析构函数、一个拷贝赋值运算符<ul><li>赋值运算符通常组合析构函数（销毁左侧对象的资源）和构造函数（从右侧对象拷贝构造）的操作</li><li>拷贝赋值运算符要考虑到【自赋值】的正确性：</li></ul></li><li>好的方法是先将右侧对象（动态内存的指针对象）拷贝到一个局部临时对象，再销毁左侧对象的资源。（P453<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=79f6e710-cfdb-8315-7af9-bccf63645b0b&amp;page=479&amp;rect=80.880,111.600,117.360,120.720">例子</a>）</li></ul><h4 id=行为像指针>行为像指针<a hidden class=anchor aria-hidden=true href=#行为像指针>¶</a></h4><ul><li>共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据，需要定义一个拷贝构造函数、一个析构函数、一个拷贝赋值运算符</li><li>最好使用shared_ptr管理资源，或者使用一个<strong>引用计数</strong>来直接管理（引用计数和资源一样是共享的，应该保存在动态内存中）。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=0cd2068b-d080-32af-4d30-59bb8bec3168&amp;page=481&amp;rect=80.160,327.130,164.400,334.810">引用计数的工作方式</a>：<ul><li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。创建一个对象时，计数器初始化为1。</li><li>拷贝构造函数不创建新的引用计数，而是拷贝对象的计数器并递增它。</li><li>析构函数递减计数器，如果计数器变为 0，则析构函数释放状态。</li><li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为 0 就销毁状态。</li></ul></li><li>拷贝赋值运算符类似于shared_ptr，需要递增右侧对象的引用计数，递减左侧对象的引用计数</li><li>此时处理【自赋值】问题：先是右侧对象引用计数递增，后是左侧对象引用计数递减，自赋值时引用计数不变（P457<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=2715fed7-26b5-0064-9720-b469350a27a6&amp;page=482&amp;rect=236.842,53.760,344.400,62.160">例子</a>）</li></ul><h2 id=133-交换操作>13.3 交换操作<a hidden class=anchor aria-hidden=true href=#133-交换操作>¶</a></h2><ul><li>管理资源的类通常还定义一个名为<code>swap</code>的函数，经常用于重排元素顺序的算法。</li><li>优先使用自定义的swap，否则使用标准库的<code>std::swap</code></li><li>通常可以使用swap来实现赋值运算符<ul><li>右侧对象传值，然后将左侧对象与右侧对象的副本进行交换（copy and swap），可以正确处理自赋值的情况</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>HasPtr</span><span class=p>{</span> <span class=c1>// 行为类似值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>friend</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=n>HasPtr</span><span class=o>&amp;</span><span class=p>,</span> <span class=n>HasPtr</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>HasPtr</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>())</span> <span class=o>:</span> <span class=n>ps</span><span class=p>(</span><span class=k>new</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=n>s</span><span class=p>)),</span> <span class=n>i</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=n>HasPtr</span><span class=p>(</span><span class=k>const</span> <span class=n>HasPtr</span><span class=o>&amp;</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span> <span class=n>ps</span><span class=p>(</span><span class=k>new</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>.</span><span class=n>ps</span><span class=p>)),</span> <span class=n>i</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>i</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// 拷贝构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>HasPtr</span><span class=p>(</span><span class=n>HasPtr</span> <span class=o>&amp;&amp;</span><span class=n>p</span><span class=p>)</span> <span class=k>noexcept</span><span class=o>:</span> <span class=n>ps</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>ps</span><span class=p>),</span> <span class=n>i</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span><span class=n>p</span><span class=p>.</span><span class=n>ps</span> <span class=mi>0</span><span class=p>;}</span> <span class=c1>// 移动构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>HasPtr</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=n>HasPtr</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>){</span> <span class=c1>// 拷贝赋值操作符
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>tmp</span> <span class=o>=</span> <span class=k>new</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>ps</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>delete</span> <span class=n>ps</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>ps</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>i</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1>// 特点：
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 1.用swap实现赋值运算符
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 2.既是拷贝赋值运算符（参数是左值），又是移动赋值运算符（参数是右值）
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>HasPtr</span><span class=o>&amp;</span> <span class=k>operator</span> <span class=o>=</span> <span class=p>(</span><span class=n>HasPtr</span> <span class=n>rhs</span><span class=p>){</span> <span class=c1>// copy and swap
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 传入的是rhs的副本（假设是rhs-copy），this还是指向本身（假设是lhs）
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>swap</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>,</span> <span class=n>rhs</span><span class=p>);</span> <span class=c1>// 交换左侧对象(lhs)和右侧对象的副本(rhs-copy)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 此时this指向rhs-copy（更准确来说还是指向lhs地址，但是原来lhs的内容已经被swap为了rhs-copy）
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// swap后的lhs没有变量来接管，因此被析构
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// 因此实现了this指向从lhs改变为rhs
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>HasPtr</span><span class=p>()</span> <span class=p>{</span><span class=k>delete</span> <span class=n>ps</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>*</span><span class=n>ps</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>i</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=n>HasPtr</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=n>HasPtr</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>;</span> <span class=c1>// 当某个成员没有自定义的swap时，使用标准库版本的swap
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>swap</span><span class=p>(</span><span class=n>lhs</span><span class=p>.</span><span class=n>ps</span><span class=p>,</span> <span class=n>rhs</span><span class=p>.</span><span class=n>ps</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>swap</span><span class=p>(</span><span class=n>lhs</span><span class=p>.</span><span class=n>i</span><span class=p>,</span> <span class=n>rhs</span><span class=p>.</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>friend</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;</span><span class=p>,</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>HasPtr</span> <span class=n>h</span><span class=p>;</span>    
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=n>Foo</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span> <span class=n>Foo</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>;</span> <span class=c1>// 优先使用自定义版本的swap
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>swap</span><span class=p>(</span><span class=n>lhs</span><span class=p>.</span><span class=n>h</span><span class=p>,</span> <span class=n>rhs</span><span class=p>.</span><span class=n>h</span><span class=p>);</span> <span class=c1>// 使用HasPtr版本的swap
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>HasPtr</span> <span class=nf>p1</span><span class=p>(</span><span class=s>&#34;test)</span><span class=p>,</span> <span class=n>p2</span><span class=p>,</span> <span class=n>p3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>p2</span> <span class=o>=</span> <span class=n>p1</span><span class=p>;</span> <span class=c1>// 使用拷贝赋值运算符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>p3</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span> <span class=c1>// 使用移动赋值运算符
</span></span></span></code></pre></td></tr></table></div></div><h2 id=134-拷贝控制示例>13.4 拷贝控制示例<a hidden class=anchor aria-hidden=true href=#134-拷贝控制示例>¶</a></h2><h2 id=135-动态内存管理类>13.5 动态内存管理类<a hidden class=anchor aria-hidden=true href=#135-动态内存管理类>¶</a></h2><h2 id=136-对象移动>13.6 对象移动<a hidden class=anchor aria-hidden=true href=#136-对象移动>¶</a></h2><p>使用对象移动的原因：</p><ul><li>一些拷贝操作后，原对象会被立即销毁，因此引入移动操作可以大幅度提升性能。</li><li>C++11可以用容器保存不可拷贝的类型，只要它们可以被移动即可。<ul><li>标准库容器、<code>string</code>和<code>shared_ptr</code>类既可以支持移动也支持拷贝。<code>IO</code>类和<code>unique_ptr</code>类可以移动但不能拷贝。</li></ul></li></ul><h3 id=左值与右值>左值与右值<a hidden class=anchor aria-hidden=true href=#左值与右值>¶</a></h3><ul><li>左值：<ul><li>返回左值的表达式：返回左值引用的函数，赋值、下标、解引用、前置递增递减运算符，</li><li>左值引用：可以绑定到变量（包括右值引用变量）、返回左值的表达式</li><li>const的左值引用可以绑定到右值</li></ul></li><li>右值：<ul><li>右值要么是字面常量（没有其他用户），要么是表达式求值过程中创建的临时变量（即将被销毁）</li><li>返回右值的表达式：返回非引用类型的函数，算数、关系、位、后置递增递减运算符</li><li>右值引用：可以绑定到要求转换的表达式、字面常量、返回右值的表达式</li></ul></li><li>move函数： ^d3a2a0<ul><li>可以将一个右值引用绑定到左值上 <code>int a=1; int &&amp;r = std::move(a);</code></li><li>定义在头文件utility中</li><li><code>move</code>告诉编译器，我们有一个左值，但我希望像右值一样处理它。</li><li>对左值调用<code>move</code>意味着：不在使用该左值的值，除非销毁它或者对它重新赋值</li><li>使用move的代码应该使用std::move而不是move，可以避免潜在的名字冲突</li></ul></li></ul><h3 id=移动构造函数和移动赋值运算符>移动构造函数和移动赋值运算符<a hidden class=anchor aria-hidden=true href=#移动构造函数和移动赋值运算符>¶</a></h3><ul><li>移动构造函数<ul><li>第一个参数是该类类型的一个右值引用，比如<code>StrVec::StrVec(StrVec &&amp;s) noexcept{}</code></li><li>在形参列表后添加关键字<code>noexcept</code>可以指明该函数不会抛出任何异常，在声明和定义中均应该指明<code>noexcept</code><ul><li>不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code></li><li>原因：如果用移动构造函数，移动到一半抛出异常，容器不能满足即使发生异常也保持自身不变的要求，因此需要显式标记<code>noexcept</code>；否则编译器基于上面的考虑，会调用拷贝构造函数而非移动构造函数</li></ul></li><li>除了完成资源移动，还要确保移动后源对象是可以安全销毁的（比如将源对象中数组的指针指向nullptr，然后源对象进行正确析构，否则会释放掉刚才移动的对象），用户不能使用移动后源对象的值</li></ul></li><li>移动赋值运算符<ul><li><code>StrVec& StrVec::operator=(StrVec && rhs) noexcept{}</code></li><li>使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能，依赖于实参的类型：实参是左值，则实参被拷贝；实参是右值，则实参被移动：<code>StrVec& StrVec::operator=(StrVec rhs);</code></li></ul></li><li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=e9cc2ba7-e7de-20c5-6d18-bd84fd5f6733&amp;page=506&amp;rect=180.960,300.960,227.280,309.840">移动迭代器</a>：<ul><li>普通迭代器的解引用运算符返回一个指向元素的左值，移动迭代器的解引用运算符生成一个右值引用</li><li><code>make_move_iterator</code>函数将一个普通迭代器转换为一个移动迭代器。</li><li>因此，可以将移动迭代器传递给算法或是allocator的伴随算法</li><li>但是，标准库不能保证哪些算法适用于移动迭代器，哪些不适用。由于移动一个对象可能销毁掉源对象，因此要确定以后不再访问这个元素时，才能将移动迭代器传递给算法。</li><li>移后源对象具有不确定的状态，必须确认移后源对象没有其他用户，因此要小心使用</li></ul></li><li>合成的移动操作<ul><li>如果一个类定义了自己的拷贝构造函数、拷贝赋值函数或者析构函数，编译器不会为它合成移动构造函数和移动赋值运算符</li><li>如果一个类没有移动操作，类会用对应的拷贝操作来代替移动操作，即使使用move函数也是如此</li><li>只有当一个类没有自定义的拷贝控制成员，且类的每个非static数据成员都可以移动（内置类型可以移动，类类型要有对应的移动操作）时，编译器才会为类合成移动构造函数和移动赋值运算符；否则即使显式要求合成移动操作<code>=default</code>，编译器也会将移动操作定义为<code>=delele</code></li><li>与拷贝操作不同，移动操作永远不会隐式定义为<code>=delete</code><ul><li>例外：<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=26545b20-71fb-2bf8-83a8-871ae37ad44a&amp;page=502&amp;rect=64.080,328.080,432,350.400">将合成的移动操作定义为删除的</a></li></ul></li><li>如果一个类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝函数和拷贝赋值运算符会被定义为删除的</li><li>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的</li></ul></li></ul><h3 id=引用限定符>引用限定符<a hidden class=anchor aria-hidden=true href=#引用限定符>¶</a></h3><ul><li>成员函数一般有接受拷贝的<code>const T&</code>版本和接受右值的<code>T&&</code>版本</li><li><strong>引用限定符</strong><code>&</code>和<code>&&</code>：<ul><li>限制调用者必须是左值还是右值</li><li>语法相关：<ul><li>引用限定符只能用于非static成员函数</li><li>引用限定符必须同时出现在函数的声明和定义中</li><li>一个函数可以同时使用const和引用限定，即引用限定符必须在const限定符之后</li><li>如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符</li></ul></li><li>可以综合使用引用限定符和const限定符来区分一个函数的重载版本<ul><li>使用const &&进行限定时，调用者必须是右值</li><li>使用const &进行限定时，调用者可以是左值，也可以是右值</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Test</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Test</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span><span class=o>:</span> <span class=n>val</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=nf>show</span><span class=p>()</span> <span class=o>&amp;</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span><span class=k>return</span> <span class=n>val</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// const int show() &amp; {} // 报错：返回值与重载无关，见6.4
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=nf>show</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=mi>2</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span><span class=k>return</span> <span class=n>val</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=nf>show</span><span class=p>()</span> <span class=k>const</span> <span class=o>&amp;</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=mi>3</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span><span class=k>return</span> <span class=n>val</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=nf>show</span><span class=p>()</span> <span class=k>const</span> <span class=o>&amp;&amp;</span> <span class=p>{</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=o>&lt;&lt;</span><span class=mi>4</span><span class=o>&lt;&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span><span class=k>return</span> <span class=n>val</span><span class=p>;}</span> <span class=c1>// 右值本来就是常量，这种方法无法被调用（被show() &amp;&amp;）覆盖
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>    
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>Test</span> <span class=n>t1</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=n>t1</span><span class=p>.</span><span class=n>show</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>Test</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>show</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>Test</span> <span class=n>t3</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=n>t3</span><span class=p>.</span><span class=n>show</span><span class=p>();</span> <span class=c1>// const对象或是const对象的指针/引用，只能调用const成员函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 输出1 2 3 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>  
</span></span></code></pre></td></tr></table></div></div></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://qinganzhang.github.io/posts/cpp-primer/ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Ch14 重载运算与类型转换</span>
</a><a class=next href=https://qinganzhang.github.io/posts/cpp-primer/ch12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Ch12 动态内存</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://qinganzhang.github.io/>Paul's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>