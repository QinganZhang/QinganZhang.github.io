<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ch06 函数 | Paul's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="第六章 函数 6.1 函数基础 调用运算符：一对圆括号 ()，作用于函数指针 函数调用过程： 主调函数（calling function）的执行被中断，使用实参"><meta name=author content="Paul"><link rel=canonical href=https://qinganzhang.github.io/posts/cpp-primer/ch06-%E5%87%BD%E6%95%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://qinganzhang.github.io/favicon.ico><link rel=apple-touch-icon href=https://qinganzhang.github.io/apple-touch-icon.png><meta name=twitter:title content="Ch06 函数 | Paul's Blog"><meta name=twitter:description content="第六章 函数 6.1 函数基础 调用运算符：一对圆括号 ()，作用于函数指针 函数调用过程： 主调函数（calling function）的执行被中断，使用实参"><meta property="og:title" content="Ch06 函数 | Paul's Blog"><meta property="og:description" content="第六章 函数 6.1 函数基础 调用运算符：一对圆括号 ()，作用于函数指针 函数调用过程： 主调函数（calling function）的执行被中断，使用实参"><meta property="og:type" content="article"><meta property="og:url" content="https://qinganzhang.github.io/posts/cpp-primer/ch06-%E5%87%BD%E6%95%B0/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T15:56:57+08:00"><meta property="article:modified_time" content="2024-02-27T15:56:57+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://qinganzhang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Ch06 函数","item":"https://qinganzhang.github.io/posts/cpp-primer/ch06-%E5%87%BD%E6%95%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ch06 函数 | Paul's Blog","name":"Ch06 函数","description":"第六章 函数 6.1 函数基础 调用运算符：一对圆括号 ()，作用于函数指针 函数调用过程： 主调函数（calling function）的执行被中断，使用实参","keywords":["cpp"],"wordCount":"4106","inLanguage":"en","datePublished":"2024-02-27T15:56:57+08:00","dateModified":"2024-02-27T15:56:57+08:00","author":{"@type":"Person","name":"Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qinganzhang.github.io/posts/cpp-primer/ch06-%E5%87%BD%E6%95%B0/"},"publisher":{"@type":"Organization","name":"Paul's Blog","logo":{"@type":"ImageObject","url":"https://qinganzhang.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://qinganzhang.github.io/ accesskey=h title="Paul's Blog (Alt + H)">Paul's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://qinganzhang.github.io/posts/ title=Posts class=active>Posts</a></li><li><a href=https://qinganzhang.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://qinganzhang.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://qinganzhang.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://qinganzhang.github.io/categories/ title=Categories>Categories</a></li><li><a href=https://qinganzhang.github.io/about/ title=About>About</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qinganzhang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://qinganzhang.github.io/posts/>Post</a></div><h1 class=post-title>Ch06 函数</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-02-27</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://qinganzhang.github.io/tags/cpp/>cpp</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>4106 words</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>9 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ac%ac%e5%85%ad%e7%ab%a0-%e5%87%bd%e6%95%b0 aria-label="第六章 函数">第六章 函数</a><ul><li><a href=#61-%e5%87%bd%e6%95%b0%e5%9f%ba%e7%a1%80 aria-label="6.1 函数基础">6.1 函数基础</a><ul><li><a href=#%e5%b1%80%e9%83%a8%e5%af%b9%e8%b1%a1 aria-label=局部对象>局部对象</a></li><li><a href=#%e5%87%bd%e6%95%b0%e5%a3%b0%e6%98%8e aria-label=函数声明>函数声明</a></li></ul></li><li><a href=#62-%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92 aria-label="6.2 参数传递">6.2 参数传递</a><ul><li><a href=#%e6%95%b0%e7%bb%84%e5%bd%a2%e5%8f%82 aria-label=数组形参>数组形参</a></li><li><a href=#main%e5%a4%84%e7%90%86%e5%91%bd%e4%bb%a4%e8%a1%8c%e9%80%89%e9%a1%b9 aria-label=main处理命令行选项>main处理命令行选项</a></li><li><a href=#%e5%8f%af%e5%8f%98%e5%bd%a2%e5%8f%82 aria-label=可变形参>可变形参</a></li></ul></li><li><a href=#63-%e8%bf%94%e5%9b%9e%e7%b1%bb%e5%9e%8b%e5%92%8creturn%e8%af%ad%e5%8f%a5 aria-label="6.3 返回类型和return语句">6.3 返回类型和return语句</a><ul><li><a href=#%e8%bf%94%e5%9b%9e%e6%95%b0%e7%bb%84%e6%8c%87%e9%92%88 aria-label=返回数组指针>返回数组指针</a></li></ul></li><li><a href=#64-%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd aria-label="6.4 函数重载">6.4 函数重载</a></li><li><a href=#65-%e7%89%b9%e6%ae%8a%e7%94%a8%e9%80%94%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7 aria-label="6.5 特殊用途语言特性">6.5 特殊用途语言特性</a><ul><li><a href=#%e9%bb%98%e8%ae%a4%e5%ae%9e%e5%8f%82 aria-label=默认实参>默认实参</a></li><li><a href=#%e5%86%85%e8%81%94inline%e5%87%bd%e6%95%b0 aria-label=内联（inline）函数>内联（inline）函数</a></li><li><a href=#constexpr-%e5%87%bd%e6%95%b0obsidianbooknotetypeannotationbookcpp_primer-e99885e8afbbe7ac94e8aeb0primer20ce7acac5e78988pdfid08ac9451-c1bd-d611-0716-98d876b07c54page240rect62650382800131280391200 aria-label="constexpr 函数"><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=08ac9451-c1bd-d611-0716-98d876b07c54&amp;page=240&amp;rect=62.650,382.800,131.280,391.200">constexpr 函数</a></a></li><li><a href=#%e8%b0%83%e8%af%95%e5%b8%ae%e5%8a%a9 aria-label=调试帮助>调试帮助</a></li></ul></li><li><a href=#66-%e5%87%bd%e6%95%b0%e5%8c%b9%e9%85%8d aria-label="6.6 函数匹配">6.6 函数匹配</a></li><li><a href=#67-%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88 aria-label="6.7 函数指针">6.7 函数指针</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=第六章-函数>第六章 函数<a hidden class=anchor aria-hidden=true href=#第六章-函数>¶</a></h1><h2 id=61-函数基础>6.1 函数基础<a hidden class=anchor aria-hidden=true href=#61-函数基础>¶</a></h2><ul><li>调用运算符：一对圆括号 <code>()</code>，作用于函数指针</li><li>函数调用过程：<ul><li>主调函数（calling function）的执行被中断，使用实参初始化对应的形参</li><li>控制权移交给被调函数，被调函数（called function）开始执行。</li></ul></li><li>函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。</li></ul><h3 id=局部对象>局部对象<a hidden class=anchor aria-hidden=true href=#局部对象>¶</a></h3><ul><li><strong>生命周期</strong>：对象的生命周期是程序执行过程中该对象存在的一段时间。</li><li><strong>局部静态对象</strong>： <code>static</code>类型的局部变量，在程序执行路径第一次经过对象定义语句时进行初始化，直到程序终止才被销毁</li></ul><h3 id=函数声明>函数声明<a hidden class=anchor aria-hidden=true href=#函数声明>¶</a></h3><ul><li>函数声明不需要形参的名字</li><li>函数三要素：返回类型，函数名，形参类型</li></ul><h2 id=62-参数传递>6.2 参数传递<a hidden class=anchor aria-hidden=true href=#62-参数传递>¶</a></h2><ul><li>形参初始化的机理和变量初始化一样<ul><li>形参的顶层<code>const</code>被忽略：<code>void func(const int i)</code>与<code>void func(int i)</code>具有相同的函数签名 ^f06638<ul><li>原因：引用没有顶层const；如果传值，传递的是实参的副本，不会改变实参的值</li><li>但是前面这个函数体中i是const的，连副本也无法修改</li></ul></li></ul></li><li>两种传参方式：<ul><li>传值参数（值传递，传值调用）</li><li>传引用参数（引用传递，传引用调用）<ul><li>如果无需改变引用形参的值，最好将其声明为常量引用。</li><li>不能将const对象、字面值或需要类型转换的对象传递给普通引用形参，但是可以传递给常量引用形参</li></ul></li></ul></li></ul><h3 id=数组形参>数组形参<a hidden class=anchor aria-hidden=true href=#数组形参>¶</a></h3><ul><li>数组有两个特殊性质：不允许拷贝数组、使用数组时通常会将其转换为指针</li><li>数组形参：<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 以下几种方式形参等价，编译器只会检查传参类型是否为const int*
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span><span class=p>[])</span> <span class=c1>// 可以看出函数意图是传递数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>func</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span> <span class=c1>// 可以提示数组长度
</span></span></span></code></pre></td></tr></table></div></div><ul><li>当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针，因此也要传入数组长度</li></ul></li><li>数组引用形参：形参是数组引用，实参要传递相同类型及大小的数组<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>)[</span><span class=mi>5</span><span class=p>]){}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li>传递多维数组：数组第二维（及更多维）的大小都是数组类型的一部分，不能省略<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>matrix</span><span class=p>)[</span><span class=mi>10</span><span class=p>],</span> <span class=kt>int</span> <span class=n>size</span><span class=p>){}</span> <span class=c1>// matrix是一个指针，指向int[10]类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span> <span class=n>matrix</span><span class=p>[][</span><span class=mi>10</span><span class=p>],</span> <span class=kt>int</span> <span class=n>size</span><span class=p>){}</span> <span class=c1>// 等价定义
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=main处理命令行选项>main处理命令行选项<a hidden class=anchor aria-hidden=true href=#main处理命令行选项>¶</a></h3><ul><li><code>int main(int argc, char *argv[]) {}</code><ul><li>argc代表参数的个数；argv是一个数组，数组元素是char*（或者说char数组），第一个元素是程序的名字或一个空字符串，</li></ul></li></ul><h3 id=可变形参>可变形参<a hidden class=anchor aria-hidden=true href=#可变形参>¶</a></h3><ul><li>处理不同数量实参的函数<ul><li>如果所有实参类型相同，可以传递一个<code>initializer_list</code>标准库类型</li><li>如果实参类型不同，可以定义可变参数模板</li><li>省略符形参：<code>void func(param_list, ...)</code><ul><li>一般只用于与C函数交互的接口程序，便于CPP访问某些C代码</li><li>大多数类类型的对象在传递给省略符形参时都无法正确拷贝</li><li>省略符形参对应的实参无须类型检查</li></ul></li></ul></li><li><code>initializer_list</code>：定义在同名头文件中的模板类型<ul><li><code>initializer_list</code>与vector类似，但是它元素永远是常量</li><li><code>initializer_list</code>只能使用列表初始化</li><li>含有<code>initializer_list</code>形参的函数也可以有其他形参</li><li>其他容器使用列表初始化本质上都是采用了<code>initializer_list</code>形参的构造函数进行初始化的</li><li><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=67eed969-0ae3-b578-5007-a926384feff5&amp;page=224&amp;rect=218.650,632.400,316.320,640.080">initializer_list 提供的操作</a>：<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>lst1</span><span class=p>,</span> <span class=n>lst2</span><span class=p>;</span><span class=c1>//默认初始化:空列表 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>initlst</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>};</span><span class=c1>//initlast 的元素数量与初始值一样多
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>lst1</span><span class=p>(</span><span class=n>initlst</span><span class=p>);</span> <span class=c1>// 直接初始化，lst1与initlst共享元素（不会复制）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>lst2</span><span class=p>(</span><span class=n>initlst</span><span class=p>);</span> <span class=c1>// 赋值初始化，lst2与initlst共享元素（不会复制）
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span> <span class=n>lst</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=p>{</span><span class=sc>&#39;a&#39;</span><span class=p>,</span> <span class=sc>&#39;b&#39;</span><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><h2 id=63-返回类型和return语句>6.3 返回类型和return语句<a hidden class=anchor aria-hidden=true href=#63-返回类型和return语句>¶</a></h2><ul><li>不要返回局部对象的引用或指针</li><li><strong>引用返回左值</strong>：调用一个返回引用的函数得到左值，其他返回类型得到右值。</li><li>列表初始化返回值：函数可以返回花括号包围的值的列表，并对函数返回的临时量进行初始化。<ul><li><code>vector&lt;int> func() { return {"a", "b", "c"}; }</code></li><li>这样可以减少一次拷贝？<ul><li>相关：RVO</li><li>参考：《程序员的自我修养》P305（声明狼藉的C++返回对象）</li></ul></li></ul></li><li>main的返回值：cstdlib头文件定义了两种预处理变量来表示成功（<code>EXIT_FAILURE</code>）与失败（<code>EXIT_SUCCESS</code>）</li></ul><h3 id=返回数组指针>返回数组指针<a hidden class=anchor aria-hidden=true href=#返回数组指针>¶</a></h3><ul><li>取别名比较方便</li><li>可以使用尾置返回类型</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdio&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// int ( *p )[10]; // 数组指针：指向数组的指针
</span></span></span><span class=line><span class=cl><span class=c1>// int ( *func(params) )[10]; // 返回数组指针：函数参数是params，返回指向int[10]的数组指针
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 形式： Type (*function (parameter_list))[dimension]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=p>(</span> <span class=o>*</span><span class=n>func1</span><span class=p>(</span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>)[</span><span class=mi>5</span><span class=p>])</span> <span class=p>)[</span><span class=mi>5</span><span class=p>]{</span> <span class=c1>// 传入数组指针，返回数组指针, int (*arr)[5]是传入的数组指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>it</span> <span class=o>=</span> <span class=n>begin</span><span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>),</span> <span class=o>*</span><span class=n>ed</span> <span class=o>=</span> <span class=n>end</span><span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>);</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>ed</span><span class=p>;</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=o>*</span><span class=n>it</span><span class=p>)</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 使用类型别名进行简化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>arrT</span> <span class=o>=</span> <span class=kt>int</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// typedef int arrT[10]; // 感觉没有using直观
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>arrT</span><span class=o>*</span> <span class=nf>func2</span><span class=p>(</span><span class=n>arrT</span><span class=o>*</span> <span class=n>arr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>){</span> <span class=c1>// 使用别名，传入数组指针，返回数组指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>)[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 数组指针解引用得到数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 使用尾置返回类型，简化函数的声明和定义（尤其当返回值比较复杂时）
</span></span></span><span class=line><span class=cl><span class=c1>// 在形参列表后面跟一个-&gt;，表示真正的返回值类型跟在形参列表之后，开头返回值用auto代替
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=nf>func3</span><span class=p>(</span> <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>)[</span><span class=mi>5</span><span class=p>]</span> <span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)[</span><span class=mi>5</span><span class=p>]{</span> 
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>it</span> <span class=o>=</span> <span class=n>begin</span><span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>),</span> <span class=o>*</span><span class=n>ed</span> <span class=o>=</span> <span class=n>end</span><span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>);</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>ed</span><span class=p>;</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=o>*</span><span class=n>it</span><span class=p>)</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 还可以使用 `decltype`，见P206
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>};</span> 
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>)[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>arr</span><span class=p>;</span> <span class=c1>// p是指向数组的指针， p的内容是数组首地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>arrT</span><span class=o>*</span> <span class=n>pp</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>arr</span><span class=p>;</span> <span class=c1>// pp同样是数组的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>a</span><span class=p>)[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=n>func1</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>it</span> <span class=o>=</span> <span class=n>begin</span><span class=p>(</span><span class=o>*</span><span class=n>a</span><span class=p>),</span> <span class=o>*</span><span class=n>ed</span> <span class=o>=</span> <span class=n>end</span><span class=p>(</span><span class=o>*</span><span class=n>a</span><span class=p>);</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>ed</span><span class=p>;</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span> <span class=n>cout</span><span class=o>&lt;&lt;*</span><span class=n>it</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>aa</span><span class=p>)[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=n>func2</span><span class=p>(</span><span class=n>pp</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>it</span> <span class=o>=</span> <span class=n>begin</span><span class=p>(</span><span class=o>*</span><span class=n>aa</span><span class=p>),</span> <span class=o>*</span><span class=n>ed</span> <span class=o>=</span> <span class=n>end</span><span class=p>(</span><span class=o>*</span><span class=n>aa</span><span class=p>);</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>ed</span><span class=p>;</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span> <span class=n>cout</span><span class=o>&lt;&lt;*</span><span class=n>it</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>a3</span><span class=p>)[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=n>func3</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>it</span> <span class=o>=</span> <span class=n>begin</span><span class=p>(</span><span class=o>*</span><span class=n>a3</span><span class=p>),</span> <span class=o>*</span><span class=n>ed</span> <span class=o>=</span> <span class=n>end</span><span class=p>(</span><span class=o>*</span><span class=n>a3</span><span class=p>);</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>ed</span><span class=p>;</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span> <span class=n>cout</span><span class=o>&lt;&lt;*</span><span class=n>it</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=64-函数重载>6.4 函数重载<a hidden class=anchor aria-hidden=true href=#64-函数重载>¶</a></h2><ul><li>语法相关：<ul><li>不允许两个函数除了返回类型以外的其他所有要素都相同，或者说返回值与重载无关</li><li>因为[[ch06-函数#^f06638|形参的顶层const被忽略]]，所以在重载函数中，一个有顶层const形参，另一个重载函数相应参数是普通形参，相当于重复声明，但是可以区分底层const。<a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=4f33a9d7-1eec-b511-c252-e9aeb4459a80&amp;page=234&amp;rect=115.200,519.130,429.360,526.810">例子</a></li></ul></li><li>使用：<ul><li>一个函数的形参可能有常量引用和非常量引用两种版本，可以使用const_cast进行类型的转换<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>func</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span><span class=cm>/* do something*/</span><span class=p>}</span> <span class=c1>// 底层const
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=nf>func</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>r</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=k>const_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>s</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li>重载和作用域：因为C++中名字查找发生在类型检查之间，所以编译器一旦在当前作用域内找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。<ul><li>因此，不同的重载版本要定义在同一作用域中，一般是全局作用域</li></ul></li></ul></li></ul><h2 id=65-特殊用途语言特性>6.5 特殊用途语言特性<a hidden class=anchor aria-hidden=true href=#65-特殊用途语言特性>¶</a></h2><h3 id=默认实参>默认实参<a hidden class=anchor aria-hidden=true href=#默认实参>¶</a></h3><ul><li>形参顺序：普通形参，不怎么使用默认值的形参，经常使用默认值的形参<ul><li>设置默认值的形参必须放在没有默认值的形参之后</li><li>一旦某个形参被赋予（或使用）默认值，那么它之后的形参都必须要有默认值</li></ul></li><li>虽然多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>screen</span><span class=p>(</span><span class=kt>int</span> <span class=n>w</span><span class=p>,</span> <span class=kt>int</span> <span class=n>h</span><span class=p>,</span> <span class=kt>char</span> <span class=n>c</span><span class=o>=</span><span class=sc>&#39; &#39;</span><span class=p>);</span> <span class=c1>// 第一次声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>screen</span><span class=p>(</span><span class=kt>int</span> <span class=n>w</span><span class=p>,</span> <span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=mi>80</span><span class=p>,</span> <span class=kt>char</span> <span class=n>c</span><span class=p>);</span> <span class=c1>// 第二次声明，添加了默认实参
</span></span></span></code></pre></td></tr></table></div></div></li><li>默认实参只能出现在函数声明和定义其中一处，通常应该在头文件中的函数声明中指定默认实参。</li><li>局部变量不能作为函数的默认实参，全局变量和字面值都可以</li></ul><h3 id=内联inline函数>内联（inline）函数<a hidden class=anchor aria-hidden=true href=#内联inline函数>¶</a></h3><ul><li>在函数声明和定义中都能使用关键字inline，但是建议只在函数定义时使用。</li><li>一般来说，内联机制适用于优化规模较小、流程直接、调用频繁的函数。内联函数中不允许有循环语句和switch语句，否则函数会被编译为普通函数。</li></ul><h3 id=constexpr-函数obsidianbooknotetypeannotationbookcpp_primer-e99885e8afbbe7ac94e8aeb0primer20ce7acac5e78988pdfid08ac9451-c1bd-d611-0716-98d876b07c54page240rect62650382800131280391200><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=08ac9451-c1bd-d611-0716-98d876b07c54&amp;page=240&amp;rect=62.650,382.800,131.280,391.200">constexpr 函数</a><a hidden class=anchor aria-hidden=true href=#constexpr-函数obsidianbooknotetypeannotationbookcpp_primer-e99885e8afbbe7ac94e8aeb0primer20ce7acac5e78988pdfid08ac9451-c1bd-d611-0716-98d876b07c54page240rect62650382800131280391200>¶</a></h3><p>不是很理解，个人理解是在编译器就能确定返回值的函数</p><ul><li>内联函数和constexpr函数通常定义在头文件中。</li></ul><h3 id=调试帮助>调试帮助<a hidden class=anchor aria-hidden=true href=#调试帮助>¶</a></h3><p>调试帮助：用类似头文件保护的方式，有选择的执行调试代码。即在开发过程中，程序可以包含一些用于调试的代码，当程序发布时，需要先屏蔽掉调试代码。调试帮助通常包含两种预处理功能：<code>assert</code>和<code>DNEBUG</code></p><ul><li><code>assert</code>是一种预处理宏（preprocessor macro）：<code>assert(expr);</code><ul><li>当表达式为假时，assert输出信息并终止程序；如果真，assert什么都不做</li><li>常用来检查不能发生的条件</li></ul></li><li><code>NDEBUG</code>预处理变量：关闭调试状态<ul><li>可以使用<code>#define NDEBUG</code>来定义<code>NDEBUG</code>，但很多编译器都提供了命令行选项<code>-D NDEBUG</code></li><li>如果定义了<code>NDEBUG</code>，则assert什么都不做；默认情况下没有定义<code>NDEBUG</code></li><li>几个用于调试的变量名称：</li></ul></li></ul><table><thead><tr><th style=text-align:center>变量名称</th><th style=text-align:center>内容</th></tr></thead><tbody><tr><td style=text-align:center><code>__func__</code></td><td style=text-align:center>当前函数名称</td></tr><tr><td style=text-align:center><code>__FILE__</code></td><td style=text-align:center>当前文件名称</td></tr><tr><td style=text-align:center><code>__LINE__</code></td><td style=text-align:center>当前行号</td></tr><tr><td style=text-align:center><code>__TIME__</code></td><td style=text-align:center>文件编译时间</td></tr><tr><td style=text-align:center><code>__DATE__</code></td><td style=text-align:center>文件编译日期</td></tr></tbody></table><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=cp>#ifndef NDEBUG </span><span class=c1>// 默认情况下没有定义NDEBUG，可以在这里编写自己的调试代码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 如果定义了NDEBUG，则跳过
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=n>__func__</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;...&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=66-函数匹配>6.6 函数匹配<a hidden class=anchor aria-hidden=true href=#66-函数匹配>¶</a></h2><p><a href="obsidian://booknote?type=annotation&amp;book=Cpp_Primer-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Primer%20C++(%E7%AC%AC5%E7%89%88).pdf&amp;id=ff2868c8-59a4-9b72-c42c-92a021d43cec&amp;page=235&amp;rect=350.170,216.730,389.050,225.850">函数匹配</a>（或称为重载确定）</p><ul><li>重载函数匹配的三个步骤：<ul><li>找候选函数：同名函数</li><li>选可行函数：形参实参数量相等，类型匹配或者能进行转换</li><li>寻找最佳匹配：实参类型和形参类型越接近，它们匹配越好<ul><li>精确匹配、从数组类型或函数类型转换为对应的指针类型、添加/删除顶层const</li><li>const转换</li><li>类型提升</li><li>算数类型转换、指针转换</li><li>类类型转换</li></ul></li><li>如果有若干个匹配，但没有一个最佳匹配时，编译器可能报告二义性调用的信息</li></ul></li></ul><h2 id=67-函数指针>6.7 函数指针<a hidden class=anchor aria-hidden=true href=#67-函数指针>¶</a></h2><ul><li>对于重载函数，函数指针类型必须与重载函数中某一个精确匹配<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=k>using</span> <span class=n>Func</span> <span class=o>=</span> <span class=kt>int</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> <span class=c1>// 函数类型
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>typedef</span> <span class=kt>int</span> <span class=nf>Func2</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> <span class=c1>// 函数类型，等价于Func
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>using</span> <span class=n>FuncP</span> <span class=o>=</span>  <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> <span class=c1>// 函数指针类型
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>typedef</span> <span class=nf>int</span> <span class=p>(</span><span class=o>*</span><span class=n>FuncP2</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> <span class=c1>// 函数指针类型，等价于FuncP
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=nf>add</span><span class=p>(</span><span class=kt>double</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>op1</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>,</span> <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>f</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=n>f</span><span class=p>)(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>op2</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>,</span> <span class=n>Func</span><span class=o>*</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=n>f</span><span class=p>)(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);}</span> <span class=c1>// 函数不能做形参
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=nf>op3</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>,</span> <span class=n>FuncP</span> <span class=n>fp</span><span class=p>)</span> <span class=p>{</span><span class=k>return</span> <span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>test</span><span class=p>()</span> <span class=p>{</span><span class=k>return</span> <span class=mi>1</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>  <span class=k>typedef</span> <span class=nf>decltype</span><span class=p>(</span><span class=n>test</span><span class=p>)</span> <span class=n>FuncT</span><span class=p>;</span> <span class=c1>// 函数类型
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>typedef</span> <span class=nf>decltype</span><span class=p>(</span><span class=n>test</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=n>FuncTP</span><span class=p>);</span> <span class=c1>// 函数指针类型，decltype返回函数类型，需要在别名类型前加上*表示函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>      <span class=n>Func</span> <span class=o>*</span><span class=n>f</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>FuncP</span> <span class=n>g</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>cout</span><span class=o>&lt;&lt;</span><span class=n>op1</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=n>add</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>op2</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=n>f</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=s>&#34; &#34;</span><span class=o>&lt;&lt;</span><span class=n>op3</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=n>g</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li>函数指针可以作为形参<ul><li>形参类型可能为函数类型，传入的也可能是函数名，但是最终都是转换为函数指针</li></ul></li><li>函数指针可以作为返回值，函数类型不可以作为返回值</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>Func</span> <span class=o>=</span> <span class=kt>int</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> <span class=c1>// 函数类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>FuncP</span> <span class=o>=</span>  <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> <span class=c1>// 函数指针类型
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>ret_func1</span><span class=p>(</span><span class=n>params</span><span class=p>))</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> <span class=c1>// 一个名为ret_func1的函数，其参数为params，返回一个int(*)(int, int)类型的函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=nf>ret_func2</span><span class=p>(</span><span class=n>params</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> <span class=c1>// 尾置返回类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Func</span><span class=o>*</span> <span class=nf>ret_func3</span><span class=p>(</span><span class=n>params</span><span class=p>);</span> <span class=c1>// 使用别名，返回指向函数类型的指针，不能返回Func
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>FuncP</span> <span class=nf>ret_func4</span><span class=p>(</span><span class=n>params</span><span class=p>);</span> <span class=c1>// 使用别名，返回函数指针
</span></span></span></code></pre></td></tr></table></div></div><ul><li>复杂例子：假设函数指针类型是<code>int(*)(int, int)</code>，数组指针类型是<code>int (*)[5]</code><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>FuncP</span> <span class=o>=</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>Arr</span> <span class=o>=</span> <span class=kt>int</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>返回值是函数指针，函数形参是数组指针<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span> <span class=o>*</span><span class=n>f</span><span class=p>(</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=p>)</span> <span class=p>)</span> <span class=p>)</span> <span class=p>(</span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=p>)[</span><span class=mi>5</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=nf>f</span><span class=p>(</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>)[</span><span class=mi>5</span><span class=p>]</span> <span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>FuncP</span> <span class=nf>f</span><span class=p>(</span><span class=n>Arr</span><span class=o>*</span> <span class=n>arr</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li>返回值是函数指针，函数形参是函数指针<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>f</span><span class=p>(</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>))</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=nf>f</span><span class=p>(</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>FuncP</span> <span class=nf>f</span><span class=p>(</span><span class=n>FuncP</span> <span class=n>fp</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li>返回值是数组指针，函数形参是函数指针<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span> <span class=o>*</span><span class=n>f</span><span class=p>(</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>)</span> <span class=p>)[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=nf>f</span><span class=p>(</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>Arr</span><span class=o>*</span> <span class=nf>f</span><span class=p>(</span><span class=n>FuncP</span> <span class=n>fp</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li>返回值是数组指针，函数形参是数组指针<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>f</span><span class=p>(</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>)[</span><span class=mi>5</span><span class=p>]</span> <span class=p>))[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=nf>f</span><span class=p>(</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=n>arr</span><span class=p>)[</span><span class=mi>5</span><span class=p>]</span> <span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>Arr</span><span class=o>*</span> <span class=nf>f</span><span class=p>(</span><span class=n>Arr</span><span class=o>*</span> <span class=n>arr</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://qinganzhang.github.io/posts/cpp-primer/ch07-%E7%B1%BB/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Ch07 类</span>
</a><a class=next href=https://qinganzhang.github.io/posts/cpp-primer/ch05-%E8%AF%AD%E5%8F%A5/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Ch05 语句</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://qinganzhang.github.io/>Paul's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>