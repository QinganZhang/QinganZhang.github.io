<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>计算机架构科普和梳理 | Paul's Blog</title>
<meta name=keywords content="architecture"><meta name=description content="指令集架构 指令集 说明了操作种类、指令格式（操作码和地址码，地址码个数，操作码定长与拓展）、寻址方式、地址空间大小和寄存器个数等。简单可以理解"><meta name=author content="Paul"><link rel=canonical href=https://qinganzhang.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%A7%91%E6%99%AE%E5%92%8C%E6%A2%B3%E7%90%86/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://qinganzhang.github.io/favicon.ico><link rel=apple-touch-icon href=https://qinganzhang.github.io/apple-touch-icon.png><meta name=twitter:title content="计算机架构科普和梳理 | Paul's Blog"><meta name=twitter:description content="指令集架构 指令集 说明了操作种类、指令格式（操作码和地址码，地址码个数，操作码定长与拓展）、寻址方式、地址空间大小和寄存器个数等。简单可以理解"><meta property="og:title" content="计算机架构科普和梳理 | Paul's Blog"><meta property="og:description" content="指令集架构 指令集 说明了操作种类、指令格式（操作码和地址码，地址码个数，操作码定长与拓展）、寻址方式、地址空间大小和寄存器个数等。简单可以理解"><meta property="og:type" content="article"><meta property="og:url" content="https://qinganzhang.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%A7%91%E6%99%AE%E5%92%8C%E6%A2%B3%E7%90%86/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-29T14:52:29+08:00"><meta property="article:modified_time" content="2024-02-29T14:52:29+08:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Post","item":"https://qinganzhang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"计算机架构科普和梳理","item":"https://qinganzhang.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%A7%91%E6%99%AE%E5%92%8C%E6%A2%B3%E7%90%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"计算机架构科普和梳理 | Paul's Blog","name":"计算机架构科普和梳理","description":"指令集架构 指令集 说明了操作种类、指令格式（操作码和地址码，地址码个数，操作码定长与拓展）、寻址方式、地址空间大小和寄存器个数等。简单可以理解","keywords":["architecture"],"wordCount":"4630","inLanguage":"en","datePublished":"2024-02-29T14:52:29+08:00","dateModified":"2024-02-29T14:52:29+08:00","author":{"@type":"Person","name":"Paul"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qinganzhang.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%A7%91%E6%99%AE%E5%92%8C%E6%A2%B3%E7%90%86/"},"publisher":{"@type":"Organization","name":"Paul's Blog","logo":{"@type":"ImageObject","url":"https://qinganzhang.github.io/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://qinganzhang.github.io/ accesskey=h title="Paul's Blog (Alt + H)">Paul's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://qinganzhang.github.io/posts/ title=Posts class=active>Posts</a></li><li><a href=https://qinganzhang.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://qinganzhang.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://qinganzhang.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://qinganzhang.github.io/categories/ title=Categories>Categories</a></li><li><a href=https://qinganzhang.github.io/about/ title=About>About</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://qinganzhang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://qinganzhang.github.io/posts/>Post</a></div><h1 class=post-title>计算机架构科普和梳理</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2024-02-29</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://qinganzhang.github.io/tags/architecture/>architecture</a></span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>4630 words</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>10 min</span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%8c%87%e4%bb%a4%e9%9b%86%e6%9e%b6%e6%9e%84 aria-label=指令集架构>指令集架构</a><ul><li><a href=#%e6%8c%87%e4%bb%a4%e9%9b%86 aria-label=指令集>指令集</a></li><li><a href=#%e5%a4%8d%e6%9d%82%e6%8c%87%e4%bb%a4%e9%9b%86cisc aria-label=复杂指令集CISC>复杂指令集CISC</a></li><li><a href=#%e7%b2%be%e7%ae%80%e6%8c%87%e4%bb%a4%e9%9b%86risc aria-label=精简指令集RISC>精简指令集RISC</a></li></ul></li><li><a href=#%e5%be%ae%e6%9e%b6%e6%9e%84 aria-label=微架构>微架构</a></li><li><a href=#%e8%ae%a1%e7%ae%97%e6%9c%ba%e6%9e%b6%e6%9e%84 aria-label=计算机架构>计算机架构</a></li><li><a href=#%e7%89%b9%e5%88%ab%e4%bb%8b%e7%bb%8darm aria-label=特别介绍：ARM>特别介绍：ARM</a><ul><li><a href=#arm%e5%95%86%e4%b8%9a%e5%8f%91%e5%b1%95 aria-label=ARM商业发展>ARM商业发展</a></li><li><a href=#arm%e5%a4%84%e7%90%86%e5%99%a8 aria-label=ARM处理器>ARM处理器</a></li><li><a href=#android aria-label=Android>Android</a><ul><li><a href=#%e7%ae%80%e4%bb%8b aria-label=简介>简介</a></li><li><a href=#%e7%89%88%e6%9c%ac aria-label=版本>版本</a></li></ul></li></ul></li><li><a href=#%e5%b7%a5%e5%85%b7%e9%93%be aria-label=工具链>工具链</a><ul><li><a href=#makefile aria-label=Makefile>Makefile</a></li><li><a href=#cmake aria-label=CMake>CMake</a></li><li><a href=#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5 aria-label=最佳实践>最佳实践</a><ul><li><a href=#%e9%a1%b9%e7%9b%ae%e9%85%8d%e7%bd%ae aria-label=项目配置>项目配置</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=指令集架构>指令集架构<a hidden class=anchor aria-hidden=true href=#指令集架构>¶</a></h2><h3 id=指令集>指令集<a hidden class=anchor aria-hidden=true href=#指令集>¶</a></h3><p>说明了操作种类、指令格式（操作码和地址码，地址码个数，操作码定长与拓展）、寻址方式、地址空间大小和寄存器个数等。简单可以理解为汇编指令用01表示。</p><blockquote><p>CPU位数=CPU中寄存器的位数=数据总线宽度</p></blockquote><ul><li><p>硬件厂商开发某种指令集的CPU，需要该指令集专利持有者进行授权</p><ul><li><p>比如ARM公司自己的研发指令集叫ARM指令集，对外授权（同时ARM公司还进行微架构的授权）</p></li><li><p>一些大型公司都获得ARM公司针对ARM指令集的授权，开发兼容ARM指令集的不同的微架构</p><ul><li>比如Intel授权AMD可以生产兼容x86指令集的CPU</li></ul></li></ul></li><li><p>编译：高级语言翻译成特定ISA的机器码</p></li><li><p>参考</p><ul><li><a href=https://zhuanlan.zhihu.com/p/19893066>关于CPU、指令集、架构、芯片的一些科普</a></li></ul></li></ul><h3 id=复杂指令集cisc>复杂指令集CISC<a hidden class=anchor aria-hidden=true href=#复杂指令集cisc>¶</a></h3><ul><li><p>x86：在1978年的Intel 8086 CPU（16位）指令集基础上，发展而来的一些列指令集的泛称</p><ul><li>桌面级CPU一般都是x86的，兼容8086指令集</li></ul></li><li><p>IA-32(x86,i386)：Intel将16位的x86拓展为32位的IA-32，但是由于IA-32的统治地位，x86也一般指IA-32的CPU</p><ul><li>Intel 80386是第一款i386 CPU（第一款IA-32架构的CPU）<ul><li>i386，i486：即Intel 80386， Intel 80486</li><li>Pentium（i586）：Intel 80586</li><li>Pentium Pro（Pentium Ⅱ，i686）：Intel 80686</li></ul></li><li>此后，x86成为一些列架构的泛称，不限于16位，32位，64位</li></ul></li><li><p>IA-64：1994年Intel推出的与x86完全无关的新架构（也不兼容之），基于显式并行指令运算（EPIC）的64位指令集架构</p><ul><li>2001年发布第一款基于IA-64的CPU，叫Itanium安腾，IA-64也称为Intel Itanium</li><li>但是由于软件环境的缺乏和AMD的竞争，导致市场不好</li></ul></li><li><p>x86-64(x64)：1999年，AMD推出x86-64架构（简称x64），是对IA-32(x86)的兼容和拓展</p><ul><li><p>2003年AMD发布的一款基于x86-64的CPU，x86-64也称为AMD64</p></li><li><p>后来Intel也用AMD64架构，称为IA-32e(IA-32 extension)，后来又叫Intel64</p></li><li><p>x86-64, x64, AMD64, Intel64, IA-32e(IA-32 extension)基本是一个东西</p><ul><li><p>苹果公司和 <code>RPM</code> 包管理员以 <code>x86-64</code> 或 <code>x86_64</code> 称呼此 <code>64</code> 位架构。甲骨文公司及 <code>Microsoft</code> 称之为<code>x64</code>。<code>BSD</code> 家族及其他 <code>Linux</code> 发行版则使用 <code>amd64</code>，<code>32</code> 位版本则称为<code>i386</code>（或 <code>i486/586/686</code>），<code>Arch Linux</code> 用<code>x86_64</code> 称呼此 <code>64</code> 位架构。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/113157931#:~:text=CPU%20%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84%E7%9B%AE%E5%89%8D%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%A4%E5%A4%A7%E7%B1%BB%E3%80%82%20%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86%E6%98%AF%20x86%20%E3%80%81%20x64%20%28%E4%B9%9F%E5%8F%AB%20x86-64%2C,%E4%B8%80%E7%A7%8D%E6%9E%B6%E6%9E%84%EF%BC%8C%E4%B8%93%E5%88%A9%E5%9C%A8%20ARM%20%E5%85%AC%E5%8F%B8%E6%89%8B%E9%87%8C%EF%BC%8C%E8%AF%A5%E6%9E%B6%E6%9E%84%20CPU%20%E4%B8%BB%E8%A6%81%E6%9C%89%E9%AB%98%E9%80%9A%E3%80%81%E4%B8%89%E6%98%9F%E3%80%81%E8%8B%B9%E6%9E%9C%E3%80%81%E5%8D%8E%E4%B8%BA%E6%B5%B7%E6%80%9D%E3%80%81%E8%81%94%E5%8F%91%E7%A7%91%E7%AD%89%E5%85%AC%E5%8F%B8%E3%80%82%20%E8%BF%99%E7%A7%8D%20CPU%20%E5%B8%B8%E7%94%A8%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8A%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%AE%89%E5%8D%93%E5%92%8C%E8%8B%B9%E6%9E%9C%E3%80%82">x86,x64,x86-64,amd64,arm指令集架构之间的关系</a>中x86 架构发展</p></blockquote></li></ul></li></ul></li><li><p>参考</p><ul><li><a href=https://www.jianshu.com/p/70872b91ab46>i386、i486、i586、 i686、 x86、x86_64、x64、amd_64详解【写的很好】</a></li></ul></li></ul><h3 id=精简指令集risc>精简指令集RISC<a hidden class=anchor aria-hidden=true href=#精简指令集risc>¶</a></h3><ul><li>ARM<ul><li>ARMv3~ARMv7都是32位</li><li>ARMv8：向前兼容32位指令，同时<ul><li>AArch64：64位执行状态，使用全新的ARM 64位指令集</li><li>AArch32：32位执行状态</li></ul></li></ul></li><li>RISC-V：伯克利发明的一种基于RISC的开源指令集架构<ul><li><a href=https://www.sohu.com/a/225906734_132567>一文看懂RISC-V</a></li></ul></li><li>MIPS</li><li>PowerPC</li></ul><h2 id=微架构>微架构<a hidden class=anchor aria-hidden=true href=#微架构>¶</a></h2><ul><li>微架构：硬件电路（或CPU单个核心core）的结构和实现</li><li>CPU研发能力一般指的是独立的微架构研发能力，是否使用自行研发的指令集关系不大<ul><li>研发兼容的指令集可以没有获得授权，指令集的研发不是很难，但是之后获得授权后才能合法销售</li><li>微架构的设计细节是保密且复杂的</li><li>SoC（System on Chip）封装相对简单</li></ul></li><li>商业模式<ul><li>之前在PC时代，CPU研发厂商自己的微架构只有自己用</li><li>后来在智能设备时代，ARM公司将自己的微架构出售，其他厂商可以拿来组装，比如Cortex系列核心</li><li>由于ARM公司的成功，ARM公司针对PC领域发布了ARM v8 64位指令集<ul><li>以前ARM适合低功耗的场景，随着技术进步，指令集对微架构的影响越来越小</li></ul></li></ul></li><li>指令集的选择：倾向于选择软件生态良好的指令集<ul><li>以前获得指令集的授权很困难，主要通过技术交换的形式（指令集多授权一家，就多一个对手）</li><li>后来ARM对指令集授权略微放松</li></ul></li><li>参考：<ul><li><a href=https://www.jianshu.com/p/c80850ccfb27>指令集、微架构、手机芯片(Soc)及ARM的介绍(偏硬件科普)</a></li></ul></li></ul><h2 id=计算机架构>计算机架构<a hidden class=anchor aria-hidden=true href=#计算机架构>¶</a></h2><ul><li>冯.诺伊曼架构：程序和指令存储在一起</li><li>哈佛架构：程序和指令分开存储<ul><li>比如单片机（51单片机，STM32单片机），Cortex-M系列</li></ul></li><li>现代处理器架构一般指令和数据共享存储，但是CPU内部缓存分开</li></ul><h2 id=特别介绍arm>特别介绍：ARM<a hidden class=anchor aria-hidden=true href=#特别介绍arm>¶</a></h2><h3 id=arm商业发展>ARM商业发展<a hidden class=anchor aria-hidden=true href=#arm商业发展>¶</a></h3><ul><li><p>由于商业需要，1985年，Acorn公司基于RISC，自研CPU（包括指令集和微架构），称为ARM（Acorn RISC Machine），型号命名为ARM1（对标80286）</p></li><li><p>后来，Acorn公司和苹果公司联合成立了一家叫ARM（Advanced RISC Machines）的公司，开启新的产品策略：授权</p><blockquote><p>传统商业模式：</p><ul><li>IDM(Integrated Design and Manufacture)：从设计，到制造、封装测试以及投向消费市场一条龙全包，比如Intel</li><li>无工厂模式Fabless：自己设计，制造交给代工厂，比如AMD，NVIDIA</li><li>Foundry：只做代工</li></ul></blockquote><ul><li>使用层级授权（处理器授权）：只能买来已经封装好的CPU，不能更改原来设计，可以配置的地方不多</li><li>内核层级授权（POP授权）：以一个内核（或IP核）为基础然后在加上自己的外设</li><li>架构层级授权：授权使用ARM指令集，可以修改指令集，但是比较贵<ul><li>比如华为基于ARMv8，自研达芬奇架构</li></ul></li></ul></li><li><p>后来ARM公司越来越成功，苹果公司逐渐卖掉其股份，开发ipod（基于ARM指令集）。</p><ul><li>2007年，苹果公司发布iphone，基于ARM指令集</li><li>2008年，谷歌发布Android系统，也是基于ARM指令集</li></ul></li><li><p>2016年，ARM公司被软银集团收购</p></li><li><p>参考</p><ul><li><a href=https://www.zhihu.com/question/296178433/answer/692275926>如何看待观点「华为没有核心技术，因为芯片用的是ARM（安谋）架构，一旦被停止授权，就会做不出芯片」？</a></li><li><a href=https://zhuanlan.zhihu.com/p/266092621>【推荐】到底什么是Cortex、ARMv8、arm架构、ARM指令集、soc？一文帮你梳理基础概念【科普】</a></li></ul></li></ul><h3 id=arm处理器>ARM处理器<a hidden class=anchor aria-hidden=true href=#arm处理器>¶</a></h3><blockquote><p>一般处理器就是指CPU</p><p>但是ARM处理器指的是单个核（或IP核，或内核），因为厂商可以在IP核上进一步封装，最终CPU不尽相同</p><blockquote><p>IP核，全称知识产权核（英语：intellectual property core），是在集成电路的可重用设计方法学中，指某一方提供的、形式为逻辑单元、芯片设计的可重用模组。IP核通常已经通过了设计验证，设计人员以IP核为基础进行设计，可以缩短设计所需的周期。</p></blockquote><p>参考：</p><ul><li><a href=https://zhuanlan.zhihu.com/p/362648496>armv7-A系列0 - arm 处理器架构发展史</a>中的处理器到底指的是什么</li><li><a href=https://zhuanlan.zhihu.com/p/266092621>到底什么是Cortex、ARMv8、arm架构、ARM指令集、soc？一文帮你梳理基础概念【科普】</a>中的ARM内核与架构</li><li><a href=https://www.jianshu.com/p/c80850ccfb27>指令集、微架构、手机芯片(Soc)及ARM的介绍(偏硬件科普)</a></li></ul></blockquote><ul><li><p>指令集架构：</p><ul><li>ARMv1~ARMv9（可以有一定的变种比如ARMv8-A）</li><li>ARMv8是首款64位的ARM指令集</li></ul></li><li><p>处理器架构</p><ul><li>ARMv3~ARMv6：<ul><li>ARM6, ARM7, ARM9, ARM11系列</li></ul></li><li>ARMv7及以后<ul><li>Cortex-A：大型嵌入式系统（手机）</li><li>Cortex-R：实时处理器</li><li>Cortex-M：单片机</li></ul></li></ul></li><li><p>参考：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/494924815#:~:text=ARM%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%20%7C%20ARM%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%201%201.%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84%20%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84%E5%91%BD%E5%90%8D%E6%A0%BC%E5%BC%8F%3A%20Armv%EF%BC%9A%E5%9B%BA%E5%AE%9A%E5%AD%97%E7%AC%A6%2C%20%E5%8D%B3ARM,x%EF%BC%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E5%88%97%2C%20%E6%9C%896%2C%207%2C%209%20%2C%2011%E7%AD%89%E5%A4%9A%E4%B8%AA%E7%B3%BB%E5%88%97%20y%EF%BC%9A%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%2F%E4%BF%9D%E6%8A%A4%E5%8D%95%E5%85%83%20">ARM基础教程 | ARM命名规则</a></p></li><li><p><a href=https://zhuanlan.zhihu.com/p/25681832>ARM 命名规则——指令架构、CPU的历史回顾</a></p></li></ul></li></ul><p>参考：</p><p><a href=https://dongka.github.io/2018/11/17/cpu/arm%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%91%E5%B1%95/>ARM体系架构概述</a></p><h3 id=android>Android<a hidden class=anchor aria-hidden=true href=#android>¶</a></h3><h4 id=简介>简介<a hidden class=anchor aria-hidden=true href=#简介>¶</a></h4><ul><li><p>Android是一个开源的，基于Linux的移动设备操作系统，主要使用于移动设备</p></li><li><p>谷歌在2007年发布了第一个测试版本的 Android 软件开发工具包（SDK），第一个商业版本的 Android 1.0，则发布于2008年9月。</p></li><li><p>Android 应用程序一般使用 Android 软件开发工具包，采用 Java 语言来开发。</p></li></ul><h4 id=版本>版本<a hidden class=anchor aria-hidden=true href=#版本>¶</a></h4><ul><li><p><a href="https://developer.android.com/about/versions?hl=zh-cn">Android版本</a>（版本代号）</p><ul><li>每个Android 版本对应一个Android SDK，可以类比JDK</li></ul></li><li><p>Android API版本：有利于设置和解决兼容性问题</p><p><a href="https://developer.android.com/about/versions/13/get?hl=zh-cn">Android API级别官方说明</a></p><p><a href=https://apilevels.com/>Android版本和 Android API level的对应关系</a></p></li><li><p>Android NKD</p><img src=https://cdn.jsdelivr.net/gh/QinganZhang/ImageHosting/img/2023-09-04-15:56:07.png alt=image-20230710173808296 style=zoom:80%></li></ul><h2 id=工具链>工具链<a hidden class=anchor aria-hidden=true href=#工具链>¶</a></h2><p>背景：</p><ul><li>使用GCC编译，很多时候需要手动链接（只有标准库才默认链接）</li><li>当需要链接的文件很多时，一来每次在命令行中写一遍繁琐容易出错，二来无法使用增量编译</li></ul><h3 id=makefile>Makefile<a hidden class=anchor aria-hidden=true href=#makefile>¶</a></h3><ul><li><p>背景：make命令根据编译规则进行编译，而且可以进行增量编译，makefile用于写编译规则</p></li><li><p>简要语法：</p><ul><li><a href=http://ruanyifeng.com/blog/2015/02/make.html>阮一峰make教程</a></li><li><a href=https://blog.csdn.net/Nire_Yeyu/article/details/106373974>简明make教程</a></li><li><a href=https://zhuanlan.zhihu.com/p/376493209>GNU make/Makefile 简明实用教程</a></li></ul></li><li><p>语法笔记</p><ul><li><p>make：即制作出某个指定的文件（默认makefile中第一个文件）</p><ul><li>越是接近目标文件的命令，就越是要写在前面。因为程序是按照递归的方式进行依赖文件查找的，看到第一行有一个没见过的依赖文件，就往下一行进行查找，以此类推。</li></ul></li><li><p>核心概念：目标target，前置条件prerequisite，命令command</p></li><li><p>伪目标的使用</p><ul><li><p>伪目标是一个命令，且没有前置条件：比如clean，显式使用内置目标名指定为伪目标，主要用于执行命令</p></li><li><p>伪目标是一个文件，但是前置条件有多个，且没有命令：比如生成多个文件</p></li></ul></li></ul></li></ul><h3 id=cmake>CMake<a hidden class=anchor aria-hidden=true href=#cmake>¶</a></h3><ul><li>背景：<ul><li>当工程很大的时候，手写Makefile也不简单</li><li>Makefile与平台相关，无法实现跨平台</li></ul></li><li>cmake：跨平台的项目管理工具，自动生成makefile文件，然后make构建<ul><li>手写CMakeLists.txt文件，cmake生成Makefile，然后再make构建</li></ul></li><li>cmake简要语法<ul><li><p>指令大小写无关，变量大小写相关</p></li><li><p>可以使用双引号将文件名或目录名包含其中</p></li><li><p><code>add_executable</code>：将源文件编译成可执行文件</p></li><li><p><code>add_library</code>：将源文件编译为库文件</p><ul><li>在构建时，静态库和动态库重名会导致后面的构建失败，<a href=https://blog.csdn.net/qq_34796146/article/details/108877159>参考</a></li><li><code>SET_TARGET_PROPERTIES</code>：同时构建同名的静态库和动态库</li></ul></li><li><p><code>aux_source_directory(&lt;dir> &lt;variable>)</code>：将dir目录下所有源文件的文件名存放到variable变量中</p></li><li><p><code>add_subdirectory</code>：包含一个子目录，该子目录中也有一个CMakeLists.txt文件和代码文件，它们也会被处理，同时可以指定编译输出（包含编译中间结果）的路径</p></li><li><p><code>link_directories</code>：添加共享库搜索目录</p><ul><li><code>CMAKE_LIBRARY_PATH</code>：设置库文件搜索目录，这不是cmake变量（需要在bash中设置），通过<code>FIND_LIBRARY</code>找到相应库文件</li></ul></li><li><p><code>target_link_libraries(&lt;target> &lt;items>)</code>：为库或可执行文件加入库链接</p></li><li><p><code>include_directories</code>：添加头文件搜索目录</p><ul><li><code>CMAKE_INCLUDE_PATH</code>：设置头文件搜索目录，这不是cmake变量（需要在bash中设置），通过<code>find_path</code>找到相应头文件</li></ul></li><li><p><code>target_include_directories</code>：在编译目标文件时指定头文件</p></li><li><p><code>find_</code>系列</p><ul><li><code>find_package</code>：加载外部库到项目中</li></ul></li><li><p><code>configure_file</code>：默认定义了一些编译选项的值</p></li><li><p><code>option</code>：添加编译选项（更准确是代码中的宏定义）</p></li><li><p>变量</p><ul><li>创建变量：<code>set()</code>，获取变量的值：<code>${variable}</code>，调用环境变量：<code>$ENV{}</code></li><li>追加变量的值：<code>set(SRC_LIST ${SRC_LIST} test.cpp)</code></li><li><code>PROJECT_NAME</code></li><li><code>PROJECT_BINARY_DIR、CMAKE_BINARY_DIR</code>：编译路径，当前工程的二进制路径（即编译产物会存放到该路径，一般为build所在路径）</li><li><code>PROJECT_SOURCE_DIR、CMAKE_SOURCE_DIR</code>：工程根目录，即顶层CMakeLists.txt文件的路径</li><li><code>EXECUTABLE_OUTPUT_PATH</code>：编译生成的可执行文件的路径</li><li><code>LIBRARY_OUTPUT_PATH</code>：编译生成的共享库文件的路径</li></ul></li></ul></li></ul><h3 id=最佳实践>最佳实践<a hidden class=anchor aria-hidden=true href=#最佳实践>¶</a></h3><h4 id=项目配置>项目配置<a hidden class=anchor aria-hidden=true href=#项目配置>¶</a></h4><ul><li>在源文件同级目录下建立目录build，在build中<ul><li><code>cmake ..</code>：将cmake得到的中间文件保存在build文件夹中，需要重新构建直接删除文件夹</li><li><code>make</code>：构建，可以使用<code>make clean</code>清除中间文件，重新构建</li></ul></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://qinganzhang.github.io/posts/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Leetcode刷题记录</span>
</a><a class=next href=https://qinganzhang.github.io/posts/hugo+github_pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Hugo+Github Pages搭建个人博客</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://qinganzhang.github.io/>Paul's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>